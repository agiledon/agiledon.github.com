<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Architecture | 简单文本]]></title>
  <link href="http://agiledon.github.com/blog/tags/architecture/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2014-02-16T20:44:33+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[可视化架构与DDD]]></title>
    <link href="http://agiledon.github.com/blog/2014/01/09/visualization-architecture-and-ddd/"/>
    <updated>2014-01-09T13:57:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/01/09/visualization-architecture-and-ddd</id>
    <content type="html"><![CDATA[<p>从DDD的角度，领域逻辑的分析可以运用战略方法Bounded Context。可是，一个问题是：<strong>如何获得Bounded Context ？</strong></p>

<p>我查看了许多关于Bounded Context的书籍与文章，虽然都着重强调了它的重要性，也给出了一些实例，却对如何从需求——>Boundex Context这一点上语焉不详。</p>

<p>我的初步设想是通过绘制场景图（但并不成熟）。我认为有三种绘制场景图的方式：商业画布，体验地图和流程图。我认为，商业画布可以作为需求分析（尤其针对初创产品）的起点。商业画布如下图所示：
<img class="center" src="/images/2014/business_canvas.jpeg"></p>

<p>采用这种规范化的方式来推导商业模型，可以激发我们的灵感，理清我们的思路，以便我们思考为何要做这个产品，产品应该具备哪些功能。结合优点和缺点、成本等因素，我们可以藉此判断和决策功能的优先级，从而得到MVP。这个过程需要大量运用即时贴，让整个商业模型呈现。经过取舍后，就可以针对产品绘制场景图。此时，场景图可以采用Experience Map或流程图来体现。Experience Map的例子如下图所示：
<img class="center" src="/images/2014/experience_map.gif"></p>

<p>由于商业画布本身提供了“客户”项，我们应该创建Persona，找准人物角色的特征来“搜寻”需求。绘制了场景图后，就能够确定用例了，此时，可辅以ATDD帮助确定Story。在确定了用例后，可以识别Bounded Context，并通过Context Map确定上下文之间的关系。</p>

<!--more-->


<p>就我个人感觉，体验地图还是从Persona的角度设想系统如何使用，考虑它的用户体验。它其实符合“场景”的概念。这里可能还是要考虑：在一个完整的场景中，需要哪些参与者？但是，即使从粗粒度的角度出发，场景都可能存在多个，可能需要绘制多个场景图来逐步提炼Bounded Context。</p>

<p>关于如何运用Persona，我的同事熊子川在他的博客《<a href="http://www.tuzei8.com/2011/06/xd%E5%85%B3%E9%94%AE%E5%AD%975-persona/">XD关键字5：Persona</a>》中已有详细介绍，同样在他的博客《<a href="http://www.tuzei8.com/2012/06/agile-ux-content-strategy/">Agile UX内容策略工作坊</a>》中提出的“消费者建模”实践，指出：</p>

<blockquote><p>为了更好的理解我们选择的目标消费者，我们需要对消费者进行完整的建模，即Persona。越接近于真实的Persona帮助我们更好的理解其用户目标……Persona的重要产出物是一系列用户目标，对于同一个Persona，用户目标可能有不同，有些目标是基础核心目标，有些则是衍生性的，例如一个访问网站潜在投资者的核心目标可能是了解成为投资者的过程，而衍生性目标可能是获得一些关于公司历史信息增加信任度。</p></blockquote>

<p><img class="center" src="/images/2014/persona.jpg">
<strong>说明</strong>：本图摘自熊子川博客</p>

<p>假设我们要开发一个电子商务网站，我们就可以通过商业画布来驱动出这个产品应该具有哪些功能，它的客户有哪些等，在绘制了场景图后，可以初步得到这样的Bounded Context:
<img class="center" src="/images/2014/bounded_context.jpg"></p>

<p>然后，我利用Context Map得到了各个上下文之间的关系：
<img class="center" src="/images/2014/context_map.jpg"></p>

<p>这样，一个包图的获得就水到渠成了：
<img class="center" src="/images/2014/modules.jpeg"></p>

<p>在识别了Bounded Context以及Context之间的关系后，我们可以运用Hexagon架构（Cockburn提出的六边形架构）来展现系统的整体架构。Hexagon架构并不深入关注内部边界中领域部分，仅仅是简单的划分为Application与Domain两层。但它有助于我们获得基础设施层以及相关集成点的包结构。我们要合理地运用六边形架构。它更贴近应用逻辑架构，并可以驱动我们去发现诸多集成点，寻找集成模式。内外边界的分离也有助于我们将业务逻辑与应用逻辑分离开。这实际上符合“关注点分离”的架构原则。下图展现了六边形架构中常见的Port与Adapter：
<img class="center" src="/images/2014/Hexagon.jpg"></p>

<p>我对“可视化架构”的理解，还是要希望多通过即时贴、白板等工具来实现可视化，而非通过绘图。至少，绘图不应该成为主要的驱动力，否则，开发人员很难接受。例如，下图就是我运用Hexagon架构，并结合可视化手段分析该电子商务系统得到的应用逻辑架构，它很好地一个展现了Hexagon架构的可视化手法。
<img class="center" src="/images/2014/e_commerce.jpg"></p>

<p>在这个图中，直观地展现了如何与外部的支付系统以及物流系统的集成。例如，图中展现的Port实际上为防腐层（ACL）。为何要建立这样的一个防腐层呢，原因在于：支付与物流常常存在多个供应商，因而需要解除对供应商的绑定，并避免供应商系统的变化造成对电子商务系统的腐蚀。这是切合实际的决策。</p>

<p>这个电子商务系统需要与仓库管理系统集成。恰好在《面向模式的软件架构》卷四的第35页，给出了一个仓库管理流程控制系统的案例。书中描述的非功能性需求，即所谓质量属性包括：</p>

<blockquote><p>分布性。仓库管理流程控制系统天生就是分布式的。</p>

<p>性能。仓库管理流程控制系统不是一个“绝对的”实时系统，但性能仍与业务息息相关。对系统有整体的吞吐量要求，因此系统必须确保所有的运输指令能够被及时而有效地运行。</p>

<p>可伸缩性。不同仓库其大小可能会有很大的不同，因此仓库管理流程控制系统必须能既支持只有几千个箱子的小仓库，又要支持超过一百万个箱子的大仓库。</p>

<p>可用性。许多仓库操作采用三班倒的24/7模式工作，因此可用性是仓库管理流程控制系统对业务案例支持的关键因素。</p></blockquote>

<p>假设要设计这样的系统以支持这些质量属性。对于分布式而言，书中提出的解决方案是传统的分布式系统解决方案，即引入Broker模式，在本地建立对远程对象的代理。而对于支持并发的领域对象访问而言，则采用了Active Object模式，并引入Leader/Followers并发模型来获得可扩展。</p>

<p>我没有打算引入这么复杂的模式，而仅仅是通过引入消息队列，并为消息队列引入路由的方式，来实现系统的分布式。这其中当然会用到经典的Publisher-Subscriber模式。我对领域逻辑进行了识别，将整个仓库管理流程控制系统的领域逻辑分为三个Bounded Context。</p>

<ul>
<li><p>库存管理</p></li>
<li><p>物流控制</p></li>
<li><p>拓扑管理</p></li>
</ul>


<p>整个架构如下图所示：
<img class="center" src="/images/2014/inventory.jpeg"></p>

<p>对于库存管理而言，我认为它主要支持商品存放信息的数据管理，即获得商品数量、存放位置以及更新这些信息。对于该上下文而言，操作本身比较简单，且耗时较短。若出现大规模并发，其瓶颈也不在于获取或更新仓库信息（当然需要通过测试数据验证），而在于客户下订单后向仓库管理流程控制系统发起的发货请求。</p>

<p>我将发货请求放到了物流控制上下文中，除此之外，它还包括收货以及订单管理等。同时，对于物流控制与拓扑管理功能，基本上与具体的仓库形成了一一对应关系。此外，对于发货请求（或收货请求），并不要求很强的实时性，这使得对这些请求的异步处理成为可能。</p>

<p>物流控制由于牵涉到收货和运货，需要控制仓库的相关设备，并按照仓库的拓扑结构设定设备的路由。这说明物流控制与拓扑控制存在上下游关系，拓扑控制是上游。这两个上下文可以是Customer-Provider的关系。但它们之间不应该存在物理边界。因此，我将这两个上下文放到了同一个六边形中，而将库存管理放到了另一个单独的六边形中，以便于它们各自独立的可伸缩。</p>

<p>在库存管理与物流控制六边形之间，我引入消息队列来应对从库存管理子系统中转发而来的发货请求（发货请求实则又来自于E-Commerce的订单请求）。原则上，我针对一个物理的仓库建立一个单独的消息队列，因此库存管理在发送发货请求时，会根据商品的存放位置以及用户请求的IP地址，获得最优的仓库信息，然后通过Router将消息转发到正确的消息队列中。</p>

<p>一旦收到消息，物流控制系统作为消息队列的订阅者（或侦听器）就可以即使处理信息，进行后续的处理。</p>

<p>针对库存管理而言，我认为它是一个独立的物理边界，因此在可视化手段中，我展现为一个单独的库存管理六边形，如下图所示：
<img class="center" src="/images/2014/inventory_2.jpeg"></p>

<ul>
<li>建立了针对REST服务的端口，对应的适配器为Controller，其目的是支持E-Commerce系统。事实上，我们对E-Commerce系统进行过分析，获得的六边形架构正好与此对接。</li>
<li>建立了针对DB的端口，对应的适配器为DB Gateway，它负责访问库存管理自身的数据库。数据库持久化的消息包括商品的基本信息如SKU、商品名、数量等，以及商品存放的仓库名。</li>
<li>建立了针对Queue的端口，对应的适配器为Message Router，负责将发货请求消息路由到正确的消息队列。</li>
</ul>


<p>物流控制与拓扑管理放在同一个边界中，它是高度可伸缩的独立系统，为展现它的可伸缩性以及它与库存管理之间的集成，我在可视化手段中，展现出两个独立的六边形，如下图所示：
<img class="center" src="/images/2014/inventory_3.jpeg"></p>

<ul>
<li>针对Queue的侦听器端口，对应的适配器为Message Handler。若有必要，如为了更好的支持并发，也可以在此引入Active Object甚至Leader/Followers。</li>
<li>同样提供了针对REST的端口，对应适配器为Controller。它主要是为了支持移动终端设备、Web应用，以便于相关人员直接发出发货或收货请求。</li>
<li>同样提供了DB的端口。这个数据库是对应仓库的专有数据库，与库存管理数据库无关。</li>
<li>提供了针对设备（指仓库的设备，如叉车，箱子，运输车等）的端口，对应适配器为South Gateway。</li>
<li>提供了针对配置文件的端口，对应适配器为Configurer。此功能是为了支持拓扑信息的动态配置。</li>
<li>提供了针对外部物流系统的端口，这里为其建立了Shipping的防腐层，使其能够更好地支持各个不同的物流供应商。</li>
</ul>


<p>目前，我针对可视化架构与设计的手段仍在完善之中，并已经尝试在真实项目中实践以进行验证，并希望能够找到足够简单的方法，为架构师与开发者提供直观而又具有体验价值的沟通方式，并能形成行之有效的设计手段。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于《恰如其分的软件架构》]]></title>
    <link href="http://agiledon.github.com/blog/2013/08/29/about-just-enough-software-architecuture/"/>
    <updated>2013-08-29T10:39:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/08/29/about-just-enough-software-architecuture</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/justenough_cn.jpg">
华中科技大学出版社的徐定翔问我意见，了解我对Just Enough Software Architecture这本书的观感，看是否值得引进。时间是在2010年。从一开始，我就被书名中的Just Enough理念所吸引。它让我想起宋玉的东家姑娘，“增之一分则太长，减之一分则太短”那种不可言说的美丽。我在心里说，架构设计就需要这样。我当时并没有看到本书，只是到Amazon上找到了几篇英文原版样章。犹记得我在读到第一章介绍的RackSpace案例时那种兴奋之情。于是，我迫切地向徐定翔强烈推荐引进这本书，而我则毛遂自荐，希望能作为本书的译者。之后，我在InfoQ上看到对本书的《<a href="http://www.infoq.com/cn/articles/fairbanks-jesa">访谈和书摘</a>》，进一步加强了我翻译本书的信念。于是，出版社开始与作者Fairbanks联系，然而从此音讯如石沉大海。时针指向2011年，我对于本书是否被引进，是否由我翻译，一切未知。我觉得我可能错过了它，思之仍觉怅然。谁知到了九月，消息突然确定，而徐大编辑就不容分说地直接把原书给我寄来了。</p>

<p>拿到沉甸甸的书，第一面就为本书的装帧而惊喜。心里想，我这一辈子若能写出这样一本书，绝对值得生命走过的这一遭了。我并没有迫不及待地开始翻译，这就好似遇到珍馐美味，需得先赏其色，闻其香，然后再品其味。我每天抱着这本书饶有兴味地开始阅读之旅。阅读之旅确乎如行山阴道，沿途之美，目不暇接；可一想到翻译，这种美景就成了一种折磨，因为我害怕辜负这一美景。翻译之初我就举步维艰，那些词语放在那里，我却无法解开“封印”将它们取出来，即使取出来，却又找不到存放的合适位置。一些翻译隐隐约约浮现着，当我竭力去揭开这些词语的真面目时，无论如何用力，总也不能够着。翻译就好像那些年我们一起追过的女孩——追不到，痛苦；追到了，销魂。翻译进度像蜗牛一样的爬着，我终于决定求助了。辗转寻找了好多朋友，都以各种理由拒绝或者放弃了。翻译讲解软件架构的书，确乎不是一件轻松的事儿。那个时候，我的Buddy肖鹏正从翻译《面向模式的软件架构》第五卷的泥潭中爬了出来。每一提及他的这段翻译经历，脸上就会浮现出不堪回首的表情，如看了恐怖片。终于，事情得到转机，最开始是倪健的雪中送炭，再有高翌翔的锦上添花，随着我们这个三人组的建立，翻译才算开始走向正规，我才有了交稿的信心。</p>

<p>自从开始翻译这本书后，我与人谈架构，动辄就会提及“Just Enough，恰如其分”。我像祥林嫂一般地推介着Fairbanks提出的风险驱动模型，并认真地实践着这一模型。我开始对演进的架构有了更深入的理解。我写了《<a href="http://localhost:4000/blog/2011/10/10/design-just-enough-architecture/">设计恰如其分的架构</a>》这篇博客来详细阐述我对演进式架构的理解。在2011年我参加的技术会议上，我也反复讲解了如何遵循简单之美的原则，运用风险驱动模型设计恰如其分的架构。2012年，在我参加的一个项目中需要针对遗留系统进行技术栈迁移。我撰写了文章《<a href="http://www.infoq.com/cn/articles/legacy-system-migration">遗留系统的技术栈迁移</a>》，提到了“风险驱动模型”，并在2013年的Scrum Gathering会议上分享了我的一些想法。当然，这个模型并不是锤子，更不是银弹。它更近似于质量属性驱动的架构设计，我们要满足的质量属性，可能就是我们在做架构时需要面对的风险；而在Roy Fielding的那篇关于REST的著名论文中，也提到了对约束的识别，并演示了如何从一个空约束，通过逐步添加约束演化为REST风格的架构。从某种程度上，架构的约束可能是一种风险，也可能成为设计的驱动力。</p>

<p>前几天，我参加Agile China 2013，与我新认识的一位朋友范钢聊到了关于架构重构的问题。事实上，面向对象软件开发到现在，已有十余年之久；各种经验、模式与原则甚嚣尘上并得到较好的推广。然而新的方法、新的语言乃至新的思想仍然层出不穷，尤其是在互联网开发、大数据处理以及移动开发的冲击下，传统软件开发似乎已经开始走向末路。“只见新人笑，不见旧人哭”！？？是，也不是。实际上，在传统的企业开发领域，各种大型系统仍然像一艘庞大如巨型海兽一般的船舰在海面缓缓行驶，它或许就是沉没之前的泰坦尼克，一切还都安然无恙，你甚至可以听到船头甲板传来的悠扬的小提琴声；然而，冰川就在远处出没，船长还未察觉。我们该怎么办？这样的巨型船舰，自然不可能如艨艟快艇那般的敏捷，即使是360度的转身，也可以玩得如此漂亮、优雅。这些大型的企业级软件系统已经走过了漫长的历程，它们如此巨大以至于我们只能看到它的一角，它们的零部件如此复杂以至于没有人能够彻底弄懂。我们必须认识到，这些系统是最有权力的系统，它们很有可能掌握了人类生活的根本命脉——金融管理、股市交易、生命健康、医疗管理、机械制造、国防安全、航空、航天……它们就像政治界、金融界的那些巨头，要是患了病咳嗽两声，也许世界都要抖一抖。它们可以轻易改变吗？不能！然而若是不寻求改变，这些系统会宿命地走向衰亡。若我们无法承受重写的成本，唯一的办法或许就是架构的重构。我们必须清晰地认识到这一点。而我认为，风险驱动模型恰恰可以作为架构重构的指导原则。在进行重构之前，我们需要充分评估重构的价值，回答“为什么我们需要重构”的问题；然后去识别风险。在开始重构之前，我们需要尽可能做到万无一失。风险自然是不可避免的，但如果我们能事先识别出这些风险，就能有的放矢地选择正确的技术。风险驱动模型的第三步，则是评估风险是否得到有效缓解。不要轻视这一步！重构往往意味着还债。可是，我们该用什么来说服管理者们付出成本去做一些看似没有产生直接利益的任务呢？答案就是用数据来说话，通过比较重构前后的系统健康指标，可以加重说服老板的砝码。当然，毫无疑问，这个过程一定是迭代的。</p>

<p>我想，通过这次交谈，我进一步找到了“风险驱动模型”适用的场景。而这正是我翻译并推荐本书的根本意义。本书可以在<a href="http://product.dangdang.com/product.aspx?product_id=23320387">当当网</a>购买。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AgileChina2003架构演进杂志]]></title>
    <link href="http://agiledon.github.com/blog/2013/07/29/agilechina-magazine/"/>
    <updated>2013-07-29T22:06:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/07/29/agilechina-magazine</id>
    <content type="html"><![CDATA[<h3>“架构演进”介绍</h3>

<p>软件系统的架构从来都不是一蹴而就的，它需要在不断的演化中改进设计，甚至做出重要的架构迁移。尤其对于大型软件系统而言，组织管理、软件过程、需求变化、规模扩张、技术迁移、遗留系统等诸多因素都决定着架构的发展，甚至可能是诸多力量的博弈与权衡。</p>

<h3>技术文章</h3>

<h4>演化架构与紧急设计系列</h4>

<p>本系列文章旨在从全新的视角来介绍经常讨论但是又难以理解的软件架构和设计概念。作者 Neal Ford 将通过介绍一些具体示例来帮助您在演化架构和紧急设计的灵活实践中打下坚实的基础。通过将重要的架构和设计决定推迟到最后责任时刻，您可以防止由于不必要的复杂度而降低软件项目质量的问题。点击<a href="http://www.ibm.com/developerworks/cn/java/j-eaed/">链接</a>。</p>

<h4>遗留系统的技术栈迁移</h4>

<p>遗留系统是一个还在运行和使用，但已步入软件生命周期衰老期的软件系统。它可能会因为无法满足新的质量需求，又或者是出于企业战略决策的考虑等诸多原因，需要对其进行技术栈迁移。然而，在迁移过程中，我们既需要满足迁移后的需求，又必须保证原有的系统功能不会受到破坏，这就为技术栈迁移制造了障碍。本文提出运用“风险驱动模型”来完成这一工作。风险驱动模型就是通过识别风险，对风险排定优先级；然后根据风险选定相关技术，再对风险是否得到缓解进行评估的一种架构方法。点击<a href="http://www.infoq.com/cn/articles/legacy-system-migration">链接</a>。</p>

<h4>注重实效的架构师——大胆行前人未行之路</h4>

<p>是什么让架构师们精通自己的技艺？熟练的架构师是如何进行设计的？一次次，有人问起我这些问题，而我也不止一遍的问我自己。很明显，这并不只是软件工程过程、设计方法、技术或是编程的专业程度所决定的。很多架构师具备令人钦佩且完备的技术知识，这确实是使设计成功的必要条件。但是，还是有很多的软件项目失败了，或是在项目的架构中遭受到了严峻的挑战。掌握此道的关键在于架构师是以什么方式实现设计，他们重视什么，他们关注哪些方面以及在这些方面努力着。点击<a href="http://www.infoq.com/cn/articles/pragmatic-architect">链接</a>。</p>

<!--more-->


<h4>可扩展Web架构与分布式系统</h4>

<p>开放源代码已经成为一些大型网站的基本原则。而在这些网站成长的过程中，一些优秀的实践经验和规则也出现在他们的结构中。本文旨在介绍一些在大型网站结构设计的过程中需要注意的关键问题以及实现目标的基础工作。本文侧重于介绍网络系统，尽管一些准则在其他分布式系统中也是适用的。点击<a href="http://www.oschina.net/translate/scalable-web-architecture-and-distributed-systems">链接</a>。</p>

<h4>架构师</h4>

<p><img class="left" src="/images/2013/07/nealford.png"></p>

<h5>Neal Ford</h5>

<p>Neal Ford是全球IT咨询公司ThoughtWorks的软件架构师。除了常规工作，他做的事情还包括设计和开发应用程序、教学材料、杂志文章、课件和视频/DVD演示，同时还是各种技术书籍的作者或者编辑，其中包括著作The Productive Programmer。他专注于设计和开发大规模企业应用程序，同时，他也是世界开发人员会议的国际知名演说家。
<img class="right" src="/images/2013/07/ericevans.png"></p>

<h5>Eric Evans</h5>

<p>大型业务系统方面的领域建模和设计专家。早20世纪90年代，他就参与了很多项目，基于对象（Object）开发出许多大型的业务系统，并致力于将敏捷过程应用到现实项目中。
此外，Eric Evans还是《领域驱动设计——软件核心复杂性应对之道》一书的作者。在书中他总结了构建上述业务系统相关的经验、原则和技术等。并介绍了一个建模和设计技术的系统，成功的团队应用这一系统可以组装有业务需求的复杂软件系统，并使系统在增大时仍然保持敏捷。
Eric现在是“Domain Language”组织的负责人。该组织是一个咨询小组，它指导和训练团队实施领域驱动设计，帮助他们使自己的开发工作对业务而言更有生产力和更有价值。<img class="left" src="/images/2013/07/buschmann.png"></p>

<h5>FranK Buschmann</h5>

<p>德国慕尼黑西门子技术公司资深技术专家及负责人。Wiley软件设计模式系列图书主编。他的研究领域包括对象技术、软件架构、产品线、模型驱动软件开发和模式。他曾是ANSI C++标准化委员会x3J16的成员，于1996年发起了首届EuroPLoP会议。Frank Buschmann是Pattern-Oriented Software Architecture系列书籍的主要作者。
<img class="right" src="/images/2013/07/george.png"></p>

<h5>Fred George</h5>

<p>Fred George先生在敏捷开发领域颇有声望，在业界有将近40年的开发经验，是国际敏捷领域大师级专家、咨询师、架构师。早年他在IBM工作。退出IBM之后，以独立咨询师的身份在美国工作了十多年。后来他加盟了ThoughtWorks，成为早期致力于推动敏捷开发的一批开发者。现在他离开了ThoughtWorks，在英国的TrafficBroker公司就任解决方案架构师一职。</p>

<h4>推荐书籍</h4>

<p><img class="left" src="/images/2013/07/releaseit.png">#####Release It!</p>

<p><strong>推荐理由：</strong>Michael Nygard的Releast It!可以看做是处理软件系统质量属性的治病良方。本书常常会以一个具体的实例开始阐述某一个质量属性的关键性，并列出一系列的反模式作为参照和对比，最后再给出正确的模式列表。这种针对问题的叙事方法，使得读者往往能够照方抓药，又因为模式的叙述如此清晰而规范，所以常常能药到病除。正如本书书名所指，这些内容确乎与软件的发布息息相关。</p>

<p><img class="right" src="/images/2013/07/beautifularchitecture.png"></p>

<h5>Beautiful Architecture</h5>

<p><strong>推荐理由：</strong>全书涵盖的内容广博而宏大，涵盖了架构基本原则、企业级应用架构、系统架构、最终用户应用架构、语言与架构，分列为本书的五大部分，读之会让人产生目不暇接之感。尤其对于术有专攻的程序员来讲，要彻底吃透本书讲解的内容，无疑是一项艰巨的挑战。然而，如果从架构师所必须具备的技能来看，本书的内容其实并没有超出架构的范畴，因为架构师必须要见识广博，你才能针对不同的需求场景，面对不同的实现技术，选出最适合当前场景的恰如其分的架构方案。</p>

<p><img class="right" src="/images/2013/07/eip.png"></p>

<h5>Enterprise Integation Patterns</h5>

<p><strong>推荐理由：</strong>本书关注企业级软件系统的本质问题，那就是集成。对于采用异步消息传递的集成方案，本书针对不同场景给出了不同的解决方案，并以模式的方式进行概述与归纳。倘若你在设计软件系统时，需要使用异步消息传递的方式对系统进行集成，本书可以成为你的最佳指南。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[处理文件请求限制]]></title>
    <link href="http://agiledon.github.com/blog/2013/06/13/handle-the-limitation-of-requesting-file/"/>
    <updated>2013-06-13T21:29:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/06/13/handle-the-limitation-of-requesting-file</id>
    <content type="html"><![CDATA[<p>在我参与的一个项目中，遇见了一个结合功能性需求与非功能性需求，并要求同时满足的场景。它的功能其实很简单，就是需要向系统发出处理文件的请求。文件的处理则涉及到多个数据表的查询，对相关数据的解析，并依照事先设定好的模板填充数据，最后生成PDF文件。一旦文件处理完毕，就可以返回处理后的文件。由于该系统的业务特殊性，这一功能需求会在某个特定时间，迎来数以万计的客户请求。同时，文件处理功能是一个相对漫长的处理过程，且生成的文件较大。在系统的最初版本中，经历过数千人次的并发数，在只有一台服务器的情况下，导致了大量请求的阻塞。同时，由于加载文件和文件读写需要耗费内存，在请求较为频繁的情况下，多次抛出OutOfMemory异常。即使在最好的情况下，服务端响应了客户端请求，也可能花费大量的时间，严重影响了用户体验。</p>

<p>我们希望在后续版本中解决这一问题。然而，现实总是这么残酷。真正处理文件并提供下载功能的系统并不在我们的掌控之中。它是第三方Vendor提供的Web Service，我们开发的系统仅仅涉及到请求的转发，完成对该Web Service的调用；并在获得结果后，将响应（包含了文件流数据）返回给客户端。换言之，我们既不能改善文件处理的实现逻辑，以提高处理的速度；也无法对该Web Service进行水平伸缩，例如通过引入多台服务器建立集群和负载均衡的方式。</p>

<p>遭遇如此场景实属无奈，要得出好的设计决策就好似戴着镣铐跳舞，只有在自己的服务端下功夫。我们首先想到的是限流（throttle）的方式，通过引入一个类似Controller角色的对象RequestHandlerPool，对客户端的请求进行控制。我们可以设定一个阈值，一旦超过该阈值，就将后续的请求放入队列进行排队。这个限流可以采用简单地在内存实现请求池全局对象。当然，也可以考虑引入消息队列中间件。改进后的时序图如下所示：
<img class="center" src="/images/2013/06/filehandling.png"></p>

<p>引入RequestHandlerPool仅仅是对请求进行了限制，从而避免请求过多导致File Cabinet的阻塞，或者导致抛出OutOfMemeory异常。但整体的处理时间并没有得到任何改善。我们首先考虑将该功能分为两阶段。第一阶段是发起对文件的处理请求，第二阶段则是下载处理好的文件。对于耗时较长的文件处理请求，可以考虑使用异步请求，一旦文件处理完毕，就可以通过Callback通知请求者。然而，由于文件处理的时间过长，可能会导致请求者不愿继续等待结果，从而退出系统，形成一次失败的请求。因而，我们考虑系统的Callback可以通过发送邮件的方式通知发出请求的客户，在邮件内容中附带下载地址，以供客户下载。</p>

<p>纵观整个场景，存在太多制肘，我们也没有太多好的解决方案。而且，我们还应该保证这个解决方案足够简单，因为我们需要在尽量短的周期内对原有方案进行改善，以迎接新一期的业务高峰。这些限制不同于架构约束，它常常迫使我们在逼仄的空间中闪转腾挪。我们还必须尽快地实现方案的原型，并营造与真实业务场景相当的数据，对其进行压力测试和性能测试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ThoughtWorks读书雷达-架构设计篇]]></title>
    <link href="http://agiledon.github.com/blog/2013/05/13/architecture-and-design-of-reading-radar/"/>
    <updated>2013-05-13T20:41:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/05/13/architecture-and-design-of-reading-radar</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/04/reading_radar_02.png">
编码的能力与设计的能力，二者均不可偏废。我们认为，编码事实上是设计的一部分，只不过它更多的是以代码的形式来呈现，而设计则主要由模型来组成。这种设计模型有助于知识的传递与分享，同时也可以有效地提高编码质量。至于架构，则是软件系统中重要的事物，它关乎的内容往往是难以更改的。卓越的软件设计一定拥有美的架构，也能够有助于促进架构的演化。在ThoughtWorks，并没有明确的架构师职位。如果有，我们也希望这个角色应该是Martin Folwer认为的Architectus Oryzus，这些架构师与处理最困难部分的其他开发人员合作，积极地向项目贡献代码。显然，我们认为架构师也是程序员。这正是我们要在这个读书雷达中列出Architecture &amp; Design象限的原因。</p>

<p>整体概览本象限列出的书籍，若有相关读书经验的人一定会注意到，这里列出的书籍并没有脱离面向对象设计体系的范畴。我们认为，在当今的企业级软件开发领域中，面向对象的思想体系仍然占据了主要的地位。对于程序员而言，建立面向对象的设计思维仍然至关重要。但是，我们从来都不曾忽略函数式语言对设计领域带来的冲击，以及它可能产生的巨大影响。在<a href="http://www.thoughtworks.com/insights">最新的ThoughtWorks Technology Radar</a>的Languages &amp; Frameworks象限中，ThoughtWorks对Scala，Clojure，F#等函数式语言青睐有加，同时也谈到了在Java中引入高阶函数等函数式特性的Functional Java发展趋势。我们也注意到在2012年的DDD eXchange会议上，函数式语言对设计范式的转变产生的影响。遗憾的是，除了少量介绍具体函数式语言的书籍，我们很少看到如面向对象设计一般专门讲解与深入探讨函数式软件设计的书籍。与其滥竽充数，不如抱残守缺。我们选择了在这期读书雷达图中，让函数式设计范式集体缺席。</p>

<p>架构内容包罗万象，在这个象限中我们关注的书籍主要与架构本质内容相关，包括架构风格、架构模式和重要的架构设计原则。虽然云计算、大数据以及REST服务等相关技术已经成为架构师的必备知识，也诞生了许多优秀的书籍；但我们还是希望让这个象限的内容变得更内聚一些，从而帮助读者能够从中挑选出合适的书籍，组成学习架构与设计技能的读书路线图。或许，在将来我们希望引入Tools、Frameworks以及Platforms等更多的象限来囊括这部分内容。</p>

<!--more-->


<p>在Architecture &amp; Design象限的基础篇中，我们仍然选择设计模式作为面向对象设计能力提高的突破口。因此，我们将浅显易懂的Head First Design Patterns《<a href="http://book.douban.com/subject/1488876/">深入浅出设计模式</a>》作为学习设计模式的入门书。图文并茂以及与生活有关的设计案例可以很容易启发读者的阅读理解，快速地掌握设计模式的精要。我们唯一担心的是这样一本充斥着玩具项目的入门书籍，可能很难让读者将自己学到的设计思想运用到真实项目中。因此，我们强烈推荐Robert Martin的经典著作Agile Software Development《<a href="http://book.douban.com/subject/1140457/">敏捷软件开发</a>》。该书很好地总结了面向对象设计的SOLID原则，在设计理论上做到了高屋建瓴；同时又给出了丰富的更加贴近真实项目的案例来分析设计模式。</p>

<p>我们必须列入GOF的Design Patterns《<a href="http://book.douban.com/subject/1052241/">设计模式</a>》，不仅仅是因为本书对整个设计领域的影响力，还因为本书讲到的设计理念与原则，至今读来，内涵的真知灼见仍然熠熠生辉。我强烈建议读者仔细研读本书的第一章，几乎每一句话都值得我们深思。即使你曾经读过，我仍然建议你再次阅读。本书第二章给出的案例实在太精妙了，仿佛一件艺术品，虽为人工雕刻，你却看不到斧凿的痕迹。如此浓缩的两章内容，抵得上许多讲述设计模式书籍的千言万语。当然，从今天的视角来看，GOF提出的一些设计模式如今已经变得不合时宜；然而我认为，在你没有真正理解设计模式之前，请先闭上质疑的眼光，收回批判的言辞。</p>

<p>在Medium的层级，我们开始将目光投向更高层次的架构模式，这其中尤以Martin Fowler的著作Patterns of Enterprise Application Architecture《<a href="http://book.douban.com/subject/1230559/">企业应用架构模式</a>》为代表。该书围绕着分层架构模式，根据不同层次呈现出的不同特征，提炼出了在企业开发中得到广泛使用的模式。可以认为这是Martin Fowler给出的企业应用开发的最佳实践，以模式的形式告诉你在不同的场景下，你应该选择何种设计方案。书中的多数模式已经如设计模式一般深入人心，在某种程度上甚至可以作为设计人员的交流术语。换言之，倘若你不曾掌握这些模式，或许会失去在许多场景下说话的资格。</p>

<p>Eric Raymond的The Art of UNIX Programming《<a href="http://book.douban.com/subject/1467587/">UNIX编程艺术</a>》则从艺术的角度剖析了UNIX的编程哲学，使得我们明白软件设计其实并没有阵营之分，即使是面向过程的语言，也能做出优雅的设计。而且，面向对象设计中所有精华的设计思想与原则，其实都可以从UNIX的编程哲学中找到，例如使用简洁的接口拼合简单的部件，清晰胜于机巧，策略同机制分离，设计追求简洁，健壮源于透明与简洁。愿本书能够开拓你的设计视野。</p>

<p>Jaroslav Tulach的Practical API Design《<a href="http://book.douban.com/subject/6003832/">软件框架设计的艺术</a>》则从框架的角度讨论了如何针对API进行实效主义的设计。这在一定程度上弥补了软件设计技术书籍在API设计方面的空白。本书对于API与SPI的讨论，对模块化设计的分析，尤其是来自于NetBeans框架产品版本演化的实践经验，都是非常重要的设计知识。</p>

<p>在Architecture &amp; Design象限中，放入Martin Fowler的Domain Specific Languages《<a href="http://book.douban.com/subject/21964984/">领域特定语言</a>》似乎有些突兀，或许它更应该放入Coding Practice象限。然而，我们认为掌握领域特定语言在一定程度上可以改进我们的设计，尤其是API的设计。无论是内部DSL还是外部DSL，必然会涉及到如何合理设计语言，这其中蕴含了精妙的设计思想。看看书中对状态机以DSL风格进行的分析，阐释各种解析表达式树的算法，讨论如何设计分离更有利于重用和测试，这其中又包括了对语义模型的提炼与分析。无疑，这是一本DSL的集大成之作，但如果我们仅仅将其范围局限在语言层面，你可能会错失对Martin Fowler深邃的设计思想领悟的机会。</p>

<p>入选Advanced层级的书籍除了Eric Evans的Domain Driven Design《<a href="http://book.douban.com/subject/1629512/">领域驱动设计</a>》，均与软件架构直接相关。我们尤其尊重《领域驱动设计》一书在设计领域的开创与先驱地位，它提出的以领域为核心，以建模为手段的设计方法学，为设计业务复杂的大型企业级软件提供了具有实践意义的方法体系，进而催生了领域驱动设计。书中提到的诸多概念包括Entity、Value Object、Repository、Aggregation、Bounded Context，已经成为了设计知识的专用术语。我们强烈推荐此书，是因为对于程序员而言，只要你逃避不了对业务领域的分析与建模，就不能绕过领域驱动设计。</p>

<p>以五卷本的系列著作来阐述软件架构模式，可见作者的宏伟决心以及对架构设计驾轻就熟的能力。我们认为，在模式领域里，以Frank Buschmann为主要贡献者的Pattern-Oriented Software Architecture《<a href="http://book.douban.com/subject/4848563/">面向模式的软件架构</a>》系列对软件设计领域带来的影响巨大而深远。这个系列虽然都是讲解架构模式，但各有其特色，关注点也有不同，分别涵盖了通用架构模式、并发模式、资源模式、分布式模式与模式语言。阅读这一系列确实需要读者下定一百万分的决心，若你不愿意通读，那么它也可以成为很不错的架构模式参考书籍。我们相信，你在软件设计中可能会遭遇的大多数设计场景，都能在本系列中找到对应的架构模式，从而作为设计方案的重要输入。</p>

<p>在Pattern-Oriented Software Architecture系列中，虽然介绍了分布式系统的架构模式，但关于系统集成包括消息处理等内容却显得不够深入和详尽，这是因为已有一本优秀著作专美于前，即Gregor Hohpe与Bobby Woolf的Enterprise Integation Patterns《<a href="http://book.douban.com/subject/1766652/">企业集成模式</a>》。本书关注企业级软件系统的本质问题，那就是集成。对于采用异步消息传递的集成方案，本书针对不同场景给出了不同的解决方案，并以模式的方式进行概述与归纳。倘若你在设计软件系统时，需要使用异步消息传递的方式对系统进行集成，本书可以成为你的最佳指南。</p>

<p>如果将《领域驱动设计》视为应对领域复杂性的解决之道，Michael Nygard的<a href="http://book.douban.com/subject/2065284/">Releast It!</a>则可以看做是处理软件系统质量属性的治病良方。本书常常会以一个具体的实例开始阐述某一个质量属性的关键性，并列出一系列的反模式作为参照和对比，最后再给出正确的模式列表。这种针对问题的叙事方法，使得读者往往能够照方抓药，又因为模式的叙述如此清晰而规范，所以常常能药到病除。正如本书书名所指，这些内容确乎与软件的发布息息相关。</p>

<p>最后一本推荐书籍看似有些大杂烩，实则是大家云集的架构师合唱团，可谓架构的盛宴，那就是Till Adam编著的Beatiful Architecture《<a href="http://book.douban.com/subject/4086029/">架构之美</a>》。全书涵盖的内容广博而宏大，涵盖了架构基本原则、企业级应用架构、系统架构、最终用户应用架构、语言与架构，分列为本书的五大部分，读之会让人产生目不暇接之感。尤其对于术有专攻的程序员来讲，要彻底吃透本书讲解的内容，无疑是一项艰巨的挑战。然而，如果从架构师所必须具备的技能来看，本书的内容其实并没有超出架构的范畴，因为架构师必须要见识广博，你才能针对不同的需求场景，面对不同的实现技术，选出最适合当前场景的恰如其分的架构方案。当然，在阅读时，千万不要在太多的技术细节中迷失自己，关键还是要把握美丽架构的基本原则。而这正是本书的主线，使得本书能够在散乱的主题中，还能做到“形散而神不散”。</p>
]]></content>
  </entry>
  
</feed>
