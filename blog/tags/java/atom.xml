<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Java | 简单文本]]></title>
  <link href="http://agiledon.github.com/blog/tags/java/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2014-02-22T23:05:44+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Maven为一个项目生成多个Jar包]]></title>
    <link href="http://agiledon.github.com/blog/2013/11/10/create-two-jars-from-one-project-using-maven/"/>
    <updated>2013-11-10T22:43:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/11/10/create-two-jars-from-one-project-using-maven</id>
    <content type="html"><![CDATA[<p>虽然在Java平台下，各种构建工具如Maven、Gradle、SBT已经得到了较为广泛地运用，同时Maven约定的模块目录结构也得到了业界的认可，成为了Java平台下项目结构的事实标准。但我们总无法避免与各种遗留系统或老系统打交道。在没有Maven的时代，是Ant统治的时代，它因为提供了较为灵活的编写Task的功能，而忽略了制定一套看似呆板，实则有效的标准模板。于是，在不同的企业，不同的Java项目，出现了各种各样奇怪的目录结构与打包要求。拖着这些沉重的历史包袱，我们自然希望彻底革命，把那些看不顺眼的东西全部改造，让整个项目焕然一新。这是好事儿，所谓长痛不如短痛，一下子把问题肿瘤给割了，痛快！可是现实总有那么一些阻力会让我们缩手缩脚，我们不能挥起革命的利刃一阵乱砍，这弄不好会砍伤自己的手。于是乎，我们需要做战略性的撤退。退一步海阔天空嘛。</p>

<p>我面对的就是这样一个软件系统。这个Java开发的软件系统一直没有依赖管理，仅仅编写了Ant任务用于发布打包。我们的任务是渐进地引入Maven，并在从Build到deploy的整个生命周期中，逐步替换Ant，与持续集成搭配起来。这个系统的多数模块都划分了服务端与客户端。然而不巧的是，各个模块的服务端和客户端都集中在一个模块中。同时，这个项目的目录结构并非标准的Maven结构，如下图所示。因此，还需要自定义Source与TestSource的目录结构。在原来的Ant任务中，是将它们打包成了两个Jar包。现在，我们需要在Maven中同样做到这一点。</p>

<!-- more -->


<p>{% img left /images/2013/folder-structure.png %}</p>

<p>分析这个目录结构，无非是在打包时，对文件进行include或exclude。我查阅到Maven的一位开发者Tim O'Brien写的一篇博客<a href="http://blog.sonatype.com/people/2010/01/how-to-create-two-jars-from-one-project-and-why-you-shouldnt/#.Un9DKpTN_Gp">Sonatype的博客</a>，详细介绍了具体的做法。当然，在博客中，他一再强调了这种做法的不可取，建议在项目模块上做出好的分解，保证一个Module对应一个Jar包。这篇博客介绍了两种做法，一个是在Profile中定义，一个则是在build中定义，使用的插件皆为maven-jar-plugin。对于我要解决的问题，可以考虑选择使用第二种做法，因为它只需要执行一条mvn package命令就能同时得到Server和Client的Jar包。具体的做法就是在插件的配置中，include各自的文件夹即可。配置如下：
{% codeblock lang:xml %}</p>

<pre><code>&lt;groupId&gt;com.test.maven&lt;/groupId&gt;
&lt;artifactId&gt;testmaven&lt;/artifactId&gt;
&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;

&lt;build&gt;
    &lt;sourceDirectory&gt;src&lt;/sourceDirectory&gt;
    &lt;testSourceDirectory&gt;testSrc&lt;/testSourceDirectory&gt;

    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;server&lt;/id&gt;
                    &lt;goals&gt;&lt;goal&gt;jar&lt;/goal&gt;&lt;/goals&gt;
                    &lt;phase&gt;package&lt;/phase&gt;
                    &lt;configuration&gt;
                        &lt;classifier&gt;server&lt;/classifier&gt;
                        &lt;includes&gt;
                            &lt;include&gt;**/server/**&lt;/include&gt;
                        &lt;/includes&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
                &lt;execution&gt;
                    &lt;id&gt;client&lt;/id&gt;
                    &lt;goals&gt;&lt;goal&gt;jar&lt;/goal&gt;&lt;/goals&gt;
                    &lt;phase&gt;package&lt;/phase&gt;
                    &lt;configuration&gt;
                        &lt;classifier&gt;client&lt;/classifier&gt;
                        &lt;includes&gt;
                            &lt;include&gt;**/client/**&lt;/include&gt;
                        &lt;/includes&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>通过这样的配置，运行mvn package可以生成三个包，其中testmaven-1.0-SNAPSHOT.jar同时包含了服务端和客户端的类；而服务端和客户端对应的Jar则为testmaven-1.0-SNAPSHOT-server.jar和testmaven-1.0-SNAPSHOT-client.jar。</p>

<p>在前面的配置中，我们并没有为server和client包定义自己的坐标，而是沿用了统一的一个。这就意味着依赖这个包的其他Module，可能无法通过Dependency来精确定位Server或Client。这对于部署来说，是没有问题的，但却无法进行依赖管理；除非在依赖的时候，去依赖整个大的模块。</p>

<p>要保证依赖管理，就意味着需要为server和client分别指定各自的坐标。看来需要另辟蹊径。其实，Maven是支持在一个项目中建立多个子模块的。我们可以考虑在项目中引入两个子模块，分别对应server和client，并在这两个子模块中建立自己的pom.xml文件。这在本质上是与Maven多模块支持是相同的，唯一不同的是代码结构。而且这种新建模块并没有影响原有的目录结构，对于遗留系统而言，还是可以接受的。因此，我们建立了如下图所示的模块结构：
{% img center /images/2013/module-structure.png %}</p>

<p>在新的结构中，除了原有模块外，我还引入了另外两个新的模块server和client，它们除了拥有自己的pom.xml文件，没有其他任何内容。而在原有模块下，同样定义了一个pom.xml文件，它将作为整个项目的parent。定义如下：
{% codeblock lang:xml %}</p>

<pre><code>&lt;groupId&gt;com.test.maven&lt;/groupId&gt;
&lt;artifactId&gt;testmaven&lt;/artifactId&gt;
&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;packaging&gt;pom&lt;/packaging&gt;

&lt;modules&gt;
    &lt;module&gt;server&lt;/module&gt;
    &lt;module&gt;client&lt;/module&gt;
&lt;/modules&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>这里定义的坐标是整个项目的坐标，同时指定了packaging的类型为pom。在这个pom.xml文件中还包括了两个子模块，其中的值应该与模块的名称对应。接下来配置server模块的pom.xml：
{% codeblock lang:xml %}</p>

<pre><code>&lt;parent&gt;
    &lt;groupId&gt;com.test.maven&lt;/groupId&gt;
    &lt;artifactId&gt;testmaven&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/parent&gt;

&lt;artifactId&gt;testmaven-server&lt;/artifactId&gt;

&lt;build&gt;
    &lt;sourceDirectory&gt;../src&lt;/sourceDirectory&gt;
    &lt;testSourceDirectory&gt;../testSrc&lt;/testSourceDirectory&gt;

    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.1&lt;/version&gt;
            &lt;configuration&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/server/**&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/configuration&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>首先声明了parent指向了主模块的坐标。接下来，声明当前模块的artifact id为testmaven-server。这就为server指定了独立的坐标。一旦部署后，在maven的Repository中会得到这样的文件：com/test/maven/testmaven-server/1.0-SNAPSHOT/testmaven-server-1.0-SNAPSHOT.jar。我们就可以在依赖中这样声明：
{% codeblock lang:xml %}</p>

<pre><code>&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.test.maven&lt;/groupId&gt;
        &lt;artifactId&gt;testmaven-server&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>运行mvn package，oops……竟然出现问题了。什么问题呢？单元测试无法通过。报告的错误为：
{% codeblock %}
Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:testCompile (default-testCompile) on project testmaven-server: Compilation failure: Compilation failure:
[ERROR] /Users/twer/learn/testmaven/testSrc/com/test/maven/client/HelloMavenTest.java:[11,9] cannot find symbol
[ERROR] symbol  : class HelloMaven
[ERROR] location: class com.test.maven.client.HelloMavenTest
{% endcodeblock %}</p>

<p>仔细分析，原来是在执行编译server包时，报告无法编译client包对应的测试类。怎么会在编译server包时，去编译client包对应的测试呢？仔细观察我们的pom.xml文件，在maven-compiler-plugin插件中，我们配置了对server文件的引入，这就意味着在编译server包时，不会引入client文件夹下的所有文件（当然在这里就是Java类文件）。但是，我们并没有在test-compile阶段排除client对应的测试文件。这就导致client的测试无法找到对应的实现类。找到根源，问题就好解决了，显然我们需要在test-compile阶段排除client文件夹。所以，server模块下正确的pom.xml配置为：
{% codeblock lang:xml %}</p>

<pre><code>&lt;parent&gt;
    &lt;groupId&gt;com.test.maven&lt;/groupId&gt;
    &lt;artifactId&gt;testmaven&lt;/artifactId&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
&lt;/parent&gt;

&lt;artifactId&gt;testmaven-server&lt;/artifactId&gt;

&lt;build&gt;
    &lt;sourceDirectory&gt;../src&lt;/sourceDirectory&gt;
    &lt;testSourceDirectory&gt;../testSrc&lt;/testSourceDirectory&gt;

    &lt;plugins&gt;
        &lt;plugin&gt;
            &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
            &lt;version&gt;3.1&lt;/version&gt;
            &lt;configuration&gt;
                &lt;includes&gt;
                    &lt;include&gt;**/server/**&lt;/include&gt;
                &lt;/includes&gt;
            &lt;/configuration&gt;
            &lt;executions&gt;
                &lt;execution&gt;
                    &lt;id&gt;default-testCompile&lt;/id&gt;
                    &lt;phase&gt;test-compile&lt;/phase&gt;
                    &lt;configuration&gt;
                        &lt;testExcludes&gt;
                            &lt;exclude&gt;**/client/**&lt;/exclude&gt;
                        &lt;/testExcludes&gt;
                    &lt;/configuration&gt;
                &lt;/execution&gt;
            &lt;/executions&gt;
        &lt;/plugin&gt;
    &lt;/plugins&gt;
&lt;/build&gt;
</code></pre>

<p>{% endcodeblock %}</p>

<p>注意：我在IntelliJ配置execution下的configuration节时，碰到一个问题，那就是针对testExcludes配置节没有智能提示。由于其他maven配置节在正确情况下都有智能提示，因而让我产生错误，认为这个配置项不支持testExcludes，这让我纠结了好半天。</p>

<p>对于client模块而言，如法炮制，只是包含以及过滤的文件夹反转了一个个儿而已。当我们进行install甚至deploy时，在repository下的test/maven文件夹中，看到了三个文件夹，如图所示：
{% img center /images/2013/maven-repository.png %}</p>

<p>其中的testmaven/1.0-SNAPSHOT文件夹下并没有jar包，因为它对应的配置为主模块的配置，也就是parent配置。在这个配置中，我们将packaging的类型设置为pom了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Guava提供的Preconditions]]></title>
    <link href="http://agiledon.github.com/blog/2013/10/09/using-preconditions-of-guava/"/>
    <updated>2013-10-09T22:57:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/10/09/using-preconditions-of-guava</id>
    <content type="html"><![CDATA[<p>我看到这么一段Java代码，主要逻辑是对传入的数据对象进行分析和处理。方法除了长了一点，本身没有什么问题，但一个不好的味道是方法中充斥了一部分对对象非空的处理，以及写日志的信息。这些语句本身不属于方法的主干实现，却很讨厌地干扰了方法的主要逻辑，影响了程序的可读性。</p>

<p>{% codeblock lang:java %}
public class Processor {</p>

<pre><code>public void execute(ProcessData processData) {
    if (processData == null || processData.getInput() == null) {
        logger.error("processData is error");
        return;
    }

    List&lt;FavoratePolicy&gt; policies = fetchPolicies(processData);
    if (policies == null || policies.isEmpty()) {
        logger.error("can not fetch favorate policies");
        return;
    }

    for (FavoratePolicy policy : policies) {
        //handle policy
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>我最初想要尝试使用Guava提供的Optional。经过仔细分析，发现这里的场景并不适合Optional。Optional确实可以用于处理null object，甚至可以将其看做是Null Object模式的实现。但它为Java语言带来的好处，无非是提高了代码可读性，同时可以有效地防止程序员忘记对null的判断。它不能带来代码量的减少，用在这里，也无法消除非空判断以及日志的噪音。所幸，Guava还提供了Preconditions，它拥有更好而简洁的断言方式，可以处理程序的一些异常分支。它主要定义的方法包括checkArgument(), checkNotNull()以及checkState()等，可以通过抛指定异常的方式，将程序的主分支与异常分支有效地隔离开。通过引入checkArgument()方法，前面的代码可以调整为：
{% codeblock lang:java %}
public class Processor {</p>

<pre><code>public void execute(ProcessData processData) {
    try {
        checkArgument(processData != null &amp;&amp; processData.getInput() != null, "processData is error");

        List&lt;FavoratePolicy&gt; policies = fetchPolicies(processData);

        checkArgument(policies != null &amp;&amp; (!policies.isEmpty()), "can not fetch favorate policies");

        for (FavoratePolicy policy : policies) {
            //handle policy
        }

    } catch (IllegalArgumentException ex) {
        logger.error(ex.getMessage());
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>经过这样的处理，程序的主体逻辑变得清晰了许多，而且也能够有效地避免日志方法的重复。当然，这里也可以使用checkNotNull()方法来处理ProcessData与List<FavoratePolicy>的null情形。但由于它抛出的异常为NullPointerException，用在这里会增加一个异常捕获（因为它无法处理isEmpty()的情况），所以就一致地选择了checkArgument()方法。不过，在使用这一方法时，要注意它传入的条件表达式与原有实现的表达式是相反的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[代码是如何腐化的]]></title>
    <link href="http://agiledon.github.com/blog/2013/07/05/corrupt-code/"/>
    <updated>2013-07-05T14:26:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/07/05/corrupt-code</id>
    <content type="html"><![CDATA[<p>代码是如何腐化的？这是一个很大的话题，因为这种腐化的代码样本可能会体现不同的特征，若要彻底总结，可能会又是一本《重构》。我自然没有这个能力和知识。好在有一个简便的说法，即可以诉诸于“破窗理论”的威力。无论多少坏味道识别，重构手法运用，提高代码质量的最佳实践，以及运用诸多甄别代码质量体征的工具，都仅仅限于“术”的运用而已。若未能在开发人员内心树立整洁代码的习惯，时时刻刻对各种代码臭味保持敏感，且具有一颗期待卓越代码之心，那么，随着项目的演进，时间的推移，代码最终还是会慢慢腐烂。</p>

<p>这几日在开发一个User Story时，从诸多测试代码（包括集成测试与验收测试）中，观察到了一些接近腐烂的代码坏味。这些代码虽然不是产品代码，但同样是我们交付工件的一部分。最关键之处在于：它让我察觉到一种危险的趋势，若不能及时扭转，可能会让代码陷入腐烂的泥沼。若能及时解决这些糟糕代码，其实仅仅需要一些简单的重构手法，付出几个小时时间即可。</p>

<p>首先是针对集成测试的数据准备。我们要编写的集成测试针对Spring Batch Job，这些Job需要访问数据库，以验证Job的执行是否符合期望。我们发现在之前已有与Spring Batch Job相关的集成测试存在，并提供了访问数据库，以及启动、访问和停止Ftp服务器的功能。其中，与数据准备有关的功能放到单独定义的Fixture类中。这些Fixture是为特定目的编写的数据准备，可是，随着越来越多的Batch Job出现，有诸多集成测试都需要准备数据，于是开始慢慢产生了测试数据的重叠，逐步浮现出违背DRY原则的征兆了。</p>

<!--more-->


<p>对于多数程序员而言，并非不重视重用，但多数却不愿意为了重用付出一些代价。例如针对一些具备差异性的功能，一些程序员更愿意使用Copy And Paste，然后再针对自己的需求对实现进行修改或调整。观察目前的一些集成测试，正是这样一些陋习导致的。</p>

<p>在这些集成测试中，使用了继承的方式来重用数据准备的功能。如下图所示：
{% img center /images/2013/07/datafixture.png %}</p>

<p>在CustomerIntegratedDataFixture中，提供了相关方法实现了对Customer数据的创建。由于需要提供访问FtpServer的功能，因此又定义了CustomerIntegratedDataAndFtpPrepareFixture类，使其继承CustomerIntegratedDataFixture。它定义了startFtpServer()和stopFtpServer()方法，并在JUnit中，运用了@BeforeClass与@AfterClass标记，使其避免为每个测试启动和停止专有的FtpServer。现在，我们编写的集成测试同样需要与Customer有关的数据，但并不需要Ftp功能。换言之，我们希望重用CustomerIntegratedDataFixture。现在看来，似乎并没有问题。例如，我们可以让新增的测试直接继承CustomerIntegratedDataFixture。然而，就在同样的集成测试模块中，我们还发现了其他集成测试同样编写了自己的数据准备类。这些数据准备与Spring Batch Job无关，却同样提供了准备Customer数据的功能。存在的差异是它除了提供Customer数据外，还提供了依赖Customer的Consent数据。</p>

<p>我们没有着急去重用CustomerIntegratedDataFixture，因为我们察觉到代码会随着这种继承体系的延伸，会变得越来越难以重用。如上图的继承体系，使得数据准备与Spring Batch Job紧耦合了，同时又在CustomerIntegratedDataAndFtpPrepareFixture子类中引入了与Ftp有关的耦合，明显违背了单一职责原则。我们需要单独剥离出数据准备的类，它即可以作为超类被集成测试类继承，也可以通过组合的方式被继承了JobLauncherTestUtils的测试子类所调用。这符合Bridge模式的设计原则。因此，我们运用了“Replace Inheritance with Delegation”手法，对其进行了简单重构：
{% img center /images/2013/07/datafixtureafterrefactor.png %}</p>

<p>之后，我们对Customer和Consent对应的数据准备类进行了相应的重构与修改，使得这些数据的准备更为内聚，并去除一些不必要的重复，使之更容易被重用。
{% img center /images/2013/07/customerfixture.png %}</p>

<p>第二个例子是在JBehave的Story中，我看到了这样的Steps类的组织，如图：
{% img center /images/2013/07/steps.png %}</p>

<p>我们看到了什么？——一个“扁平组织”的Steps类。显然，促成这样的结果是一个渐进的过程。由于在之前编写相关的Steps类时，还看不到分类的概念，因此，只是简单地将自己的Steps类放到step之下即可。然后，不断有开发人员增加自己的Steps类，他们找到了step位置，却没有仔细思考是否需要更好地对Steps类进行组织。这就使得Steps类略显零乱，没有展现出好的结构。我们重新组织了这些Steps类：
{% img center /images/2013/07/stepsafterrefactor.png %}</p>

<p>只需要简单地归类，调整结构，整个Steps类就变得更加清晰了。于是，我们发现了可以重用的可能。观察重新组织之后的batch包，这里面包含的UpdateCustomerTypeSteps，ProductSystemLinkLoaderSteps与DeleteOrphanedRecordsSteps，都是与Btach Job有关的Steps类。MaintainProspectsSteps类则是我们新增的类，它同样需要用到启动Batch Job的方法。在之前存在的Steps类中，已经存在相似的代码了。例如在UpdateCustomerTypeSteps类中：
{% codeblock lang:java %}</p>

<pre><code>private String waitAndGetSatus(Map&lt;String, String&gt; params) throws InterruptedException {
    String status = null;
    for (int index = 0; index &lt; MAX_TRY_TIME; index++) {
        status = getJobStatus(params);
        if ("COMPLETED".equals(status)) {
            break;
        }
        Thread.sleep(WAIT_INTERVAL);
    }
    return status;
}

private String getJobStatus(Map&lt;String, String&gt; params) {
    return db2JdbcTemplate.queryForObject("select jobExec.STATUS from TCIST_JOB_EXECUTION jobExec " +
            "inner join TCIST_JOB_PARAMS jobParam on jobExec.JOB_INSTANCE_ID = jobParam.JOB_INSTANCE_ID " +
            "and jobParam.KEY_NAME = 'retry' " +
            "and jobParam.STRING_VAL = ?", String.class, params.get("retry"));
}
</code></pre>

<p>{% endcodeblock %}</p>

<p>再看DeleteOrphanedRecordsSteps类：
{% codeblock lang:java %}</p>

<pre><code>private String waitAndGetSatus(String currentTime) throws InterruptedException {
    String status = null;
    for (int index = 0; index &lt; MAX_TRY_TIME; index++) {
        status = getJobStatus(currentTime);
        if ("COMPLETED".equals(status)) {
            break;
        }
        Thread.sleep(WAIT_INTERVAL);
    }
    return status;
}

private String getJobStatus(String currentTime) {
    return jdbcTemplate.queryForObject("select jobExec.STATUS from TCIST_JOB_EXECUTION jobExec " +
            "inner join TCIST_JOB_PARAMS jobParam on jobExec.JOB_INSTANCE_ID = jobParam.JOB_INSTANCE_ID " +
            "and jobParam.KEY_NAME = 'time' " +
            "and jobParam.STRING_VAL = ?", String.class, currentTime);
}
</code></pre>

<p>{% endcodeblock %}</p>

<p>比较这些方法，除了jobParam的key与value存在细微区别，其余实现完全相同。若按照这样一个态势发展，随着与Batch Job有关的Story逐渐增多，不发现这种代码的臭味并即刻解决，这些代码就会逐渐蔓延，最后变得“无法自拔”。想要修改，已经变得极为困难了。</p>

<p>我们为这些Steps类提供了一个抽象的超类AbstractBatchJobSteps，并将这些可能重用的方法提取到这个超类中：
{% codeblock lang:java %}
public class AbstractBatchJobSteps extends AbstractSteps {</p>

<pre><code>private static final int WAIT_INTERVAL = 1000;
private static final int MAX_TRY_TIME = 30;

protected String waitAndGetSatus(Map&lt;String, String&gt; params, String paraKey) throws InterruptedException {
    String status = null;
    for (int index = 0; index &lt; MAX_TRY_TIME; index++) {
        status = getJobStatus(params, paraKey);
        if ("COMPLETED".equals(status)) {
            break;
        }
        Thread.sleep(WAIT_INTERVAL);
    }
    return status;
}

private String getJobStatus(Map&lt;String, String&gt; params, String paraKey) {
    return jdbcTemplate.queryForObject("select jobExec.STATUS from TCIST_JOB_EXECUTION jobExec " +
            "inner join TCIST_JOB_PARAMS jobParam on jobExec.JOB_INSTANCE_ID = jobParam.JOB_INSTANCE_ID " +
            "and jobParam.KEY_NAME = '" + paraKey + "' " +
            "and jobParam.STRING_VAL = ?", String.class, params.get(paraKey));
} 
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>如上的例子都可以通过一些细小的重构手法改进代码，使得代码的结构更加清晰，并有利于代码的重用。我深信大多数开发人员都具备这样的技能，且只需要稍加思索，即能发现这些代码的坏味。然而，我们总是因为种种原因，对这种还不太严重的“破窗”风景视而不见。殊不知当我们开始对这种不够整洁的代码采取纵容态度时，就可能会是代码腐化之始。一旦真正腐化，就将积重难返，到了那时，我们就可能真正无能为力了。</p>

<p>你是否遭遇过这样的情形？面对一个承担了无数职责似乎无所不能的上帝类，它被无数多的Client调用，且又没有足够覆盖率的测试，你是否会产生心有余而力不足的感慨。这时的你，是否像一位奋战沙场，出生入死却无力挽回败局的将军，面对那汹涌而来占据压倒性优势的敌军，唯有对天长叹：“某有心杀贼，却无力回天啊！”</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[新手培养日记(二)]]></title>
    <link href="http://agiledon.github.com/blog/2013/03/28/diary-2-for-coaching-fresh-man/"/>
    <updated>2013-03-28T20:30:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/03/28/diary-2-for-coaching-fresh-man</id>
    <content type="html"><![CDATA[<p>{% img center /images/2013/03/learning_perception.jpg %}
几天后，新手又一次提交了一份代码。由于改动较大，新手重新创建了一个项目。在这份代码中，新手接受了我的建议，改为使用Spring提供的JdbcTemplate。包的结构也得到了一定程度的改善。这充分说明他认识到了问题所在，并能够快速准确地采取行动去纠正这些问题。但或许是我提出的问题太多，给出的建议不够具体，在新提交的这份代码中，我还是看到了一些问题，且某些问题在上一次Review代码时，我曾经提及。</p>

<p>来看看如下两段代码。首先，是CustomerService，它定义了目前Story要求的基本业务：
{% codeblock lang:java %}
@Service("customerService")
public class CustomerService {</p>

<pre><code>@Autowired
@Qualifier("customerDAO")
private CustomerDAO customerDAO;

private final String defaultTableNameForCustomer = "customer";
private String tableName = defaultTableNameForCustomer;

public void setTableName(String tableName) {
    this.tableName = tableName;
}

@Transactional
public void addCustomer(Customer customer) throws DuplicateCustomerException {
    customerDAO.addCustomer(customer, tableName);
}

public Customer getCustomer(String nickname) throws CustomerNotFoundException {
    return customerDAO.getCustomer(nickname, tableName);
}

public void withdraw(String nickname, double balanceToWithdraw) throws BalanceOverdrawException {
    customerDAO.withdrawBalance(nickname, balanceToWithdraw, tableName);
}

public void deposit(String nickname, double balance) {
    customerDAO.deposit(nickname, balance, tableName);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>在CustomerService类中，调用了CustomerDAO类的相关方法：
{% codeblock lang:java %}
@Component
@Repository("customerDAO")
public class CustomerDAO {</p>

<pre><code>@Autowired
private JdbcTemplate jdbcTemplate;

public void createTable(String tableName) {
    jdbcTemplate.execute("DROP TABLE IF EXISTS " + tableName);
    jdbcTemplate.execute("CREATE TABLE " + tableName + "(" + "nickname VARCHAR(45) NOT NULL ," +
            "dateOfBirth DATETIME NOT NULL," + "balance DOUBLE NOT NULL, " + "PRIMARY KEY(nickname)" + ");");
}

public void addCustomer(Customer customer, String tableName) throws DuplicateCustomerException {
    String SQL = "insert into " + tableName + "(nickname, dateOfBirth, balance) values (?, ?, ?)";
    try {
        jdbcTemplate.update(SQL, new Object[]{customer.getNickname(), customer.getDateOfBirth(), customer.getBalance()});
    } catch (DuplicateKeyException exception) {
        throw new DuplicateCustomerException("Customer with nickname " + customer.getNickname() + " has already existed");
    }
}

public Customer getCustomer(String nickname, String tableName) throws CustomerNotFoundException {
    String SQL = "select * from " + tableName + " where nickname = ?";
    Customer customer;
    try {
        customer = jdbcTemplate.queryForObject(SQL, new Object[]{nickname}, new CustomerMapper());
    } catch (EmptyResultDataAccessException exception) {
        throw new CustomerNotFoundException("Customer with nickname " + nickname + " is not found");
    }
    return customer;
}

public Double getBalance(String nickname, String tableName) {
    String SQL = "select balance from " + tableName + " where nickname = ?";
    double balance = jdbcTemplate.queryForObject(SQL, new Object[]{nickname}, Double.class);
    return balance;
}

public void withdrawBalance(String nickname, double balanceToWithdraw, String tableName) throws BalanceOverdrawException {
    double balanceBefore = getBalance(nickname, tableName);
    double balanceAfter = balanceBefore - balanceToWithdraw;

    if (balanceAfter &lt; 0) {
        throw new BalanceOverdrawException("You have only " + balanceBefore + "$. You can not withdraw " + balanceToWithdraw + "$");
    }

    String SQL = "update " + tableName + " set balance = ? where nickname = ?";

    jdbcTemplate.update(SQL, new Object[]{balanceAfter, nickname});
}

public void deposit(String nickname, double balanceToDeposit, String tableName) {
    double balanceBefore = getBalance(nickname, tableName);
    double balanceAfter = balanceBefore + balanceToDeposit;

    String SQL = "update " + tableName + " set balance = ? where nickname = ?";
    jdbcTemplate.update(SQL, new Object[]{balanceAfter, nickname});
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>这两段代码存在什么问题？</p>

<p>显然，我们看到CustomerService履行的职责仅仅是对调用的委派，另外还添加了事务功能，除此之外，它什么事情都没有做，接到了请求，转手就递给CustomerDAO了。再看CustomerDAO，特别关注withdrawBalance()方法，你会发现这个方法的实现其实体现了较多的业务逻辑。事实上，我们看到这个方法的名称，体现的就是业务的概念。显然，这里的职责分配是不合理的。新手明显没有深刻体会Service与Dao之间的区别。无论是传统的分层架构模型，还是DDD提出的领域层与基础设施层的分离，都表达了业务与数据访问关注点分离的原则。事实上，新手还错误地将Service类放到了database.service包中。</p>

<p>正确的做法应该是保证每个对象的纯洁性与单一性，让每个对象只做一件事情，只做它应该关心的事情，遵循单一职责原则。Dao是数据访问对象，那么它就应该只处理数据访问的逻辑，而对具体业务应该是“一无所知”的。一个简单的识别办法，就是不要在这个类中出现任何业务概念，它做的事情就是CRUD。</p>

<p>对于许多OO初学者而言，职责不清是最容易犯下的毛病。要么就是恨不得把所有内容都塞给一个类；要么就是张冠李戴，随着性子乱分配职责，全然不考虑每个对象的感受。我常常说，对象是有意识的生物，这样不尊重对象搞乱分配，迟早这些对象会造反。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[新人培养日记(一)]]></title>
    <link href="http://agiledon.github.com/blog/2013/03/14/diary-1-for-coaching-fresh-man/"/>
    <updated>2013-03-14T20:37:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/03/14/diary-1-for-coaching-fresh-man</id>
    <content type="html"><![CDATA[<p>{% img center /images/2013/03/growup.jpg %}
我在公司内部Wiki找到了一份如何利用TDD驱动开发与设计的案例。这个案例的代码非常粗略，用C#编写。可贵之处在于它提供了20个已经写好的Story，并以正式项目中书写Story的方式编写。这个案例的需求类似一个真实软件系统，非常适合让新人体会应该如何开发一个完整地项目。它要求创建一个电子银行系统，提供银行的一些基本功能，例如客户管理、存取款等业务逻辑。</p>

<p>最初我并不知道新手的真实水平，不过，可以假设他只具备基础的Java编程知识，对TDD、Refactoring以及OO有最初步的了解，但处于懵懵懂懂之间。我最初希望新手仅仅针对业务层进行设计与编码，但新手坚持要加上数据库访问以及Web页面。我认为这种做法有利于新手学习到更多的Java框架和库，便同意了这种请求。</p>

<!--more-->


<p>我给新人简单地讲了前面两个Story的需求，就将这个项目扔给新手，一周后，我再去Review他提交的代码。结果发现了一大堆问题。</p>

<p>首先，项目没有使用任何构建工具，例如Maven或者Gradle。项目依赖的一些Java包，例如JUnit和Mockito，使用了直接依赖的方式。没有构建工具来创建构建脚本，就无法使用最快捷的方式来编译、构建以及运行测试，从而使得开发者懒于在提交前进行构建，以确保代码没有引入问题。没有自动化构建，更谈不上持续集成了（我打算在项目中期要求新手搭建CI环境）。</p>

<p>{% img center /images/2013/03/coach01.png %}
新手对代码包的划分，以及相关类的命名，有些惨不忍睹。上图是对该项目包结构以及相关类分布的截图。infoTracker包的命名让人觉得莫名其妙，打开其中的类查看代码，发现它事实上是调用DBTransaction类，执行对数据表的CRUD操作。例如代码：
{% codeblock lang:java infoTracker.CustomerAccountUpdater.java %}
public class CustomerAccountUpdater {</p>

<pre><code>private static DBTransaction transaction = new DBTransaction();

public static void addBalance(double money, Customer customer) {
    transaction.addBalance(money, customer);
}

public static void withdrawBalance(double money, Customer customer) throws CustomerBalanceInvalid {
    transaction.withdrawBalance(money, customer);
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>database包的DBTransaction类的命名更是容易引起歧义，以为是对事务的处理，实则是DAO对象：
{% codeblock lang:java database.DBTransaction.java %}
public class DBTransaction {</p>

<pre><code>public static Connection connection;
private PreparedStatement pstmt;

public DBTransaction() {
    this.connection = DBConnection.getConnection();
}

public void addCustomer(Customer customer) {
    String nickname = customer.getNickname();
    Date dateOfBirth = customer.getDateOfBirth();
    String properName = customer.getProperName();
    Date joiningDate = customer.getJoiningDate();
    double balance = customer.getBalance();
    boolean isBonusAdded = customer.isBonusAdded();

    String sql = "insert into userinfo values (?, ?, ?, ?, ?, ?)";

    try {
        pstmt = connection.prepareStatement(sql);
        pstmt.setString(1, nickname);
        pstmt.setObject(2, dateOfBirth);
        pstmt.setString(3, properName);
        pstmt.setObject(4, joiningDate);
        pstmt.setDouble(5, balance);
        pstmt.setBoolean(6, isBonusAdded);

        pstmt.executeUpdate();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>新手并没有使用我建议的Spring JDBC Template，而是直接使用了JDBC，因而充斥了大量的冗余代码。再看他实现的DBConnection，居然将连接的相关属性硬编码到Java类中了：
{% codeblock lang:java database.DBConnection.java %}
public class DBConnection {</p>

<pre><code>private static Connection conn;

public static Connection getConnection() {
    String driver = "com.mysql.jdbc.Driver";
    String url = "jdbc:mysql://127.0.0.1:3306/test_01";
    String username = "root";
    String password = "";

    try {
        Class.forName(driver);
        conn = DriverManager.getConnection(url, username, password);
    } catch (ClassNotFoundException e) {
        e.printStackTrace();
    } catch (SQLException e) {
        e.printStackTrace();
    }

    return conn;
}

public static void disconnect() {
    try {
        conn.close();
    } catch (SQLException e) {
        e.printStackTrace();
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>再看测试，没有单元测试和集成测试的概念。一些本来可以进行单元测试的逻辑，例如针对Customer Nickname的验证逻辑，并没有得到足够的测试覆盖。由于没有构建脚本帮助搭建本地测试环境，在获得系统源代码后，根本无法运行集成测试。</p>

<p>整体来看，新手对一个项目如何进行分层以及分包缺乏基本的概念，没有自动化构建的意识。对于如何编写数据库访问的类也缺乏足够的知识。不了解单元测试与集成测试之间的区别，没有开发环境和测试环境的基本认识。</p>

<p>我首先考虑引入gradle实现基本的自动化构建，它可以通过引入一些插件就可以比较容易地实现java编译、测试以及自动化打包的功能，还能比较容易地运行Jetty。
{% codeblock lang:groovy build.gradle %}
apply plugin: 'idea'
apply plugin: 'java'
apply plugin: 'war'
apply plugin: 'jetty'</p>

<p>repositories {</p>

<pre><code>mavenCentral()
</code></pre>

<p>}</p>

<p>dependencies {</p>

<pre><code>compile (
        'joda-time:joda-time:2.1'
)
testCompile (
        'junit:junit:4.11',
        'org.mockito:mockito-all:1.9.5'
)
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>我修改了之前定义的infoTracker包，将其重命名为repository包，并放到domain包下，并对其下的类也同样进行了重命名。修改后的包结构如下图所示：
{% img center /images/2013/03/coach02.png %}</p>

<p>我没有修改数据库访问层的代码，而是要求新手使用JDBC Template，并着重给他讲解了数据库访问的基础知识，并要求他将数据库属性放置到配置文件中。我想，到了下一周，他又会提交一份什么样的代码呢？</p>
]]></content>
  </entry>
  
</feed>
