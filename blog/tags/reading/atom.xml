<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Reading | 简单文本]]></title>
  <link href="http://agiledon.github.com/blog/tags/reading/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2013-04-18T00:08:46+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ThoughtWorks(中国)程序员读书雷达]]></title>
    <link href="http://agiledon.github.com/blog/2013/04/17/thoughtworks-developer-reading-radar/"/>
    <updated>2013-04-17T21:46:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/04/17/thoughtworks-developer-reading-radar</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/04/reading-radar.jpg">
软件业的特点是变化。若要提高软件开发的技能，就必须跟上技术发展的步伐。埋首醉心于项目开发与实战，固然能够锤炼自己的开发技巧，却难免受限于经验与学识。世界上并不存在速成的终南捷径，但阅读好的技术书籍，尤其是阅读大师们的经典著作，总能收到事半功倍之效。一位优秀的程序员，或许就是一名好的阅读者。好的阅读者，总是知道如何选择好的书籍。书海浩繁，良莠不齐。阅读技术好书，如与智者交谈，“与君一席话胜读十年书”；遭遇技术烂书，如被拐卖，“少小离家老大回，乡音无改鬓毛衰”。</p>

<p>ThoughtWorks作为一家学习型组织，颇为看重每一位员工的学习能力。事实上，大多数ThoughtWorker的骨子里，都溢满了读书的基因。与书相伴，与书为伍，既是一种乐趣，又是一种习惯。当习惯成为自然时，书籍就成为生活和工作不可或缺的一部分了。如果说人文历史哲学等书籍是一碗心灵鸡汤，技术书籍大抵算得上是一味营养素，读之可以直接带来养分；可若是不了解自己究竟缺了哪一种营养，乱吃乱补，结果就可能适得其反了。有鉴于此，我和同事刘龙军结合自身的阅读经验，为新入职ThoughtWorks的程序员制作了一份读书路线图。我们将范围明确为程序员，是因为作为程序员的我们，它是我们最了解的工作角色。我们筛选出了一些大家公认的经典书籍，再结合自己的阅读体会，并广泛征集了更多ThoughtWorker的意见，包括徐昊，熊节，郑晔等资深阅读者，得到了这样一份草稿。在中国公司内部推出时，这份读书路线图得到了多数人的认可和欢迎。继而，我们在成都办公室陆续针对此读书路线图展开了读书俱乐部的活动，算是做了一次全方位大面积的试水。</p>

<p>现在，我们觉得是推出正式版本，并面向更多受众的时机了。这就是大家现在看到的ThoughtWorks(中国)程序员读书雷达。它相较于之前的读书路线图草稿，分类更为专业，书籍筛选更为合理，并以雷达独有的优势，来展现不同的阅读维度与阅读深度。显然，读书雷达更能表达我们对所选书籍的深度认识。它可以作为学习型组织的一份知识输入，每一位程序员都可以根据自身水平与能力，选择适合自己的书籍，甚至组成一份表达阅读履历的读书路线图，在获得知识完善与汲取的过程中，提高自身能力，达至各个维度的巅峰。</p>

<p>该读书雷达将书籍分为了如下四个维度：
<blockquote><p>Codeing Practice（编程实践）<br/>Architecture &amp; Design（架构与设计）<br/>Methodology（方法学）<br/>Thought &amp; Leadership（思想与领导力）</p></blockquote></p>

<p>我们之所以将方法学、思想与领导力放入到这个为程序员设计的读书雷达中，乃是因为软件开发不仅仅是个人的活动，也不仅仅是编码技巧和设计能力的体现。我们认为，开发技能其实是一项综合的系统工程。了解方法学，可以促进你对开发过程的理解；关于思想，则涉及大脑思维的修炼，可以提高程序员的抽象能力、学习能力，有助于帮助程序员发现事物发展的规律和本质；至于领导力，则有助于程序员在开发团队中发挥更大的作用，并能作为很好的团队成员，提升团队的整体能力。我们没有在这个读书雷达中包括语言类的书籍，原因在于这类书籍太过于发散，且更新较快；我们也不可能奢望在一张读书雷达图中，为不同的语言平台展现不同的优秀书籍。相比较语言的学习，我们更看重程序员在编程实践上的基本功。</p>

<p>每个维度皆分为三个等级，分别为Fundamental、Medium和Advanced，对应初学、进阶和高级。在雷达图中，读者可以根据该书在图中距离圆心的远近，判断它的难度级别。我们还使用了不同的图示来表达对每本书的倾向性意见，其中，橙色的三角形图示代表“强烈推荐”，蓝色的圆形图示代表“推荐”。我们希望这类书籍对于程序员而言，可以根据自己目前的水平，选择适合自己的书籍。在这个层次上，强烈推荐可能就意味着必读。</p>

<p>或许有人会质疑读书雷达的挑选标准。正所谓“每个人心中都有自己的哈姆雷特”，我们认同的未必能得到读者的认同，这是我们这个世界关于一种观点或态度的常态。我们发布这个读书雷达，只是希望能提供更多有用的信息与参考，而非代表一种读书权利的绝对化。事实上，我们也不可能做到。此外，"吾生也有涯，而知也无涯"，我们阅读的书籍毕竟有限，且读书雷达的容量也有限，难免会有遗珠之叹，这也是一件无可奈何之事。然而，我们欢迎更多的批评与建议，或许你推荐的好书恰恰是我们遗忘的，又或者激起了我们的共识，那么我们也会毫不吝啬地更新读书雷达，以求做到我们能力范围内的尽善尽美。当然，正如你看到的，我们在Methodolog（方法学）维度，更多地推荐了与敏捷和精益相关的书籍。这是因为我们对敏捷技能与方法更有心得和信心。对于一些未知领域，我们不敢也不愿做出可能误导人的推荐。</p>

<p>本读书雷达虽然冠以ThoughtWorks（中国）之名，但选书的倾向与意见并非ThoughtWorks（中国）官方的态度，而是作为制作者（龙军和我）个人表达的意见而已。如果你也加入了ThoughtWorks，你一定会发现这种自发组织的民间活动，在ThoughtWorks可谓俯拾皆是，不用诧异。</p>

<p>我将在后面的文章中，根据每个维度为每一本书给出我们的推荐理由。此时，书籍成为了我们的臣民，我想对这个王国做一次不吝惜赞赏的巡视。最后，列出读书雷达的中英文书单，如下所示：</p>

<h3>Coding Practice | 编程实践</h3>

<h4>基础篇</h4>

<p><blockquote><p>Clean Code《代码整洁之道》<br/>Pragmatic Unit Testing《单元测试之道》<br/>The Productive Programmer《卓有成效的程序员》<br/>Test-Driven Development By Example《测试驱动开发》<br/>Clean Coder《程序员的职业修养》<br/>The Art of Readable Code《编写可读代码的艺术》</p></blockquote></p>

<h4>进阶篇</h4>

<p><blockquote><p>Refactoring To Patterns《重构与模式》<br/>Implementation Patterns《实现模式》<br/>Code Completed《代码大全》<br/>The Pragmatic Programmer《程序员修炼之道》</p></blockquote></p>

<h4>高级篇</h4>

<p><blockquote><p>Structure and Interpretation of Computer Programs《计算机程序的构造和解释》<br/>Working Effectively with Legacy Code《修改代码的艺术》</p></blockquote></p>

<h3>Architecture &amp; Design | 架构与设计</h3>

<h4>基础篇</h4>

<p><blockquote><p>Agile Software Development 《敏捷软件开发：原则、实践与模式》<br/>Head First Design Patterns《深入浅出设计模式》<br/>Design Patterns 《设计模式》</p></blockquote></p>

<h4>进阶篇</h4>

<p><blockquote><p>The Art of UNIX Programming 《Unix编程艺术》<br/>Practical API Design  《框架设计的艺术》<br/>Domain Specific Languages 《领域特定语言》<br/>Patterns of Enterprise Application Architecture 《企业应用架构模式》</p></blockquote></p>

<h4>高级篇</h4>

<p><blockquote><p>Release It<br/>Domain-Driven Design 《领域驱动设计》<br/>Enterprise Integration Patterns《企业集成模式》<br/>Beautiful Architecture《架构之美》<br/>Pattern-Oriented Software Architecture《面向模式的软件架构》</p></blockquote></p>

<h3>Methodology | 方法学</h3>

<h4>基础篇</h4>

<p><blockquote><p>User Stories Applied《用户故事与敏捷方法》<br/>The Gold Mine《金矿》<br/>Scrum and XP From the Trenches《硝烟中的Scrum和XP》<br/>Continuous Integration《持续集成》<br/>Extreme Programming Explained《解析极限编程》</p></blockquote></p>

<h4>进阶篇</h4>

<p><blockquote><p>Lean Thinking《精益思想》<br/>Continuous Delivery《持续交付》<br/>How Google Tests Software<br/>Agile Testing<br/>Extreme Programming Refactored《重构极限编程》</p></blockquote></p>

<h4>高级篇</h4>

<p><blockquote><p>Specification By Example</p></blockquote></p>

<h3>Thought &amp; Leadership | 思想与领导力</h3>

<h4>基础篇</h4>

<p><blockquote><p>The Effective Executive《桌有成效的管理者》<br/>Are Your Lights On?《你的灯亮着吗》<br/>Becoming A Technical Leader《成为技术领导者》</p></blockquote></p>

<h4>进阶篇</h4>

<p><blockquote><p>The Fifth Discipline《第五项修炼》<br/>The Design Of Business<br/>Management 3.0《管理3.0：培养和提升敏捷领导力》<br/>Presentation To Win<br/>The McKinsey Way《麦肯锡方法》</p></blockquote></p>

<h4>高级篇</h4>

<p><blockquote><p>Thinking, Fast and Slow《思考快与慢》</p></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[苍老与隐居以及战斗]]></title>
    <link href="http://agiledon.github.com/blog/2013/03/16/old-and-reclusion-and-fight/"/>
    <updated>2013-03-16T21:47:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/03/16/old-and-reclusion-and-fight</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/03/old.jpeg">
杜拉斯在《情人》里劈头就是这么一段话：“我已经老了，有一天，在一处公共场所的大厅里，有一个男人向我走来。他主动介绍自己，他对我说：‘我认识你，永远记得你。那时候，你还很年轻，人人都说你美，现在，我是特为来告诉你，对我来说，我觉得现在你比年轻的时候更美，那时你是年轻女人，与你那时的面貌相比，我更爱你现在备受摧残的面容。’”</p>

<p>人的沧桑如年代悠远的古董一般让人怀念，如侵蚀后的青铜器斑驳的美。每位老人都是讲不完的长篇故事，刻在皱纹里的是曾经拥有的回忆。似乎什么都经历过，似乎什么都未曾经历得完全，孤独与衰老慢慢侵袭而来，正如皱纹慢慢爬上额头。时光开始变得急促，可惜步子越发的蹒跚，再也无法追赶光阴的影子了。这或许是一种无奈；然而，真正的苍老总是懂得生命的哲理，毋须哀叹这不可追回的韶光。沧桑的历练足以让老人在回忆中度过另一个鲜活的生命。这是一种睿智。这种睿智仿佛一把金刚刀，岁月之美如钻石一般被切割出来，拥有那玲珑剔透的切面，折射出璀璨的辉光。</p>

<p><blockquote><p>然而，面对苍老，我总不免低低咏叹：<br/>你饱经沧桑的双眼，<br/>为何总饱含着忧伤的泪水？</p></blockquote></p>

<p>想到人的日渐衰老，我总是无法抑制地哀伤。“夕阳无限好，只是近黄昏”，李商隐的一句诗，道尽了这其中的无奈，甚至是凄楚。或许，自私的人们总是可以欣赏别人备受摧残的面容，却无法容忍自己的老去，最后走向阴冷的坟墓。对苍老的诵咏，就变成一曲对凄美的哀歌了。</p>

<p>“不要老去！”我在心里呐喊。可是，我终究是要老去的。</p>

<p>其实，我已经老了。我变得渴望隐居的生活。我变得害怕喧嚣，甚至不愿有太多感情的牵绊。这是否是衰老的征兆？</p>

<p>我的厌世之情，或许源于我执著于醉意孤独？我的思想没有任何人能够理解，因为，连我自己都不理解我自己。或许，无所不知的全能的神是一个例外，可是，作为高高在上的神灵，哪里会关注我这样一个卑微如蝼蚁一般的生命呢？更何况在这世上，神灵究竟存在与否，我仍然保持着足够谨慎的怀疑。</p>

<p>这是否是我渴望隐居的原因之一呢？</p>

<p>我从来不明白玄学的意义，但我却开始变得眷恋虚空的思索，就像卢梭一个孤独漫步者的遐想那般，思索道德与人生，抑或是自主意识地从内心识别自己，而无需那些澹妄的敌人为自己做出盖棺论定。在这个世界，我们面对的每一个人都是敌人，他们试图戴上伪装的面具，靠近我，或者疏远我。我希望逃离，无奈人生的樊笼早已锁住了我，我无法逃离，甚至我不能逃离。</p>

<p>这就是我渴望隐居的原因之一吧！</p>

<p>约翰·汤姆逊造访晚清时的中国，在广东乡村的游历中，访谒清远县的飞来寺，留下了两位僧人的存影。汤姆逊说：“和尚们隐居那里，远离尘世，他们认为什么时候能从宇宙万物中认识了抽象的自我，什么时候就会忘记存在，忘记喜怒哀乐，从而达到绝对的清静，进而修成正果——涅槃。”</p>

<p>若真能够隐居的我，断然做不到这样枯守住内心的寂寞与安宁。我骨子里希望自己能是一个脱俗的人，然而，我的灵魂却总是甘于在尘世中堕落。灵与肉的分离，使我彻底沦为矛盾的共同体，我始终陷入挣扎中。愈是挣扎，绳索捆缚得愈紧，这令我感到悲哀，进而是苦闷。</p>

<p>厨川白村在其著述《苦闷的象征》中写道：“……无非说是‘活着’这事，就是反复着这战斗的苦难。我们的生活愈不肤浅，愈深，便比照着这深，生命力愈盛，便比照着盛，这苦恼也不得不愈加其烈。在伏在心的深处的内底生活，即无意识心理的底里，是蓄积着极痛烈而且深刻的许多伤害的。一面经验着这样的苦闷，一面参与着悲惨的战斗，向人生的道路进行的时候，我们就或呻，或叫，或怨嗟，或号泣，而同时也常有自己陶醉在奏凯的欢乐和赞美的事。这发出来的声音，就是文艺。对于人生，有着极强的爱慕和执着，至于虽然负了重伤，流着血，苦闷着，悲哀着，然而放不下，忘不掉的时候，在这时候，人类发出来的诅咒，愤激，赞叹，企慕，欢呼的声音，不就是文艺么？在这样的意义上，文艺就是朝着真善美的理想，追赶向上的一路的生命的进行曲，也是进军的喇叭。响亮的闳远的那声音，有着贯天地动百世的伟力的所以就在此。”</p>

<p>若能在苦闷中不停地战斗，即使暴风骤雨满路荆棘，鲜血淋漓狼狈不堪，总还能印证自己的存在。战斗是一种精神，一种态度。它或许仅仅是一种象征意义，然而我们在战斗中会变得饱满而鲜活——暮然回首，我们发现，生活多么的畅快淋漓！此时，苍老其实是一种壮美；毋宁说，隐居也变成了一种战斗！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阅读的设计体悟]]></title>
    <link href="http://agiledon.github.com/blog/2013/03/02/harvest-from-reading/"/>
    <updated>2013-03-02T21:46:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/03/02/harvest-from-reading</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/03/jsbookcover.jpg">
不管语言的变化有多大，关于程序设计的基本编程思想和设计本质，应是殊途同归。两年前阅读了Jonathan Snook的著作《Javascript捷径教程Accelerated DOM Scripting with Ajax, APIs, and Libraries》。在书中，他带领读者构建了一个简单的动画对象。简单的例子，轻描淡写的描述，却似乎展现了朴素的基本设计思想。</p>

<!--more-->


<p>下面记录了一些阅读感悟。例如，书中这样写道：
<blockquote><p>页面里要用到的动画对象一般都不止一个，所以应该把它定义成一个类。定义一个有5个参数的函数：要加上动画的元素、要改变的属性、属性的起始值、属性的结束值、动画的持续时间。<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">duration</span><span class="p">){}</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></p><p><p>不管编写什么代码，都应该先把实现想透彻。每个决定都有正反两方面的后果，你应该想清楚每个决定的原因。</p></blockquote></p>

<p>这代表一个朴素的思想，那就是从实现原理来进行设计决定。注意这里的实现原理，并不是要关注实现的细节，而是要考虑影响实现的因素，并从调用者的角度思考接口或函数的输入与输出值。以本例而言，如果事先不明确动画效果的营造方式，是根据时间的变化动态变更element属性的方式来完成，就无法确定Animation函数。设计不是空中楼阁，抽象固然是重要的，但功能实现的基本原理仍然需要事先思考通透，否则，设计就可能走弯路。拿到一个功能，先要弄清楚它的目标是什么，有没有质量属性的要求，未来的变化如何，还有这一功能的实现原理。例如，我们要提供服务定制的功能，就需要实现明确“服务”的定义，如何完成服务的注册，服务的发布，服务的订阅，谁会订阅这些服务，服务的安全如何保障，如何解决服务与实现的脱耦。只有把这些问题想清楚了，设计才会靠谱。
<blockquote><p>看看前面的代码，元素ID是作为一个字符串传递进来的，那么在动画对象中获取该元素就有两种方法：一是通过DOM方法document.getElementById()；二是采用Javascript库的调用，如${}。……既然我们想让这个动画对象能适合各种情况，那还是用DOM方法比较好，保证它不依赖于任何库。<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span><br/></span><span class='line'><span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">ducument</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span><br/></span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">el</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></blockquote></p>

<p>这段话仍然体现了一种设计决策。它的实现目标是不与任何JS库耦合。这就需要保证实现的通用性。
<blockquote><p>要是你打算执行动画的元素没有ID怎么办呢？为了让这个类更灵活，让我们把它改成既可以传入元素引用，又可以传入ID字符串。如果传入的是ID字符串而不是对象引用，程序就会通过DOM方法去获取元素。两全其美！<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span><br/></span><span class='line'><span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span><br/></span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">el</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span><br/></span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">el</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></blockquote></p>

<p>这又是一种编码修炼了。除了要在设计上保证灵活性之外，我们在编码时也需养成保证代码完整性与健壮性的习惯，并体贴地为调用者着想。有这么一条设计原理，就是伯斯塔尔法则(Postel's Law)：“发送时要保守；接收时要开放。”这里的实现无疑遵循了这样一个法则。我们在编码时，考虑到这些因素了吗？</p>

<p>Ok，继续我们的阅读。
<blockquote><p>实例化一个对象要用到5个参数，但一眼看上去很难看出参数里的那些数字都代表什么含义。……为此你可以把参数改成字面量对象，键的名称看起来更直观一些。而且如此改动能使API更加灵活，因为即使今后增加了更多的参数，实例化对象的代码也不会变得更复杂。<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span><br/></span><span class='line'><span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">options</span><span class="p">.</span><span class="nx">element</span><span class="p">;</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}</span><br/></span><span class='line'><span class="kd">var</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="nx">element</span><span class="o">:</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;elementId&#39;</span><span class="p">),</span><br/></span><span class='line'><span class="nx">property</span><span class="o">:</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span><br/></span><span class='line'><span class="nx">from</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span><br/></span><span class='line'><span class="nx">to</span><span class="o">:</span><span class="mi">200</span><span class="p">,</span><br/></span><span class='line'><span class="nx">duration</span><span class="o">:</span><span class="mi">1000</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">};</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></blockquote></p>

<p>无疑，这体现了面向对象的“封装”思想。通过封装既保证了代码的清洁与可读性，同时还有利于未来的扩展。这与OCP（开放-封闭原则）是一脉相承的。代码是有结构的，或者体现为函数，或者体现为对象，事实上都是一种按照属性与职责进行的分类。分类是保持清洁、避免重复的唯一法门。从简朴的角度来说，所有的设计其实都是在做着分类的游戏。分类体现了定义的抽象，职责的分配，结构的划分；如果再加上类别之间的协作，就是设计的全部了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[可伸缩系统的架构经验]]></title>
    <link href="http://agiledon.github.com/blog/2013/02/27/scalability-system-architecture-lessons/"/>
    <updated>2013-02-27T11:37:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/02/27/scalability-system-architecture-lessons</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/02/scalability.jpg"></p>

<p>最近，阅读了Will Larson的文章<a href="http://lethain.com/introduction-to-architecting-systems-for-scale/">Introduction to Architecting System for Scale</a>，感觉很有价值。作者分享了他在Yahoo!与Digg收获的设计可伸缩系统的架构经验。在我过往的架构经验中，由于主要参与开发企业软件系统，这种面向企业内部的软件系统通常不会有太大的负载量，太多的并发量，因而对于系统的可伸缩性考虑较少。大体而言，只要在系统部署上考虑集群以及负载均衡即可。本文给了我很多启发，现把本文的主要内容摘译出来，并结合自己对此的理解。</p>

<!--more-->


<p>Larson首先认为，一个理想的系统，对于容量（Capacity）的增长应该与添加的硬件数是线性的关系。换言之，如果系统只有一台服务器，在增加了另一台同样的机器后，容量应该翻倍。以此类推。这种线性的容量伸缩方式，通常被称之为水平伸缩“Horizontal Scalability”。</p>

<p>在设计一个健壮的系统时，自然必须首要考虑失败的情况。Larson认为，一个理想的系统是当失去其中一台服务器的时候，系统不会崩溃。当然，对应而言，失去一台服务器也会导致容量的响应线性减少。这种情况通常被称为冗余“Redundancy”。</p>

<h3>负载均衡</h3>

<p>无论是水平伸缩还是冗余，都可以通过负载均衡来实现。负载均衡就好似一个协调请求的调停者，它会根据集群中机器的当前负载，合理的分配发往Web服务器的请求，以达到有效利用集群中各台机器资源的目的。显然，这种均衡器应该介于客户端与Web服务器之间，如下图所示：
<img class="center" src="/images/2013/02/scalability01.png"></p>

<p>本文提到了实现负载均衡的几种方法。其一是Smart Client，即将负载均衡的功能添加到数据库（以及缓存或服务）的客户端中。这是一种通过软件来实现负载均衡的方式，它的缺点是方案会比较复杂，不够健壮，也很难被重用（因为协调请求的逻辑会混杂在业务系统中）。对此，Larson在文章以排比的方式连续提出问题，以强化自己对此方案的不认可态度：
<blockquote><p>Is it attractive because it is the simplest solution? Usually, no. Is it seductive because it is the most robust? Sadly, no. Is it alluring because it'll be easy to reuse? Tragically, no.</p></blockquote></p>

<p>第二种方式是采用硬件负载均衡器，例如<a href="http://www.citrix.com/English/ps2/products/product.asp?contentID=21679">Citrix NetScaler</a>。不过，购买硬件的费用不菲，通常是一些大型公司才会考虑此方案。</p>

<p>如果既不愿意承受Smart Client的痛苦，又不希望花费太多费用去购买硬件，那就可以采用一种混合（Hybird）的方式，称之为软件负载均衡器（Software Load Balancer）。Larson提到了<a href="http://haproxy.1wt.eu/">HAProxy</a>。它会运行在本地，需要负载均衡的服务都会在本地中得到均衡和协调。</p>

<h3>缓存</h3>

<p>为了减轻服务器的负载，还需要引入缓存。文章给出了常见的对缓存的分类，分别包括：预先计算结果（precalculating result，例如针对相关逻辑的前一天的访问量）、预先生成昂贵的索引（pre-generating expensive indexes，例如用户点击历史的推荐）以及在更快的后端存储频繁访问的数据的副本（例如<a href="http://memcached.org/">Memcached</a>）。</p>

<h4>应用缓存</h4>

<p>提供缓存的方式可以分为应用缓存和数据库缓存。此二者各擅胜场。应用缓存通常需要将处理缓存的代码显式地集成到应用代码中。这就有点像使用代理模式来为真实对象提供缓存。首先检查缓存中是否有需要的数据，如果有，就从缓存直接返回，否则再查询数据库。至于哪些值需要放到缓存中呢？有<a href="http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used">诸多算法</a>，例如根据最近访问的，或者根据访问频率。使用Memcached的代码如下所示：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='python'><span class='line'><span class="n">key</span> <span class="o">=</span> <span class="s">&quot;user.</span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">user_id</span>
</span><span class='line'><span class="n">user_blob</span> <span class="o">=</span> <span class="n">memcache</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="n">user_blob</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">user</span> <span class="o">=</span> <span class="n">mysql</span><span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="s">&quot;SELECT * FROM users WHERE user_id=</span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\&quot;</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">user_id</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="n">user</span><span class="p">:</span>
</span><span class='line'>    <span class="n">memcache</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">user</span><span class="p">))</span>
</span><span class='line'><span class="k">return</span> <span class="n">user</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="k">else</span><span class="p">:</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">user_blob</span><span class="p">)</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<h4>数据库缓存</h4>

<p>数据库缓存对于应用代码没有污染，一些天才的DBA甚至可以在不修改任何代码的情况下，通过数据库调优来改进系统性能。例如通过配置Cassandra行缓存。</p>

<h4>内存缓存</h4>

<p>为了提高性能，缓存通常是存储在内存中。常见的内存缓存包括Memcached和<a href="http://redis.io/">Redis</a>。不过采用这种方式仍然需要合理的权衡。我们不可能一股脑儿的将所有数据都存放在内存中，虽然这会极大地改善性能，但比较起磁盘存储而言，RAM的代价更昂贵，同时还会影响系统的健壮性，因为内存中的数据没有持久化，容易丢失。正如之前提到的，我们应该将需要的数据放入缓存，通常的算法是<a href="http://en.wikipedia.org/wiki/Cache_algorithms#Least_Recently_Used">least recently used</a>，即LRU。</p>

<h4>CDN</h4>

<p>提高性能，降低Web服务器负载的另一种常见做法是将静态媒体放入CDN（Content Distribution Network）中。如下图所示：
<img class="center" src="/images/2013/02/scalability02.png"></p>

<p>CDN可以有效地分担Web服务器的压力，使得应用服务器可以专心致志地处理动态页面；同时，CDN还可以通过地理分布来提高响应请求的性能。在设置了CDN后，当系统接收到请求时，首先会询问CDN以获得请求中需要的静态媒体（通常会通过HTTP Header来配置CDN能够缓存的内容）。如果请求的内容不可用，CDN会查询服务器以获得该文件，并在CDN本地进行缓存，最后再提供给请求者。如果当前网站并不大，引入CDN的效果不明显时，可以考虑暂不使用CDN，在将来可以通过使用一些轻量级的HTTP服务器如<a href="http://nginx.org/">Nginx</a>，为静态媒体分出专门的子域名如static.domain.com来提供服务。</p>

<h4>缓存失效</h4>

<p>引入缓存所带来的问题是如何保证真实数据与缓存数据之间的一致性。这一问题通常被称之为缓存失效（Cache Invalidation）。从高屋建瓴的角度来讲，解决这一问题的办法无非即使更新缓存中的数据。一种做法是直接将新值写入缓存中（通常被称为write-through cache）；另一种做法是简单地删除缓存中的值，在等到下一次读缓存值的时候再生成。</p>

<p>整体而言，要避免缓存实效，可以依赖于数据库缓存，或者为缓存数据添加有效期，又或者在实现应用程序逻辑时，尽量考虑避免此问题。例如不直接使用DELETE FROM a WHERE…来删除数据，而是先查询符合条件的数据，再使得缓存中对应的数据失效，继而根据其主键显式地删除这些行。</p>

<h3>Off-Line处理</h3>

<p>这篇文章还提到了Off-Line的处理方式，即通过引入消息队列的方式来处理请求。事实上，在大多数企业软件系统中，这种方式也是较为常见的做法。在我撰写的文章《<a href="http://agiledon.github.com/blog/2012/12/27/distributed-architecture-based-on-message/">案例分析:基于消息的分布式架构</a>》中，较为详细地介绍了这种架构。在引入消息队列后，Web服务器会充当消息的发布者，而在消息队列的另一端可以根据需要提供消费者Consumer。如下图所示。对于Off-Line的任务是否执行完毕，通常可以通过轮询或回调的方式来获知。
<img class="center" src="/images/2013/02/scalability03.png"></p>

<p>为了更好地提高代码可读性，可以在公开的接口定义中明确地标示该任务是On-Line还是Off-Line。</p>

<p>引入Message Queue，可以极大地缓解Web服务器的压力，因为它可以将耗时较长的任务转到专门的机器上去执行。</p>

<p>此外，通过引入定时任务，也可以有效地利用Web服务器的空闲时间来处理后台任务。例如，通过Spring Batch Job来执行每日、每周或者每月的定时任务。如果需要多台机器去执行这些定时任务，可以引入Spring提供的<a href="https://puppetlabs.com">Puppet</a>来管理这些服务器。Puppet提供了可读性强的声明性语言来完成对机器的配置。</p>

<h4>Map-Reduce</h4>

<p>对于大数据的处理，自然可以引入Map-Reduce。为整个系统专门引入一个Map-Reduce层来处理数据是有必要的。相对于使用SQL数据库作为数据中心的方式，Map-Reduce对可伸缩性的支持更好。Map-Reduce可以与任务的定时机制结合起来。如下图所示：
<img class="center" src="/images/2013/02/scalability04.png"></p>

<h3>平台层</h3>

<p>Larson认为，大多数系统都是Web应用直接与数据库通信，但如果能加入一个平台层（Platform Layer），或许会更好。
<img class="center" src="/images/2013/02/scalability05.png"></p>

<p>首先，将平台与Web应用分离，使得它们可以独立地进行伸缩。例如需要添加一个新的API，就可以添加新的平台服务器，而无需增加Web服务器。要知道，在这样一个独立的物理分层架构中，不同层次对服务器的要求是不一样的。例如，对于数据库服务器而言，由于需要频繁地对磁盘进行I/O操作，因此应保证数据库服务器的IO性能，如尽量使用固态硬盘。而对于Web服务器而言，则对CPU的要求比较高，尽可能采用多核CPU。</p>

<p>其次，增加一个额外的平台层，可以有效地提高系统的可重用性。例如我们可以将一些与系统共有特性以及横切关注点的内容（如对缓存的支持，对数据库的访问等功能）抽取到平台层中，作为整个系统的基础设施（Infrastructure）。尤其对于产品线系统而言，这种架构可以更好地为多产品提供服务。</p>

<p>最后，这种架构也可能对跨团队开发带来好处。平台可以抽离出一些与产品无关的接口，从而隐藏其具体实现的细节。如果划分合理，并能设计出相对稳定的接口，就可以使得各个团队可以并行开发。例如可以专门成立平台团队，致力于对平台的实现以及优化。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Java设计模式译者序]]></title>
    <link href="http://agiledon.github.com/blog/2013/02/22/preface-of-java-design-patterns/"/>
    <updated>2013-02-22T16:52:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/02/22/preface-of-java-design-patterns</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/02/dpinjava.jpeg">
如今，介绍和讲解设计模式的书籍可谓汗牛充栋。无论是定义、解读、延伸还是扩展，都是基于面向对象的设计原则，用了放大镜对着GOF提出的23种设计模式，如科学解剖一般，剖析每一道脉络，观察每一片纹理，细微至纤毫毕现，真可以说是道尽个中妙处；许多精妙阐述，又如黄钟大吕，振聋发聩，醍醐灌顶。</p>

<p>是否设计模式的精妙之处，业已为这些著作所穷尽？然，又未必尽然！以模式而论，若只局限在这23种模式的范围内，几乎每种模式的变化，都可以被悉心推演出来；每种模式的结构，也已被阐述得淋漓尽致。然而，若论及设计，则如大道苍穹，实则是不可穷尽的。基本上，设计的复杂程度已不亚于一个纷繁的世界，而软件，就是我们要构造的这个世界。</p>

<p>因此，再出现一本讲解设计模式的书，就不足为怪了。那么，它值得你去阅读吗？</p>

<!--more-->


<p>讨论一本书是否值得阅读，应基于书本身的价值去判断，判断的标准则依据读者的目标而定。从读者而非译者的角度看待本书，个人认为，它确乎是有价值的。这些价值主要体现在三个方面。</p>

<p>GOF对于23种设计模式的分类已经深入人心，即众所周知的创建型模式、结构型模式与行为型模式。这一分类浅显易懂，明白无误的表达了模式的意图与适用场景。但是，这一分类仍有不足之处。例如建造者模式除了关注对象的创建之外，还需处理好对象之间的结构；又例如桥接模式对于抽象与实现的解耦，在一定程度上又体现了对行为的抽象；再比如行为模式中的迭代器模式，其实还涵盖了创建迭代器的职责。本书对于设计模式的分类不落窠臼，根据作者对于设计模式的思考，别出心裁地给出了自己的一种分类，即分为接口型模式、职责型模式、构造型模式、操作型模式与扩展型模式。如果仔细阅读和思考这些模式，你会发现这五类分类很好地抓住了相关模式的设计本质。譬如，扩展型模式关注的是代码功能的扩展，因而很自然地就可以把装饰器模式与访问者模式归入这一类。</p>

<p>彰显本书价值的第二方面在于贯穿本书始终的习题练习，作者将其称之为“挑战”。确实如此，这些挑战仿佛是作者故意为读者设定的“陷阱”，“障碍”，是登堂入室所必须跨过的门槛。最关键的一点是，通过这些“挑战”，就从单方面的灌输知识，变成了一定程度的双向互动。作者就像课堂上的老师，提出问题引人思考；读者就是学生，面对老师“咄咄逼人”的提问，必须打起十二分的精神，分析问题，寻找问题的答案。最后，循循善诱的老师给出了自己的解决方案。学生可以相互对比，以便于发现自己在设计上还存在的问题。因此，本书不适合那些惫懒的读者，不适合那些喜欢被动接收知识输入，不善于思考，不善于总结的程序员。</p>

<p>真正让本书获得赞誉的还是本书给出的案例，不过，也很有可能因此收获负面的批评。本书的案例是一个虚拟的真实项目。Oozinoz公司纯属子虚乌有，完全是由作者杜撰出来的一家虚拟公司；但这个案例又如此的真实，既牵涉到复杂的领域逻辑，又面对客户提出的种种需求变化，与我们工作中需要开发的项目何其相似！可能面临的批评是，为了学习设计模式，可能读者还需要成为一名烟火专家。然而，我谨以最谦卑的态度恳求诸位，在满怀怨气、恶毒诅咒作者（也可能包括躺着中枪的译者）之前，先想想我们平时开发的软件，是否存在相似复杂度的领域需求呢？让我们再仔细想想，倘若作者给出一个纯粹编造出来的玩具项目，贴近生活，浅显易懂，学习起来势如破竹，一路通关，是否真的意味着你已经明白如何在真实项目中运用设计模式？窃以为，学习尤其是技术学习，并不都是舒舒服服寓教于乐，躺着，玩着以及笑着也能学好设计模式。你以为的懂，以为的悟，其实还是一种虚妄。你抓住的是水中央的月影，一旦遇到真实案例，就好似石头打破水面的宁静，一切都会破碎。</p>

<p>本书的原版事实上获得了业界的广泛赞誉，同时也是John Vlissides主编的“软件模式”丛书之一。John Vlissides就是著名的GOF其中之一位，可惜他已在多年前离开人世。本书作者是John Vlissides的生前好友，本书内容曾经得到过他的建议。从书的内容来看，部分Java案例显得有些过时；不过，就设计而言，拥有悠久的历史，有时候意味着它可能成为经典。不错，与经典的GOF《设计模式》相比，本书无疑要失色许多。GOF《设计模式》的光芒在于它的开创性。只要是讲解设计模式，没有哪一本书的光芒可以盖过GOF的著作。它就像是一颗恒星，其他有关设计模式的书籍，是围绕着它公转的一颗颗行星，都是借着恒星的光芒反射出属于自己的光亮。 然而，从光芒的热度与亮度来讲，也许行星才是当前的你最适合的。</p>

<p>阅读本书的读者，除了需要具备一些面向对象与设计模式的基础知识外，还需要有足够的耐心，并保存一份渴望与热情。耐心可以帮助你坚持细读与精读，持之以恒地深入理解本书的案例分析，努力面对作者给出的挑战。而这种耐心则需要提高技术能力的渴望，探求技术奥秘的热情来时刻保鲜。</p>

<p>本书的翻译由我的同事史磊与我共同完成，并最后由我完成审校工作。在翻译本书时，我还参考了由龚波、赵彩琳、陈蓓翻译的前一个版本，在此向他（她）们表示衷心地感谢。因为工作繁忙的缘故，本书的翻译工作一直断断续续持续了近一年的时间，如今交稿，既有卸下重任的轻松畅快，却又因为自己的惫懒使得翻译工作进展缓慢而深感愧疚。这里需要感谢本书编辑符隆美女士给予我的耐心与支持。</p>

<p>在写作这篇译者序时，同事史磊已经远赴ThoughtWorks南非工作，而我则从北京回到了ThoughtWorks成都。非常怀念我们在北京Office一起工作的日子。我们曾经在同一个项目结对编程，本书的翻译也可以说是结对完成，算是一次愉快的翻译体验。鉴于本人能力水平有限，翻译或有疏漏或错误，还请读者不吝赐教，并通过<a href="http://aigledon.github.com">我的博客</a>与我联系。</p>
]]></content>
  </entry>
  
</feed>
