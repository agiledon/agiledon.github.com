<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Reading | 简单文本]]></title>
  <link href="http://agiledon.github.com/blog/tags/reading/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2014-02-07T17:59:43+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[读《被禁锢的头脑》]]></title>
    <link href="http://agiledon.github.com/blog/2014/01/10/reading-the-captive-mind/"/>
    <updated>2014-01-10T22:24:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/01/10/reading-the-captive-mind</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2014/captivemind.jpg">
米沃什在《被禁锢的头脑》中，描述了战时东欧的白色恐怖：</p>

<blockquote><p>此时带着套马索的骑马者就会出现。那就是‘囚车’，即停在街角，用帆布遮盖着的大卡车。行人根本预见不到那里会有危险，当他们路过那个街角时，会突然感觉有一支枪顶住他。它也许会被关进集中营，或者会被推到墙下，用胶布封上嘴巴以防止他喊出反对占领国的口号，然后就被枪毙。这一切都令城市居民心惊胆战，迫使他们俯首帖耳。为了避免这种不幸，最好的办法就是足不出户。但是作为一家之主的父亲必须外出挣钱，弄点供养他的妻儿老小的面包和菜汤。每到晚上，家里人就开始心绪不宁，担心父亲是否还回得来。这种情况已经持续多年，所以人们渐渐觉得他们居住的这座城市简直就是危机四伏的原始森林，20世纪人的命运，与那些每天跟毒蛇猛兽作生死搏斗的穴居人的命运没什么两样。</p></blockquote>

<p>没有经历过这种生活的人阅读这样的文字，仍然可以体会那种惶惶的恐怖，这种恐慌如慢性毒药一般啃啮人的心灵。与其这般在极大恐惧中担惊受怕，过着如丧家犬的生活，不知什么时候会抛尸街头或者入牢笼中受非人的折磨，真还不如扛起枪冲出战壕面对冷酷而喧嚣的枪林弹火呢。</p>

<!--more-->


<p>第三章《凯特曼——伪装》描述的情景，不正是文革中诸多知识分子奉行的——美学凯特曼。同样的政治高压与知识钳制发生在同样的社会主义国家，这岂是偶然？思想正确的真理“唯一”论，已经说明了这种真理的不可信。正如奥威尔在《一九八四》借温斯顿之口说出的“所谓自由就是可以说二加二等于四的自由。承认这一点，其他一切就迎刃而解。”在真理唯一性的指导下，我们没有自由反驳老大哥的言论了，即使最蠢的傻瓜都知道这种言论的谬误。</p>

<p>这样的社会主义，何异于“指鹿为马”的赵高宣泄权利的恶时代呢？阅读《被禁锢的头脑》，感觉就是《一九八四》的现实版。</p>

<p>在第八章的219页，米沃什写道：“他们的研究对象是不同群体的居民。有产者阶级最不重要，他们由于工厂、矿山收归国有和农业改革而被剥夺了财产，不是供研究的主要对象。”</p>

<p>“小资产阶级——小商人和手工业工作者不应受到忽略，他们是深深扎根于民众的一股强大力量。”</p>

<p>然后书中以调侃方式提到什么叫“资本主义萌芽”，什么叫”资本主义复辟“，什么又叫”投机倒把者“，真是入木三分啊！</p>

<p>书中描绘对农民的斗争策略，可谓摸准了人性，各种隐藏的恶与自私在显微镜下纤毫毕现，他们就好像发现了病毒，却并不思考如何寻找疫苗，反而将这种病毒扩大，扩散，以期求得对他们更为广泛的利益。——“于是把农民分为‘贫农’、‘中农’、‘富农’，因为，只有利用他们之间彼此的敌对心理，打破农村的团结，才能达到目的。”——真正是四两拨千斤的高妙手段。</p>

<p>对付工人的手段仍然利用了人性，与对付农民的手段如出一辙：“总的来说，提出‘工人团结’的口号并不意味着可以放纵某一工厂工人的团结，因为这种团结会因选拔劳动‘突击手’而被瓦解——劳动‘突击手’就是超额完成任务者，这就会让其他工人感到有压力或力不从心。有两种手段可以影响工人们的思想：一方面激起他们的雄心壮志，一方面要求他们承受党组织所施加的压力。”</p>

<p>米沃什的结论是：一切都导致对人的头脑的统治。于是党的宣传手段如宗教信仰一般，以某种集体仪式，达成一种心理催眠的信仰氛围，即使心有不信者，也会被慢慢潜移默化了。于是——</p>

<blockquote><p>这个集合体是由个体组成的，有些人虽对这一切心怀疑虑，还是说了预先规定该说的话，唱了预先规定该唱的歌；这种行为就打造出了一种群体氛围，最后自己也被这种氛围所感染。俱乐部的影响尽管带有理性的表征，但也属于群体魔术现象之列。</p></blockquote>

<p>米沃什提到了“知识庸俗化”带来的影响，可谓猛于虎矣。</p>

<blockquote><p>例如，简单化和庸俗化的达尔文物种起源和物竞天择理论，都已不同于达尔文以及与他争论的学者们的理论。它已被改造成社会学理论的重要部分，带有某种感情色彩了。20世纪的领袖们，例如希特勒，其知识仅仅源于科普小册子，这就可以解释他们头脑中不可思议的知识混乱。<strong>庸俗化知识的特点是：它让人感觉一切都是明明白白的，一切都是可以解释清楚的；</strong>它也令人想起在深渊之上架设吊桥的方法，沿着吊桥可以大胆地往前走，同时自欺欺人地认为：脚下没有万丈深渊，同时要记住，眼睛千万不能往深渊看——但遗憾的是，这一切都不能改变现实中存在万丈深渊的事实。</p>

<p>由苏联窜改的辩证唯物主义，不是别的，正是知识的双倍庸俗化。……辩证法的出发点是科学的——运用人文科学方面，主要在于根据一时的需要，将人文科学任意改造为它想建立的学说。——人类历史的数世纪，充满了成千上万的复杂事件，结果只用几个术语就高度概括了。<strong>毫无疑问，将过去和当代的历史作为阶级斗争的表现来进行分析，比将历史展示为那些王公贵族和国王彼此之间的私下争斗胡闹更接近真理。正是因为这种分析更接近真理，它也就更加危险：这种分析给人一种完满知识的错误，似乎能对每个问题作出回答，然而这种回答实际上只是在转着圈儿地重复几种套话，什么也解释不了，同时还让人得到表面的满足。</strong>对此还得附加一点，即借助唯物主义（例如”物质不灭“的理论）将自然科学与人文科学结合起来，而我们就会看到，当斯大林出现在我们这个星球自有生命以来的历史顶点之时，整个圆就奇妙而又合逻辑地画成了。</p></blockquote>

<p>如下这一段达到了反讽的巅峰，却又如此合情合理：</p>

<blockquote><p>有一种昆虫，会将自己的毒刺戳进其他科属的毛毛虫体内，并注入毒素，那些体内被注入了毒素的毛毛虫虽然还活着却已经瘫痪不能动了。这些昆虫——投毒者，就在那些毛毛虫体内产卵，于是毛毛虫的身体就变成了这些昆虫幼虫的食物储藏室。同样的，在人民民主国家，人们的头脑里也被注入了麻醉剂——那就是辩证唯物主义，虽说马克思和恩格斯从未设想过他们的学说会被如此利用。当人们的大脑被麻醉了以后，斯大林主义的解释就在他们的大脑中产卵：“既然你已经是个马克思主义者，”他们对这位患者说，“那你就必须是斯大林主义者；因为没有斯大林主义，就没有马克思主义。</p></blockquote>

<p>哈，没有斯大林主义，就没有马克思主义。这是辩证唯物主义存在的意义。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于《恰如其分的软件架构》]]></title>
    <link href="http://agiledon.github.com/blog/2013/08/29/about-just-enough-software-architecuture/"/>
    <updated>2013-08-29T10:39:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/08/29/about-just-enough-software-architecuture</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/justenough_cn.jpg">
华中科技大学出版社的徐定翔问我意见，了解我对Just Enough Software Architecture这本书的观感，看是否值得引进。时间是在2010年。从一开始，我就被书名中的Just Enough理念所吸引。它让我想起宋玉的东家姑娘，“增之一分则太长，减之一分则太短”那种不可言说的美丽。我在心里说，架构设计就需要这样。我当时并没有看到本书，只是到Amazon上找到了几篇英文原版样章。犹记得我在读到第一章介绍的RackSpace案例时那种兴奋之情。于是，我迫切地向徐定翔强烈推荐引进这本书，而我则毛遂自荐，希望能作为本书的译者。之后，我在InfoQ上看到对本书的《<a href="http://www.infoq.com/cn/articles/fairbanks-jesa">访谈和书摘</a>》，进一步加强了我翻译本书的信念。于是，出版社开始与作者Fairbanks联系，然而从此音讯如石沉大海。时针指向2011年，我对于本书是否被引进，是否由我翻译，一切未知。我觉得我可能错过了它，思之仍觉怅然。谁知到了九月，消息突然确定，而徐大编辑就不容分说地直接把原书给我寄来了。</p>

<p>拿到沉甸甸的书，第一面就为本书的装帧而惊喜。心里想，我这一辈子若能写出这样一本书，绝对值得生命走过的这一遭了。我并没有迫不及待地开始翻译，这就好似遇到珍馐美味，需得先赏其色，闻其香，然后再品其味。我每天抱着这本书饶有兴味地开始阅读之旅。阅读之旅确乎如行山阴道，沿途之美，目不暇接；可一想到翻译，这种美景就成了一种折磨，因为我害怕辜负这一美景。翻译之初我就举步维艰，那些词语放在那里，我却无法解开“封印”将它们取出来，即使取出来，却又找不到存放的合适位置。一些翻译隐隐约约浮现着，当我竭力去揭开这些词语的真面目时，无论如何用力，总也不能够着。翻译就好像那些年我们一起追过的女孩——追不到，痛苦；追到了，销魂。翻译进度像蜗牛一样的爬着，我终于决定求助了。辗转寻找了好多朋友，都以各种理由拒绝或者放弃了。翻译讲解软件架构的书，确乎不是一件轻松的事儿。那个时候，我的Buddy肖鹏正从翻译《面向模式的软件架构》第五卷的泥潭中爬了出来。每一提及他的这段翻译经历，脸上就会浮现出不堪回首的表情，如看了恐怖片。终于，事情得到转机，最开始是倪健的雪中送炭，再有高翌翔的锦上添花，随着我们这个三人组的建立，翻译才算开始走向正规，我才有了交稿的信心。</p>

<p>自从开始翻译这本书后，我与人谈架构，动辄就会提及“Just Enough，恰如其分”。我像祥林嫂一般地推介着Fairbanks提出的风险驱动模型，并认真地实践着这一模型。我开始对演进的架构有了更深入的理解。我写了《<a href="http://localhost:4000/blog/2011/10/10/design-just-enough-architecture/">设计恰如其分的架构</a>》这篇博客来详细阐述我对演进式架构的理解。在2011年我参加的技术会议上，我也反复讲解了如何遵循简单之美的原则，运用风险驱动模型设计恰如其分的架构。2012年，在我参加的一个项目中需要针对遗留系统进行技术栈迁移。我撰写了文章《<a href="http://www.infoq.com/cn/articles/legacy-system-migration">遗留系统的技术栈迁移</a>》，提到了“风险驱动模型”，并在2013年的Scrum Gathering会议上分享了我的一些想法。当然，这个模型并不是锤子，更不是银弹。它更近似于质量属性驱动的架构设计，我们要满足的质量属性，可能就是我们在做架构时需要面对的风险；而在Roy Fielding的那篇关于REST的著名论文中，也提到了对约束的识别，并演示了如何从一个空约束，通过逐步添加约束演化为REST风格的架构。从某种程度上，架构的约束可能是一种风险，也可能成为设计的驱动力。</p>

<p>前几天，我参加Agile China 2013，与我新认识的一位朋友范钢聊到了关于架构重构的问题。事实上，面向对象软件开发到现在，已有十余年之久；各种经验、模式与原则甚嚣尘上并得到较好的推广。然而新的方法、新的语言乃至新的思想仍然层出不穷，尤其是在互联网开发、大数据处理以及移动开发的冲击下，传统软件开发似乎已经开始走向末路。“只见新人笑，不见旧人哭”！？？是，也不是。实际上，在传统的企业开发领域，各种大型系统仍然像一艘庞大如巨型海兽一般的船舰在海面缓缓行驶，它或许就是沉没之前的泰坦尼克，一切还都安然无恙，你甚至可以听到船头甲板传来的悠扬的小提琴声；然而，冰川就在远处出没，船长还未察觉。我们该怎么办？这样的巨型船舰，自然不可能如艨艟快艇那般的敏捷，即使是360度的转身，也可以玩得如此漂亮、优雅。这些大型的企业级软件系统已经走过了漫长的历程，它们如此巨大以至于我们只能看到它的一角，它们的零部件如此复杂以至于没有人能够彻底弄懂。我们必须认识到，这些系统是最有权力的系统，它们很有可能掌握了人类生活的根本命脉——金融管理、股市交易、生命健康、医疗管理、机械制造、国防安全、航空、航天……它们就像政治界、金融界的那些巨头，要是患了病咳嗽两声，也许世界都要抖一抖。它们可以轻易改变吗？不能！然而若是不寻求改变，这些系统会宿命地走向衰亡。若我们无法承受重写的成本，唯一的办法或许就是架构的重构。我们必须清晰地认识到这一点。而我认为，风险驱动模型恰恰可以作为架构重构的指导原则。在进行重构之前，我们需要充分评估重构的价值，回答“为什么我们需要重构”的问题；然后去识别风险。在开始重构之前，我们需要尽可能做到万无一失。风险自然是不可避免的，但如果我们能事先识别出这些风险，就能有的放矢地选择正确的技术。风险驱动模型的第三步，则是评估风险是否得到有效缓解。不要轻视这一步！重构往往意味着还债。可是，我们该用什么来说服管理者们付出成本去做一些看似没有产生直接利益的任务呢？答案就是用数据来说话，通过比较重构前后的系统健康指标，可以加重说服老板的砝码。当然，毫无疑问，这个过程一定是迭代的。</p>

<p>我想，通过这次交谈，我进一步找到了“风险驱动模型”适用的场景。而这正是我翻译并推荐本书的根本意义。本书可以在<a href="http://product.dangdang.com/product.aspx?product_id=23320387">当当网</a>购买。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ThoughtWorks(中国)程序员读书雷达]]></title>
    <link href="http://agiledon.github.com/blog/2013/04/17/thoughtworks-developer-reading-radar/"/>
    <updated>2013-04-17T21:46:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/04/17/thoughtworks-developer-reading-radar</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/04/reading-radar.jpg">
软件业的特点是变化。若要提高软件开发的技能，就必须跟上技术发展的步伐。埋首醉心于项目开发与实战，固然能够锤炼自己的开发技巧，却难免受限于经验与学识。世界上并不存在速成的终南捷径，但阅读好的技术书籍，尤其是阅读大师们的经典著作，总能收到事半功倍之效。一位优秀的程序员，或许就是一名好的阅读者。好的阅读者，总是知道如何选择好的书籍。书海浩繁，良莠不齐。阅读技术好书，如与智者交谈，“与君一席话胜读十年书”；遭遇技术烂书，如被拐卖，“少小离家老大回，乡音无改鬓毛衰”。</p>

<p>ThoughtWorks作为一家学习型组织，颇为看重每一位员工的学习能力。事实上，大多数ThoughtWorker的骨子里，都溢满了读书的基因。与书相伴，与书为伍，既是一种乐趣，又是一种习惯。当习惯成为自然时，书籍就成为生活和工作不可或缺的一部分了。如果说人文历史哲学等书籍是一碗心灵鸡汤，技术书籍大抵算得上是一味营养素，读之可以直接带来养分；可若是不了解自己究竟缺了哪一种营养，乱吃乱补，结果就可能适得其反了。有鉴于此，我和同事刘龙军结合自身的阅读经验，为新入职ThoughtWorks的程序员制作了一份读书路线图。我们将范围明确为程序员，是因为作为程序员的我们，它是我们最了解的工作角色。我们筛选出了一些大家公认的经典书籍，再结合自己的阅读体会，并广泛征集了更多ThoughtWorker的意见，包括徐昊，熊节，郑晔等资深阅读者，得到了这样一份草稿。在中国公司内部推出时，这份读书路线图得到了多数人的认可和欢迎。继而，我们在成都办公室陆续针对此读书路线图展开了读书俱乐部的活动，算是做了一次全方位大面积的试水。</p>

<!--more-->


<p>现在，我们觉得是推出正式版本，并面向更多受众的时机了。这就是大家现在看到的ThoughtWorks(中国)程序员读书雷达。它相较于之前的读书路线图草稿，分类更为专业，书籍筛选更为合理，并以雷达独有的优势，来展现不同的阅读维度与阅读深度。显然，读书雷达更能表达我们对所选书籍的深度认识。它可以作为学习型组织的一份知识输入，每一位程序员都可以根据自身水平与能力，选择适合自己的书籍，甚至组成一份表达阅读履历的读书路线图，在获得知识完善与汲取的过程中，提高自身能力，达至各个维度的巅峰。</p>

<p>该读书雷达将书籍分为了如下四个象限：
<blockquote><p>Coding Practice（编程实践）<br/>Architecture &amp; Design（架构与设计）<br/>Methodology（方法学）<br/>Thought &amp; Leadership（思想与领导力）</p></blockquote></p>

<p>我们之所以将方法学、思想与领导力放入到这个为程序员设计的读书雷达中，乃是因为软件开发不仅仅是个人的活动，也不仅仅是编码技巧和设计能力的体现。我们认为，开发技能其实是一项综合的系统工程。了解方法学，可以促进你对开发过程的理解；关于思想，则涉及大脑思维的修炼，可以提高程序员的抽象能力、学习能力，有助于帮助程序员发现事物发展的规律和本质；至于领导力，则有助于程序员在开发团队中发挥更大的作用，并能作为很好的团队成员，提升团队的整体能力。我们没有在这个读书雷达中包括语言类的书籍，原因在于这类书籍太过于发散，且更新较快；我们也不可能奢望在一张读书雷达图中，为不同的语言平台展现不同的优秀书籍。相比较语言的学习，我们更看重程序员在编程实践上的基本功。</p>

<p>每个象限皆分为三个等级，分别为Fundamental、Medium和Advanced，对应初学、进阶和高级。在雷达图中，读者可以根据该书在图中距离圆心的远近，判断它的难度级别。我们还使用了不同的图示来表达对每本书的倾向性意见，其中，橙色的三角形图示代表“强烈推荐”，蓝色的圆形图示代表“推荐”。我们希望这类书籍对于程序员而言，可以根据自己目前的水平，选择适合自己的书籍。在这个层次上，强烈推荐可能就意味着必读。</p>

<p>或许有人会质疑读书雷达的挑选标准。正所谓“每个人心中都有自己的哈姆雷特”，我们认同的未必能得到读者的认同，这是我们这个世界关于一种观点或态度的常态。我们发布这个读书雷达，只是希望能提供更多有用的信息与参考，而非代表一种读书权利的绝对化。事实上，我们也不可能做到。此外，"吾生也有涯，而知也无涯"，我们阅读的书籍毕竟有限，且读书雷达的容量也有限，难免会有遗珠之叹，这也是一件无可奈何之事。然而，我们欢迎更多的批评与建议，或许你推荐的好书恰恰是我们遗忘的，又或者激起了我们的共识，那么我们也会毫不吝啬地更新读书雷达，以求做到我们能力范围内的尽善尽美。当然，正如你看到的，我们在Methodology（方法学）象限，更多地推荐了与敏捷和精益相关的书籍。这是因为我们对敏捷技能与方法更有心得和信心。对于我和刘龙军还不够擅长的领域，我们不敢也不愿做出可能误导人的推荐。</p>

<p>本读书雷达虽然冠以ThoughtWorks（中国）之名，但选书的倾向与意见并非ThoughtWorks（中国）官方的态度，而是作为制作者（龙军和我）个人表达的意见而已。如果你也加入了ThoughtWorks，你一定会发现这种自发组织的民间活动，在ThoughtWorks可谓俯拾皆是，不用诧异。</p>

<p>我将在后面的文章中，根据每个象限为每一本书给出我们的推荐理由。此时，书籍成为了我们的臣民，我想对这个王国做一次不吝惜赞赏的巡视。最后，列出读书雷达的中英文书单，如下所示(感谢凯峰为这个雷达图建立的豆列，可以访问<a href="http://book.douban.com/doulist/2012097/">ThoughtWorks(中国)程序员读书雷达</a>)：</p>

<h3>Coding Practice | 编程实践</h3>

<h4>基础篇</h4>

<p><blockquote><p>Clean Code《代码整洁之道》<br/>Pragmatic Unit Testing《单元测试之道》<br/>The Productive Programmer《卓有成效的程序员》<br/>Test-Driven Development By Example《测试驱动开发》<br/>Clean Coder《程序员的职业修养》<br/>The Art of Readable Code《编写可读代码的艺术》</p></blockquote></p>

<h4>进阶篇</h4>

<p><blockquote><p>Refactoring To Patterns《重构与模式》<br/>Implementation Patterns《实现模式》<br/>Code Complete《代码大全》<br/>The Pragmatic Programmer《程序员修炼之道》</p></blockquote></p>

<h4>高级篇</h4>

<p><blockquote><p>Structure and Interpretation of Computer Programs《计算机程序的构造和解释》<br/>Working Effectively with Legacy Code《修改代码的艺术》</p></blockquote></p>

<h3>Architecture &amp; Design | 架构与设计</h3>

<h4>基础篇</h4>

<p><blockquote><p>Agile Software Development 《敏捷软件开发：原则、实践与模式》<br/>Head First Design Patterns《深入浅出设计模式》<br/>Design Patterns 《设计模式》</p></blockquote></p>

<h4>进阶篇</h4>

<p><blockquote><p>The Art of UNIX Programming 《Unix编程艺术》<br/>Practical API Design  《框架设计的艺术》<br/>Domain Specific Languages 《领域特定语言》<br/>Patterns of Enterprise Application Architecture 《企业应用架构模式》</p></blockquote></p>

<h4>高级篇</h4>

<p><blockquote><p>Release It<br/>Domain-Driven Design 《领域驱动设计》<br/>Enterprise Integration Patterns《企业集成模式》<br/>Beautiful Architecture《架构之美》<br/>Pattern-Oriented Software Architecture《面向模式的软件架构》</p></blockquote></p>

<h3>Methodology | 方法学</h3>

<h4>基础篇</h4>

<p><blockquote><p>User Stories Applied《用户故事与敏捷方法》<br/>The Gold Mine《金矿》<br/>Scrum and XP From the Trenches《硝烟中的Scrum和XP》<br/>Continuous Integration《持续集成》<br/>Extreme Programming Explained《解析极限编程》</p></blockquote></p>

<h4>进阶篇</h4>

<p><blockquote><p>Lean Thinking《精益思想》<br/>Continuous Delivery《持续交付》<br/>How Google Tests Software<br/>Agile Testing<br/>Extreme Programming Refactored《重构极限编程》</p></blockquote></p>

<h4>高级篇</h4>

<p><blockquote><p>Specification By Example</p></blockquote></p>

<h3>Thought &amp; Leadership | 思想与领导力</h3>

<h4>基础篇</h4>

<p><blockquote><p>The Effective Executive《卓有成效的管理者》<br/>Are Your Lights On?《你的灯亮着吗》<br/>Becoming A Technical Leader《成为技术领导者》</p></blockquote></p>

<h4>进阶篇</h4>

<p><blockquote><p>The Fifth Discipline《第五项修炼》<br/>The Design Of Business<br/>Management 3.0《管理3.0：培养和提升敏捷领导力》<br/>Presentation To Win<br/>The McKinsey Way《麦肯锡方法》</p></blockquote></p>

<h4>高级篇</h4>

<p><blockquote><p>Thinking, Fast and Slow《思考快与慢》</p></blockquote></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[苍老与隐居以及战斗]]></title>
    <link href="http://agiledon.github.com/blog/2013/03/16/old-and-reclusion-and-fight/"/>
    <updated>2013-03-16T21:47:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/03/16/old-and-reclusion-and-fight</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/03/old.jpeg">
杜拉斯在《情人》里劈头就是这么一段话：“我已经老了，有一天，在一处公共场所的大厅里，有一个男人向我走来。他主动介绍自己，他对我说：‘我认识你，永远记得你。那时候，你还很年轻，人人都说你美，现在，我是特为来告诉你，对我来说，我觉得现在你比年轻的时候更美，那时你是年轻女人，与你那时的面貌相比，我更爱你现在备受摧残的面容。’”</p>

<p>人的沧桑如年代悠远的古董一般让人怀念，如侵蚀后的青铜器斑驳的美。每位老人都是讲不完的长篇故事，刻在皱纹里的是曾经拥有的回忆。似乎什么都经历过，似乎什么都未曾经历得完全，孤独与衰老慢慢侵袭而来，正如皱纹慢慢爬上额头。时光开始变得急促，可惜步子越发的蹒跚，再也无法追赶光阴的影子了。这或许是一种无奈；然而，真正的苍老总是懂得生命的哲理，毋须哀叹这不可追回的韶光。沧桑的历练足以让老人在回忆中度过另一个鲜活的生命。这是一种睿智。这种睿智仿佛一把金刚刀，岁月之美如钻石一般被切割出来，拥有那玲珑剔透的切面，折射出璀璨的辉光。</p>

<p><blockquote><p>然而，面对苍老，我总不免低低咏叹：<br/>你饱经沧桑的双眼，<br/>为何总饱含着忧伤的泪水？</p></blockquote></p>

<p>想到人的日渐衰老，我总是无法抑制地哀伤。“夕阳无限好，只是近黄昏”，李商隐的一句诗，道尽了这其中的无奈，甚至是凄楚。或许，自私的人们总是可以欣赏别人备受摧残的面容，却无法容忍自己的老去，最后走向阴冷的坟墓。对苍老的诵咏，就变成一曲对凄美的哀歌了。</p>

<p>“不要老去！”我在心里呐喊。可是，我终究是要老去的。</p>

<p>其实，我已经老了。我变得渴望隐居的生活。我变得害怕喧嚣，甚至不愿有太多感情的牵绊。这是否是衰老的征兆？</p>

<p>我的厌世之情，或许源于我执著于醉意孤独？我的思想没有任何人能够理解，因为，连我自己都不理解我自己。或许，无所不知的全能的神是一个例外，可是，作为高高在上的神灵，哪里会关注我这样一个卑微如蝼蚁一般的生命呢？更何况在这世上，神灵究竟存在与否，我仍然保持着足够谨慎的怀疑。</p>

<p>这是否是我渴望隐居的原因之一呢？</p>

<p>我从来不明白玄学的意义，但我却开始变得眷恋虚空的思索，就像卢梭一个孤独漫步者的遐想那般，思索道德与人生，抑或是自主意识地从内心识别自己，而无需那些澹妄的敌人为自己做出盖棺论定。在这个世界，我们面对的每一个人都是敌人，他们试图戴上伪装的面具，靠近我，或者疏远我。我希望逃离，无奈人生的樊笼早已锁住了我，我无法逃离，甚至我不能逃离。</p>

<p>这就是我渴望隐居的原因之一吧！</p>

<p>约翰·汤姆逊造访晚清时的中国，在广东乡村的游历中，访谒清远县的飞来寺，留下了两位僧人的存影。汤姆逊说：“和尚们隐居那里，远离尘世，他们认为什么时候能从宇宙万物中认识了抽象的自我，什么时候就会忘记存在，忘记喜怒哀乐，从而达到绝对的清静，进而修成正果——涅槃。”</p>

<p>若真能够隐居的我，断然做不到这样枯守住内心的寂寞与安宁。我骨子里希望自己能是一个脱俗的人，然而，我的灵魂却总是甘于在尘世中堕落。灵与肉的分离，使我彻底沦为矛盾的共同体，我始终陷入挣扎中。愈是挣扎，绳索捆缚得愈紧，这令我感到悲哀，进而是苦闷。</p>

<p>厨川白村在其著述《苦闷的象征》中写道：“……无非说是‘活着’这事，就是反复着这战斗的苦难。我们的生活愈不肤浅，愈深，便比照着这深，生命力愈盛，便比照着盛，这苦恼也不得不愈加其烈。在伏在心的深处的内底生活，即无意识心理的底里，是蓄积着极痛烈而且深刻的许多伤害的。一面经验着这样的苦闷，一面参与着悲惨的战斗，向人生的道路进行的时候，我们就或呻，或叫，或怨嗟，或号泣，而同时也常有自己陶醉在奏凯的欢乐和赞美的事。这发出来的声音，就是文艺。对于人生，有着极强的爱慕和执着，至于虽然负了重伤，流着血，苦闷着，悲哀着，然而放不下，忘不掉的时候，在这时候，人类发出来的诅咒，愤激，赞叹，企慕，欢呼的声音，不就是文艺么？在这样的意义上，文艺就是朝着真善美的理想，追赶向上的一路的生命的进行曲，也是进军的喇叭。响亮的闳远的那声音，有着贯天地动百世的伟力的所以就在此。”</p>

<p>若能在苦闷中不停地战斗，即使暴风骤雨满路荆棘，鲜血淋漓狼狈不堪，总还能印证自己的存在。战斗是一种精神，一种态度。它或许仅仅是一种象征意义，然而我们在战斗中会变得饱满而鲜活——暮然回首，我们发现，生活多么的畅快淋漓！此时，苍老其实是一种壮美；毋宁说，隐居也变成了一种战斗！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阅读的设计体悟]]></title>
    <link href="http://agiledon.github.com/blog/2013/03/02/harvest-from-reading/"/>
    <updated>2013-03-02T21:46:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/03/02/harvest-from-reading</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/03/jsbookcover.jpg">
不管语言的变化有多大，关于程序设计的基本编程思想和设计本质，应是殊途同归。两年前阅读了Jonathan Snook的著作《Javascript捷径教程Accelerated DOM Scripting with Ajax, APIs, and Libraries》。在书中，他带领读者构建了一个简单的动画对象。简单的例子，轻描淡写的描述，却似乎展现了朴素的基本设计思想。</p>

<!--more-->


<p>下面记录了一些阅读感悟。例如，书中这样写道：
<blockquote><p>页面里要用到的动画对象一般都不止一个，所以应该把它定义成一个类。定义一个有5个参数的函数：要加上动画的元素、要改变的属性、属性的起始值、属性的结束值、动画的持续时间。<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">duration</span><span class="p">){}</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></p><p><p>不管编写什么代码，都应该先把实现想透彻。每个决定都有正反两方面的后果，你应该想清楚每个决定的原因。</p></blockquote></p>

<p>这代表一个朴素的思想，那就是从实现原理来进行设计决定。注意这里的实现原理，并不是要关注实现的细节，而是要考虑影响实现的因素，并从调用者的角度思考接口或函数的输入与输出值。以本例而言，如果事先不明确动画效果的营造方式，是根据时间的变化动态变更element属性的方式来完成，就无法确定Animation函数。设计不是空中楼阁，抽象固然是重要的，但功能实现的基本原理仍然需要事先思考通透，否则，设计就可能走弯路。拿到一个功能，先要弄清楚它的目标是什么，有没有质量属性的要求，未来的变化如何，还有这一功能的实现原理。例如，我们要提供服务定制的功能，就需要实现明确“服务”的定义，如何完成服务的注册，服务的发布，服务的订阅，谁会订阅这些服务，服务的安全如何保障，如何解决服务与实现的脱耦。只有把这些问题想清楚了，设计才会靠谱。
<blockquote><p>看看前面的代码，元素ID是作为一个字符串传递进来的，那么在动画对象中获取该元素就有两种方法：一是通过DOM方法document.getElementById()；二是采用Javascript库的调用，如${}。……既然我们想让这个动画对象能适合各种情况，那还是用DOM方法比较好，保证它不依赖于任何库。<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span><br/></span><span class='line'><span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">ducument</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span><br/></span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">el</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></blockquote></p>

<p>这段话仍然体现了一种设计决策。它的实现目标是不与任何JS库耦合。这就需要保证实现的通用性。
<blockquote><p>要是你打算执行动画的元素没有ID怎么办呢？为了让这个类更灵活，让我们把它改成既可以传入元素引用，又可以传入ID字符串。如果传入的是ID字符串而不是对象引用，程序就会通过DOM方法去获取元素。两全其美！<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span><br/></span><span class='line'><span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span><br/></span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">el</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span><br/></span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">el</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></blockquote></p>

<p>这又是一种编码修炼了。除了要在设计上保证灵活性之外，我们在编码时也需养成保证代码完整性与健壮性的习惯，并体贴地为调用者着想。有这么一条设计原理，就是伯斯塔尔法则(Postel's Law)：“发送时要保守；接收时要开放。”这里的实现无疑遵循了这样一个法则。我们在编码时，考虑到这些因素了吗？</p>

<p>Ok，继续我们的阅读。
<blockquote><p>实例化一个对象要用到5个参数，但一眼看上去很难看出参数里的那些数字都代表什么含义。……为此你可以把参数改成字面量对象，键的名称看起来更直观一些。而且如此改动能使API更加灵活，因为即使今后增加了更多的参数，实例化对象的代码也不会变得更复杂。<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span><br/></span><span class='line'><span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">options</span><span class="p">.</span><span class="nx">element</span><span class="p">;</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}</span><br/></span><span class='line'><span class="kd">var</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="nx">element</span><span class="o">:</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;elementId&#39;</span><span class="p">),</span><br/></span><span class='line'><span class="nx">property</span><span class="o">:</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span><br/></span><span class='line'><span class="nx">from</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span><br/></span><span class='line'><span class="nx">to</span><span class="o">:</span><span class="mi">200</span><span class="p">,</span><br/></span><span class='line'><span class="nx">duration</span><span class="o">:</span><span class="mi">1000</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">};</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></blockquote></p>

<p>无疑，这体现了面向对象的“封装”思想。通过封装既保证了代码的清洁与可读性，同时还有利于未来的扩展。这与OCP（开放-封闭原则）是一脉相承的。代码是有结构的，或者体现为函数，或者体现为对象，事实上都是一种按照属性与职责进行的分类。分类是保持清洁、避免重复的唯一法门。从简朴的角度来说，所有的设计其实都是在做着分类的游戏。分类体现了定义的抽象，职责的分配，结构的划分；如果再加上类别之间的协作，就是设计的全部了。</p>
]]></content>
  </entry>
  
</feed>
