<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Design | 晴窗笔记]]></title>
  <link href="http://agiledon.github.com/blog/tags/design/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2013-02-06T12:16:29+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[对象的角色]]></title>
    <link href="http://agiledon.github.com/blog/2013/02/05/role-of-object/"/>
    <updated>2013-02-05T21:55:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/02/05/role-of-object</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/02/roleofobject.png"></p>

<p>若要获得良好的对象设计，就必须对职责进行合理的分配。每个对象承担的职责不能太多，也不能太少，恰如其分即可。职责分配如乐谱中对音符的组织，高明的音乐家总是能让不同的音符放在合理的位置，奏成悦耳的心曲，表达音乐家的内心感情。然而，即使设计师明确职责分配的重要性，在面临纷乱复杂的需求时，常常被乱花迷了眼，或者无法识别正确的职责，又或者顾此失彼，将职责放错了位置，变成了对职责混乱的涂鸦。</p>

<p>要识别职责，进而合理分配职责，有许多秘诀，或云“技巧”。不过，将对象的角色作为职责分配的开始，不失为一个好的起点。角色是对象的身份，若以拟人化的方式思考对象世界，就可以设想：究竟是怎样的身份，需得承担怎样的职责，才会与其身份相当，不至于乱了规矩。红楼梦中，刘姥姥进了大观园，出尽了洋相，就是因为身份失当；又可以想想倘若林黛玉像尤三姐那般爱恨分明，也不至于见花落泪，惹人爱怜了。故而在分配职责时，我们能首先明确对象的角色，即可将思想带入到这一角色中，设身处地，推断这一角色可以或者必须承担哪些职责。</p>

<p>在<a href="http://product.china-pub.com/30653">Object Design:Roles, Responsibility, and Collaborations</a>一书中，将对象的角色分为了五种，分别为信息持有者、构造者、服务提供者、协调者和控制者。这种分类差不多涵盖了对象在软件系统中扮演的角色。以此为基础，在进行软件设计时，可以思考你要设计的对象，究竟属于哪一种角色。</p>

<!--more-->


<h4>信息持有者角色</h4>

<p>首先来看信息持有者。顾名思义，这种角色的对象必然持有相关的信息。不过，俯瞰对象世界，除了某些特殊的行为对象而言，大多数对象都必然持有相关的信息。所以，这里的角色划定，其主要意图在于让设计者明确，与信息相关的行为，如处理信息的方式，信息变化造成的影响等，都应首先考虑是否由该信息的持有者来承担。这近似于Larman在<a href="http://book.360buy.com/10057823.html">Applying UML and Patterns</a>一书中提到的“信息专家模式”。</p>

<p>例如，我们需要设计一个Web服务器，它提供了一个对象HttpProcessor，能够接收由HttpConnector发送来的Socket请求，对Request进行处理，并在处理后将相关信息放入Response中。请求和响应被封装在对应的HttpRequest和HttpResponse对象中。在处理请求和响应信息时，需要对Socket消息进行处理，并为Request和Response对象设置相关属性。我们当然可以在HttpProcessor中处理对这些消息的解析工作，但涉及到Request和Response自身的信息，遵循信息持有者角色的要求，最好还是将这些处理逻辑封装到各自对象中。如下图所示：
<img class="center" src="/images/2013/02/infoholder.png"></p>

<p>遵循信息持有者的特征，HttpProcessor、HttpRequest与HttpResponse之间的权责变得更加清晰。此外，这一设计方式还有利于改善性能。某些Http请求解析可能牵涉到系统开销较大的字符串操作，而解析的内容并不是在一开始就需要使用。将解析职责转移到HttpRequest中，就使得HttpProcessor的process()操作可以快速完成，并将相关请求数据流塞到HttpRequest对象中。只有真正需要相关请求信息时，才向HttpRequest对象发出解析的请求消息。这种方式颇像是对象的Lazy Load。</p>

<h4>构造者角色</h4>

<p>构造者角色主要承担对象的创建，以及对复合对象的组装。如果熟悉设计模式，可以发现构造者角色基本上囊括了构造型模式的意图。例如创建对象，组合对象，以及选择对象构造的方式。此外，还有一种特殊的构造者角色对象，即它可能具有双重角色，一方面作为构造者角色，另一方面也作为构造者所创建出来的产品。这种双重角色的构造者角色，常常会形成一条构造链。例如，在JMS中，若要获得Queue对象，就可能由ConnectionFactory对象创建出Connection对象，则通过该对象创建Session对象，最后由Session对象创建的Queue。如下图所示：
<img class="center" src="/images/2013/02/constructor.png"></p>

<p>为何我们需要构造者角色？毕竟对象自身可以拥有构造函数，以提供给调用者完成对象的创建。通常情况下，之所以引入构造者角色，主要是为了：</p>

<p>（1）为了应对创建的变化；</p>

<p>（2）为了隐藏对象创建的复杂逻辑；</p>

<p>（3）为了控制对象创建的时机或数量。</p>

<h4>服务提供者角色</h4>

<p>关于服务提供者，一个重要认识是：它能提供具有“业务价值”的行为。所谓“业务价值”，即一定是实现业务逻辑中不可缺少的，且相对独立完整的功能。这就意味着，担任服务提供者角色的对象，常常是一个职责完备地，实现了某个业务关注点的可重用对象。此外，业务价值是有层次之分的。在最外层，可能意味着一个完整的业务流程，此时服务对象暴露给客户端的，是一个封装了服务实现细节的对象（可能是接口）；而为了实现该外层服务，又可能在整个实现中，需要更为细粒度的内层服务对象提供各个实现步骤的支撑。例如系统需要生成税务报表，假设它的业务流程是读取报表数据后，对数据流进行处理，并以HTML格式呈现，然后生成PDF文件。对外而言，税务报表的生成就应该是一个完整的服务，且对于客户端的调用者而言，其实根本不需要了解其实现细节。此时，我们可以定义一个TaxReportGenerator对象，它能够接收报表数据，并生成报表的PDF文件。显然，它具有非常重要的业务价值。</p>

<p>接下来考虑该对象的内部实现。由于报表生成需要执行多个业务步骤，如果将这些职责均交给TaxReportGenerator来处理，无疑会导致该对象承担过重的职责。此外，呈现HTML格式与PDF文件生成对于报表生成而言，不过是整个业务流程中的一环；但从单个职责而言，无疑它们也是独立的。可以设想，倘若系统还有其他业务功能需要生成PDF文件，又或者需要按照规定形式呈现为HTML页面，将这些职责封装到单独的职责中，就可能很好地支持重用。从“业务价值”的角度看，它们无疑具备了服务提供者的能力。整个TaxReportGenerator对象的内部协作如下图所示：
<img class="center" src="/images/2013/02/serviceprovider.png"></p>

<h4>协调者角色</h4>

<p>协调者有些像设计模式的Mediator模式所要承担的职责，即用于协调对象职责的协作，又或者负责转发或委派请求。协调者是孜孜不倦助人为乐的居委会大妈，既善于也乐于协调邻里之间的纠纷。除了可以以中间人的身份协调对象，从而简化对象之间的协作，以降低复杂的依赖关系外，协调者还能很好地隐藏这些交互细节。这就使得调用者变得简单，还能让这种关系协调的实现集中在一处，即使将来协调关系发生了变化，也可以做到仅修改一处，即可应对变化。从这一点来看，似乎协调者又体现了Facade模式。</p>

<p>在一个大型复杂系统中，提供了许多Web Service。不同的Web Service可能需要支持不同的消费者，而这些服务的部署位置也可能并不相同。消费者需要准确定位到相关服务，然后通过一些相对复杂的实现逻辑，完成对服务的调用。这类逻辑就牵涉到消费者、服务以及服务调用与服务位置之间的协作。如果没有合适的对象去封装，既可能导致细节暴露，增加复杂度，也无法做到有效重用。一旦协作的逻辑发生变化，可能还会导致这种变化蔓延到系统的各个地方。这时，就是体现协调者角色价值所在了。在这个场景下，我们可以引入ServiceLocator对象来负责整个协调逻辑，它能够根据消费者请求的服务类型，定位服务，然后找到服务端口，发送服务请求。下图展示了这种协调逻辑的具体做法，注意不同的服务消费者都经由相同的ServiceLocator角色完成了不同的服务调用：
<img class="center" src="/images/2013/02/colaborator.png"></p>

<h4>控制者角色</h4>

<p>看到控制者，或许我们会想到MVC模式的Controller。确乎它们具有相似的特性，即用于控制多个对象之间的交互，甚至是驱动对象。或者，我们可以将这里所谓的控制者角色，看做是Controller的外延，即它具有更加宽泛的职责意义。凡是需要控制角色交互，并具有一定控制逻辑的对象，均可看做为控制者角色。注意，控制者角色与协调者角色的区别，最为明显的区别在于前者多少具有一定的管理特征，被控制的对象似乎在级别上低于控制者角色；而后者则体现一种平等的层级关系。前者是政府官员，后者是居委会大妈。</p>

<p>当然，在设计时，有时似乎也很难泾渭分明地界定这二者。这就好似用例中的使用与扩展关系，许多设计者还在孜孜以求，绞尽脑汁地要分辨出二者的不同，以保证正确地运用用例关系，求得完美的设计，孰知早有用例专家给出忠言，不必一定区分使用与扩展，它对用例的编写不会产生直接的重大影响。参考此例，我也希望设计师不必去钻牛角尖，只需明白此两种角色，其本质还在于隐藏对象的协作或交互细节，降低复杂度，保证重用以及对变化的应对。</p>

<p>在软件设计中，我们经常遇到控制者角色。一个常见的例子是由控制者角色承担判断逻辑，根据不同的请求，经由不同的分支，调用不同的对象来应对此请求。例如在一个系统中，我们需要对页面的内容合法性进行验证。不同的内容对验证的要求不尽相同。一个简单的判断是看内容是否只需要对页面头进行验证。我们在设计时，引入了ValidationProcessor来控制这种验证逻辑。站在调用者的角度，验证的事情交给ValidationProcessor去处理就好。管它是否仅是一个控制枢纽，真正的验证却是它要委派的对象呢？
<img class="center" src="/images/2013/02/controller.png"></p>

<p>当然，在这里的ContentController同样属于控制者角色，它事实上就是MVC模式中的Controller，用于控制Content与ContentView之间的交互。ValidatorProcessor与MVC风马牛不相及，但它仍可以看做是控制者角色。</p>

<p>如果我们能识辨出系统模型中各种对象的角色，就可以根据角色的特征来分配角色。又或者，我们可以根据角色来判别现有的职责分配是否合理，是否均衡，甚至能够帮助我们找到缺失的对象。除了信息持有者角色，其余四种角色通常不会出现在领域模型中，它们事实上都属于设计对象。但它们在软件设计中的地位却举足轻重，没有它们，设计就可能走向混乱，无法保证重用性与扩展性，并导致系统对象之间的协作变得复杂。每当我们在分配职责时，若有顾此失彼的感觉存在，就可能说明缺乏了承担不同角色作用的这一类设计对象。找到它，并给它以承担职责的权利，设计一定会大为改观。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文学与软件]]></title>
    <link href="http://agiledon.github.com/blog/2012/12/21/literature-and-software/"/>
    <updated>2012-12-21T18:59:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2012/12/21/literature-and-software</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/2012/12/dafenqi.jpg" width="182" height="276"></p>

<p> 卡尔维诺在哈佛大学的文学讲座（即诺顿论坛，是为纪念美国著名学者诺顿开设的，每年邀请世界文化名人作讲座，艾略特、博尔赫斯也曾获邀参加诺顿讲座）被他的妻子编成了一本独立的书《美国讲稿》。这本书展现了卡尔维诺的文学精神，体现了他的文学态度和气质。不过，我在阅读该书时，却发现了一些与编程有关的内容。</p>

<p>1、文学中的重构</p>

<p> 达芬奇在《大西洋草图》中记述了他幻想中海怪的形象，进行了前后三次重构。最初的描述是：</p>

<p><strong>啊，人们多次在波浪翻滚的广阔海洋之中看到你，看到你那长满鬃毛的黑色背脊，你像一座大山，傲慢地徐徐前进！</strong></p>

<!--more-->


<p>然后，他试图使海怪的行动生动些，加了个动词“翻转”：</p>

<p><strong>啊，人们多次在波浪翻滚的广阔海洋之中看到你，看到你在海水中傲慢地徐徐翻转身躯，看见你那长满鬃毛的黑色背脊。你像一座大山屹立在海浪之上！</strong></p>

<p>然而，他觉得“翻转”这个词削弱了他想留给人们的那种雄伟与庄严的印象，于是选择了“分开”这个动词，并改变了句子结构，使句子变得更紧凑，更有节奏。</p>

<p><strong>啊，人们多次在波浪翻滚的广阔海洋中看到你！你像一座山屹立在海浪之上。你傲慢地徐徐前进，用那长满鬃毛的黑色背脊把海水分成两半!</strong></p>

<p>在文学创作中，重构其实会经常发生，这源于作家对文学作品高质量追求的精益求精，他们常常通过修改句式，修辞手法或改变词语来改善文字，使之体现恰如其分的美。编码艺术同样如此，即使是代码的结构，以及变量、方法和类的命名，排版样式，只要给予足够的重视，锤炼这方面的技能，坚持重构，就能改善编码质量。</p>

<p>2、封装与接口</p>

<p>卡尔维诺在“精确”一章中引述了哲学家们对语言和外部世界关系的思考：</p>

<p><strong>使用语言是对事物的不断追求，不是渐渐接近事物的本质而是接近事物那无休止的变化，接近事物那多种多样的、无穷无尽的表面。正如霍夫曼斯塔尔所说：“深层应该掩盖起来。掩盖在哪里？掩盖在表层下面。” 维特根斯坦走得更远，他说：“凡被掩盖的东西，我们都没有兴趣。”</strong></p>

<p>在软件开发中，我们常常运用封装来隐藏内部的实现细节。它带来的好处是使得调用变得简单，重用成为可能，很好地隔离了内部实现的变化。当然，文学更善于挖掘内部的玄奥，却常常使用抽象的语言描述出一种晦涩，试图掩盖这种玄奥，以此追求一种寻找“高山流水”知音般心灵激荡的玄妙与浃肌沦髓。</p>

<p>文学也尝试用变化去处理变化，这似乎矛盾，却恰好是文学艺术让人着迷的地方。软件又何尝不是如此。卡尔维诺看到了两种变与不变的模式：</p>

<p>最近我偶然读到生物形成过程的模式：“一边是晶体（象征表面结构稳定而规则），一边是火焰（虽然它的内部在不停地激荡，但外部形式不变）。”……火焰与晶体这两种形象代表了生物学上的两种选择。</p>

<p>皮亚杰观点的哲学蕴含是“从噪音到有序”，即火焰；乔姆斯基观点的哲学蕴含是“自我编制系统”，即晶体。</p>

<p><img class="right" src="/images/2012/12/america.jpg" width="189" height="266"></p>

<p>这仿佛让我洞悉了面向对象设计的玄机。火焰代表了接口，无论如何变化，其外部形式总是不变。接口的引入使得软件设计可以从混沌（即皮亚杰所说的“噪音”）走向有序。至于晶体，则是遵循了信息专家模式的对象，因为它封装了数据以及操作该数据的行为，使得它具有了自我判断的意识。它的表面结构仍然是稳定的，却有一套自我约束的规则。晶体看起来是宁静的，而火焰却如此的灵活。融合晶体与火焰的系统，是否代表了对变化的封装，以及对不变概念的抽象呢？</p>

<p>3、纠缠的细节</p>

<p>薄伽丘在一篇故事中（《十日谈》第六天第一个故事）谈到讲故事的艺术，正好回顾了这种感觉。</p>

<p>**“奥丽达太太，要是你不讨厌的话，我想讲一个世界上最大的故事给你听，叫你听得津津有味，就像骑了一匹马一样，往了路途的遥远。”</p>

<p>“啊，再好没有了，先生，”那位太太说，“请你快给我讲一个故事吧。”</p>

<p>于是绅士开始讲故事给她听。故事倒很精彩，可惜他讲故事的本领，只抵得上他使用他身边那把佩剑的工夫，实在太不高明，时常把一句话颠来倒去的说了又说，甚至说上六七遍，过了一会，忽然又倒过头来说道：“哎呀，我说错啦！”对于故事中的人名地名常常纠缠不清，张冠李戴，弄得别人莫名奇妙。他那说话的声气又跟故事里的人物、情景一点都配不上，真是听得奥丽达太太头晕目眩，冷汗一身，只觉得大祸临头，连命都快要保不住了。到最后，她忍无可忍，又看见那位绅士正愈说愈糊涂，已经迷了路，失了方向，只是在那儿团团打转，再也跑不出来了，就和悦地对他说：“先生，你那匹马跑得太野，请你还是让我下了马吧。”**</p>

<p>在软件设计过程中，最要紧的是思路要清晰，既不能迷失在需求分析中，也不能迷失在复杂的实现细节中。最好能够结合实际的场景，列出我们要达到的目标，需要完成的任务，有序地进行分析和设计。编写代码时，切忌功能之间互相纠缠，虽然体现了对象的协作，但由于职责分配混乱，使得对象之间的协作变得无规律可循，颠三倒四，最后让人忍无可忍，也只能翻身下马了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计恰如其分的架构]]></title>
    <link href="http://agiledon.github.com/blog/2011/10/10/design-just-enough-architecture/"/>
    <updated>2011-10-10T16:35:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2011/10/10/design-just-enough-architecture</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2011/10/justenough01.png"></p>

<p>Thoughtworks的Sam Newman在Mythoughtworks的Software Development小组中给出了Evolutionary Architecture的一些资源。其中一个是Martin Fowler与Rebecca Parsons在QCon SF 2009的一次演讲，题目为<a href="http://www.infoq.com/presentations/agilists-and-architects">Agilists and Architects: Allies not Adversaries Presentation</a>。演讲主要谈到了在敏捷方法中的架构活动（在Martin Fowler的演讲中，播放了黑客帝国中的一个片段，很有意思）。另一个资源则是同样作为thoughtworker的Neal Ford在IBM developerWorks发表的<a href="http://www.ibm.com/developerworks/cn/java/j-eaed1/">Evelutionary Architecture and Emergent Design(演进架构与紧急设计)</a>系列。这是很棒的一个讲解演进架构的系列文章，谈到了TDD、代码复用、连贯接口、DSL、重构、惯用法模式、指标等与演进架构和紧急设计有关的内容。</p>

<!--more-->


<p><img class="left" src="/images/2011/10/justenough02.png">
事实上，关于演进式架构已经是老调重弹。Martin Fowler在2004年发表的文章<a href="http://martinfowler.com/articles/designDead.html">Is Design Dead</a>中谈到了计划式设计与演进式设计之间的区别。在我的书《<a href="http://product.china-pub.com/196623&amp;ref=xilie">软件设计精要与模式</a>》第一章中，也简单阐述了我对二者的理解。书中给出了一个建筑学的隐喻：拙政园与周庄。拙政园是计划式设计的典范，没有详尽的计划，也许就不会有疏朗典雅的拙政园。周庄却并非某人在某一时刻灵感捕捉后的设计成果，而是经历了数百年的历史沧桑，渐进地增添与更替各种建筑，最后形成现在这般灵秀的水乡风貌。在书中，我写道：</p>

<p>演进的设计，同样需要遵循架构设计的基本准则，它与计划的设计唯一的区别是设计的目标。演进的设计提倡满足客户现有的需求；而计划的设计则需要考虑未来的功能扩展。演进的设计推崇尽快地实现，追求快速确定解决方案，快速编码以及快速实现；而计划的设计则需要考虑计划的周密性，架构的完整性并保证开发过程的有条不紊。</p>

<p>最近正在阅读George Fairbanks的著作<a href="http://www.amazon.com/Just-Enough-Software-Architecture-Risk-Driven/dp/0984618104">Just Enough Software Architecture</a>，书中除了计划式设计和演进式设计之外，还提到了第三种设计：Minimal planned design（最小计划设计），这算是一种中庸之道的选择。书中认为，演进式设计需要与一些敏捷实践配合，包括重构、测试驱动设计与持续集成（evolutionary design must be paired with supporting practices like refactoring, test-driven design, and continuous integration.）George认为计划式设计背后隐藏的思想是在构造开始之前，制订的计划可以设计出很好的细节（The general idea behind planned design is that plans are worked out in great detail before construction begins）。他还提到：</p>

<p>当架构为并行的多个团队所共享时，计划式架构设计就具有实践意义，在子团队开始工作之前，这种计划式设计颇有效用（Planned architecture design is also practical when an architecture is shared by many teams working in parallel, and therefore useful to know before the sub-teams start working）。</p>

<p><img class="right" src="/images/2011/10/justenough03.png">
书中还写道：（对于多团队开发而言）计划式架构定义了高层的组件与连接器，并与局部的设计相匹配，而子团队则设计这些组件与连接器的内部模型。架构常常会保证整体的不变量与设计决策，例如建立并发策略、连接器的标准集、分配高层职责或定义某些局部的质量属性场景（a planned architecture that define the top-level components and connectors can be paired with local designs, where sub-teams design the internal models of the components and connectors. The architecture usually insists on some overall invariants and design decisions, such as setting up a concurrency policy, a standard set of connectors, allocating high-level responsibilities, or defining some localized quality attribute scenarios）。</p>

<p>至于最小计划设计，则介乎于演进式设计与计划式设计之间。支持这种设计的人认为：如果完全采取演进式设计，可能会使得设计走向死胡同；而计划式设计又非常难，因为事先对系统并没有全面的了解，可能导致设计错误。在2002年Bill Venners对Martin Fowler的采访中，Martin Fowler认为，最合理的分配是20%的计划式设计，80%的演进式设计（I think 80 percent of the time evolutionary design works for me as well. ）。在George的书中，作者认为需要权衡计划式与演进式设计。一种做法是在项目初期进行计划式设计，确保架构能够处理最大的风险。之后，就可以通过局部的设计来应对需求的变化，或者采用演进式设计，通过推行重构、测试驱动设计与持续集成对架构进行演化。</p>

<p>整体而言，这三种方式的设计各有优劣，我们应根据具体的场景，具体的项目，具体的团队进行针对性地分析。应该把握“因地制宜”的原则，认识到不同的项目需要不同的设计方式。对于不同的开发团队，做出的选择也会不同。例如，如果开发团队精于重构、测试驱动设计，并能很好地实施持续集成，就可以考虑采用演进式设计或最小计划设计。当然，就我个人的意见，比较倾向于Minimal planned design。至于它在演进式设计与计划式设计之前的权衡，不必完全照搬Martin Fowler给出的比例。</p>

<p>在Sam Newman给出的演进式架构资源中，还有一篇<a href="http://www.codingthearchitecture.com/index.html">coding the architecture</a>的文章<a href="http://www.codingthearchitecture.com/pages/book/just-enough-architecture.html">Just enough architecture</a>。这篇文章则从方法学的角度分析来如何获得恰如其分的架构。这是文章中非常漂亮的一幅图：
<img class="center" src="/images/2011/10/justenough04.png"></p>

<p>文章以及上图所表达出来的含义是：传统的瀑布式采取事先设计的做法，可以认为是计划式设计；敏捷方法学倾向于演进式设计；处于其中的RUP则更像是前面提到的最小计划设计。文中主要还是关注我们在架构过程中如何做到架构的“just enough”。事实上，这一观点在George Fairbanks的著作Just enough software architecture中被反复提到，要做到这一点，就需要采用风险驱动模型（Risk-Driven Model）。RDM的架构步骤分为三步：</p>

<ol>
<li><p>识别风险并进行优先级排列</p></li>
<li><p>选择并应用相关技术</p></li>
<li><p>评估风险是否降低</p></li>
</ol>


<p>其实风险驱动模型的三个步骤很容易理解，关键是我们应该如何识别风险，如何排列优先级，又该如何确定解决或控制风险的技术，并进行合理地评估，这是风险驱动模型的难点。我认为RDM带来的益处在于它给出了一个非常具有实践意义的驱动原则与方法，它告诉架构师，当我们在对系统进行架构时，需要从一开始就要重视风险，例如系统的安全性、可伸缩性、安全等诸多与质量属性有关的技术风险。个人认为：风险驱动加上场景驱动，以及技术约束，就等于敏捷架构。大体如下图所示：
<img class="center" src="/images/2011/10/justenough05.png"></p>

<p>风险驱动主要用于处理质量属性相关的架构内容，而场景驱动则用于处理与功能需求相关的架构内容，而技术约束则是架构层面，可能是产品线、环境等能够对系统架构产生直接影响的约束因素。至于敏捷架构的目标，就是设计恰如其分的架构。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解依赖与接缝]]></title>
    <link href="http://agiledon.github.com/blog/2011/08/07/decouple-and-seam/"/>
    <updated>2011-08-07T21:58:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2011/08/07/decouple-and-seam</id>
    <content type="html"><![CDATA[<p>接缝（seam）是Michael C. Feathers提出的概念。Feathers在Working Effectively with Legacy Code一书中对接缝的定义如下：接缝，顾名思义，就是指程序中的一些特殊的点，在这些点上你无需作任何修改就可以达到改动程序行为的目的。</p>

<p>“接缝”这个词语不太好理解，根据我的理解，大约还是依赖点的含义。通过事先找到依赖点，并采取一定方式解除依赖，就能够改善代码质量，尤其是针对遗留代码而言。准确而言，我们寻找接缝以及解依赖，就是为了代码能够具有好的可重用性与可扩展性，尤其是当我们能解除对其他外部服务的依赖时，可以带来程序的可测试性。</p>

<p>最近项目组的同事和我讨论了这样一个满足可测试性的问题。项目中需要对返回的响应信息PlatformResponse进行处理，这些信息会根据不同的StatusCode，得到不同的提示或出错信息。为了避免分支语句的判断，同事利用hash table将StatusCode与提示（出错）信息进行了映射，然后根据当前的StatusCode就可以返回对应的结果。返回结果后，还需要调用外部服务对消息进行处理，例如消息的输出。由于之前相关的类PlatformResponse并没有提供这一逻辑，相关服务要返回消息时，直接返回了PlatformResponse对象，然后再由客户端根据当前的StatusCode来判断，输出相关的提示信息，所以同事将这些逻辑写到了扩展方法中，例如定义PlatformResponseHelper静态类：</p>

<!--more-->


<p><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">PlatformResponseHelper</span> <span class="p">{&lt;/</span><span class="n">p</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">&lt;</span><span class="n">pre</span><span class="p">&gt;&lt;</span><span class="n">code</span><span class="p">&gt;</span><span class="k">private</span> <span class="k">static</span> <span class="n">HashTable</span><span class="p">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">String</span><span class="p">,</span><span class="n">String</span><span class="p">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">messageMapping</span> <span class="p">=</span> <span class="c1">//ignore;</span>
</span><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Output</span><span class="p">(</span><span class="k">this</span> <span class="n">PlatformResponse</span> <span class="n">response</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ServiceLocator</span><span class="p">.</span><span class="n">Lookup</span><span class="p">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">IMessageWriter</span><span class="p">&amp;</span><span class="n">gt</span><span class="p">;.</span><span class="n">Write</span><span class="p">(</span><span class="n">messageMapping</span><span class="p">[</span><span class="n">response</span><span class="p">.</span><span class="n">StatusCode</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">&lt;/</span><span class="n">code</span><span class="p">&gt;&lt;/</span><span class="n">pre</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>通过引入扩展方法，Controller得到的PlatformResponse对象就可以通过调用扩展方法Output()输出获得的提示(出错)信息。注意，在上面的代码中，ServiceLocator是一个单例的服务定位器对象，通过它可以获得注册的服务。在Controller中，同样调用了ServiceLocator来获得它所需的业务服务。</p>

<p>现在，我们需要进行单元测试。项目之前已经为ServiceLocator提供了Mock对象，并且该对象在Controller中也是通过依赖注入的方式获得的。所以，在测试Controller时，可以通过注入模拟的ServiceLocator对象进行测试，从而解除与外部服务之间的依赖关系。现在，在增加了PlatformResponse的扩展方法时，遇到了难题，即如何解除扩展方法与ServiceLocator之间的依赖关系？</p>

<p>显然，这里的ServiceLocator.Lookup<IMessageWriter>.Write()方法调用就是前面所说的“接缝”。我们希望在单元测试中不依赖于ServiceLocator，这就需要解除PlatformResponse与ServiceLocator之间的耦合关系。同事希望既能达到可测试性的目的，又要保障调用的简单。</p>

<p>在面向对象设计中，最常见的解除依赖的方法是职责分离以及抽象，或者利用反射或IOC容器来解除具体依赖。由于要解除与ServiceLocator的耦合关系，再加上调用PlatformResponse相关方法的Controller也是通过依赖注入ServiceLocator对象的，所以我首先想到将ServiceLocator转移到扩展方法的外部，通过传入参数的方式注入依赖。由于这个对象是单例的，因此Controller获得的ServiceLocator也就是PlatformResponse需要的对象。当我们调用PlatformResponse的Output()方法时，可以将Controller获得的ServiceLocator对象作为方法参数传给PlatformResponse。在Controller层，我们利用依赖注入注入Mock对象，就可以达到较好的可测试性了。</p>

<p>然而，倘若要这样做，就需要将调用代码改为：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="n">businessService</span><span class="p">.</span><span class="n">Response</span><span class="p">.</span><span class="n">Output</span><span class="p">(</span><span class="n">serviceLocator</span><span class="p">);</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>同事觉得在调用Output()方法时，还需要传入ServiceLocator对象，实在不够优雅而简洁。</p>

<p>由于C#的扩展方法有很多限制，例如它要求必须是静态类和静态方法，很难利用OO的一些特性，所以我想到的第二个方案是不采用扩展方法，而是将之前的逻辑直接封装到PlatformResponse中。我们可以将Output()方法定义为虚方法，然后再为测试定义PlatformResponse的子类，它将作为测试使用的Mock类，重写Output()方法。遗憾的是，系统基本上都是在调用外部服务的时候才获得的PlatformResponse对象。我们不可能去修改服务对象，使其在单元测试时返回该类的子类对象。</p>

<p>第三条路是转移职责，将扩展方法Output()转移到一个专门的类，例如OutputMessage，由它来负责管理StatusCode与提示（出错）消息之间的映射关系，以及消息的输出，然后由子类重写消息处理的逻辑，完成模拟。例如代码：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">OutputMessage</span> <span class="p">{&lt;/</span><span class="n">p</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">&lt;</span><span class="n">pre</span><span class="p">&gt;&lt;</span><span class="n">code</span><span class="p">&gt;</span><span class="k">private</span> <span class="n">PlatformResponse</span> <span class="n">response</span><span class="p">;</span>
</span><span class='line'><span class="k">private</span> <span class="n">HashTable</span><span class="p">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">String</span><span class="p">,</span> <span class="n">String</span><span class="p">&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">messageMapping</span> <span class="p">=</span> <span class="c1">//ignore;</span>
</span><span class='line'><span class="k">public</span> <span class="nf">OutputMessage</span><span class="p">(</span><span class="n">PlatformResponse</span> <span class="n">response</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">this</span><span class="p">.</span><span class="n">response</span> <span class="p">=</span> <span class="n">response</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">public</span> <span class="k">void</span> <span class="nf">Output</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">OutputInternal</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">protected</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">OutputInternal</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">ServiceLocator</span><span class="p">.</span><span class="n">Lookup</span><span class="p">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">IMessageWriter</span><span class="p">&amp;</span><span class="n">gt</span><span class="p">;.</span><span class="n">Write</span><span class="p">(</span><span class="n">messageMapping</span><span class="p">[</span><span class="n">response</span><span class="p">.</span><span class="n">StatusCode</span><span class="p">]);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="p">&lt;/</span><span class="n">code</span><span class="p">&gt;&lt;/</span><span class="n">pre</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;}</span>
</span><span class='line'><span class="k">public</span> <span class="k">class</span> <span class="nc">MockOutputMessage</span> <span class="p">{&lt;/</span><span class="n">p</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">&lt;</span><span class="n">pre</span><span class="p">&gt;&lt;</span><span class="n">code</span><span class="p">&gt;</span><span class="k">public</span> <span class="n">MockOutputMessage</span><span class="p">(</span><span class="n">PlatformResponse</span> <span class="n">response</span><span class="p">):</span><span class="k">base</span><span class="p">(</span><span class="n">response</span><span class="p">)</span> <span class="p">{}</span>
</span><span class='line'><span class="k">protected</span> <span class="k">override</span> <span class="k">void</span> <span class="nf">OutputInternal</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'><span class="c1">//mock international service to handle message;</span>
</span><span class='line'><span class="p">&lt;/</span><span class="n">code</span><span class="p">&gt;&lt;/</span><span class="n">pre</span><span class="p">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="p">&lt;</span><span class="n">p</span><span class="p">&gt;</span>   <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>实际上这一方案是第二种方案的一种变化。因为我们无法修改一个已经被广泛使用的类，所以只能在引入新职责的时候，通过引入新生类来完成职责的增加，并利用子类重写的方式达到可测试的目的。</p>

<p>可是这一方案实际上更无法达到同事的目标，因为改动后的调用变得比第一种方案更复杂：
<code>csharp
   new OutputMessage(businessService.Response).Output();
</code></p>

<p>我们必须考虑OutputMessage对象的创建，同事还需要将PlatformResponse对象传入，再调用它的Output()方法。虽然不需要传入方法参数，但对象的创建以及构造函数参数的传入，反而让事情变得更复杂。</p>

<p>那么，应该怎么办？同事的理想目标是调用简单。就目前而言，在C#中，只有扩展方法才能让我们对PlatformResponse对象的message处理显得如此的自然而简洁。再加上PlatformMessage对象已经被广泛使用，因此从PlatformMessage类的角度进行处理，就变得不再可能。</p>

<p>让我们再来仔细思考“接缝”的问题。是谁引入了依赖点？接缝是调用ServiceLocator这条语句，而它的目的实际上是需要获得IMessageWriter。是这个外部服务成为测试的障碍。所以解决的重点应该是解除与IMessageWriter之间的依赖。要这样做，就需要修改Output()扩展方法，使其能够传入IMessageWriter对象。这种改进事实上与第一种方案没有什么区别，唯一的不同是它依赖于更小的接口，而不是全局的ServiceLocator对象。我认为，这已经是一个最好的方案了。但是同事依旧执著于调用的简单性。他认为，不能为了单元测试，而改变客户端调用的方式。</p>

<p>现在，我们已经明白扩展方法是最简单的实现方式，纠结仅仅在于IMessageWriter服务的获取方式而已。在产品代码中，我们可以通过ServiceLocator来获得IMessageWriter对象，而在测试的时候，我们又需要模拟该服务对象。若要两全齐美，只有区分测试与生产环境。事实上，这是我最初想到的做法，就是引入预定义来区分测试与真正的生产环境。但同事无法接受这种C++所主要采取的预定义做法。因此，我唯一能想到的是修改PlatformMessage类的定义，提供设置IMessageWriter的属性（因为C#并不支持扩展属性），并在Output()方法中判断IMessageWriter对象是否为null。如果为null，则说明它没有在测试环境下注入，这就需要通过ServiceLocator获得。
Liquid error: invalid byte sequence in US-ASCII</p>

<p>虽然我修改了PlatformResponse类的定义，但由于需要调用或创建PlatformResponse对象的外部服务并不需要新增加的MessageWriter属性，因此这样的修改实际上是扩展，并不会影响到以前的代码。这就是我唯一能够想到的满足同事要求的方案。在测试时，我们可以通过为PlatformResponse注入模拟的IMessageWriter对象，而在真正的产品代码中，则无需为它设置MessageWriter属性，而是直接调用它的扩展方法Output()。美中不足之处在于它为调用者提供了一定的开放性，使得调用者能够自由设置MessageWriter属性，破坏了对象的封装。为使这种破坏带来的影响降到最低，在单元测试放在同一个项目的前提下，可以考虑将MessageWriter属性定义为internal。</p>

<p>我们常常需要在灵活性和简单性之间进行设计权衡。大多数情况下，都可能产生非此即彼的选择。要做到两全齐美真的很难。从面向对象的角度来看，我不认为最后的方案是最佳方案。其实，通过方法参数注入IMessageWriter的做法已经足够好了，它并没有加大结构与调用的复杂性。无论怎样，设计总是见仁见智的问题，就看大家的选择了。唯一需要遵循的原则，就是设计必须结合具体的场景来做出正确的决定。</p>
]]></content>
  </entry>
  
</feed>
