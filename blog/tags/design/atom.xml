<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Design | 简单文本]]></title>
  <link href="http://agiledon.github.com/blog/tags/design/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2013-05-07T22:30:46+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[从Go语言的设计学习设计决策]]></title>
    <link href="http://agiledon.github.com/blog/2013/05/04/design-decision-learning-from-go/"/>
    <updated>2013-05-04T21:12:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/05/04/design-decision-learning-from-go</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/05/decision.jpg">
阅读了Rob Pike撰写的《<a href="http://www.oschina.net/translate/go-at-google-language-design-in-the-service-of-software-engineering">Go在谷歌：以软件工程为目的的语言设计</a>》，颇多感触。这些感触并不在于语言层面，或者Go这门语言的语法以及底层实现；而是因为语言设计者们在设计Go这门语言时，做出设计决策的合理性以及基于的事实与根据。正如此文标题所言，显然，Go的创造者们从一开始就树立了准确的愿景与目标，并且清晰地确定了该语言的适用场景，即它需要解决“由多核处理器、系统的网络化、大规模计算机集群和Web编程模型带来的编程问题”，这是理解这门语言，进而明确其设计意图的最根本所在。</p>

<p>刚刚参加了公司八叉大神组织的轮子大赛，我们写了一个轻量级的IoC容器<a href="https://github.com/agiledon/melt">Melt</a>。就这个容器或者说框架本身，和八叉讨论了框架设计的特点。他提到“framework开发和功能开发的一个最大分别就在于，你需要规定在这个framework里那些是支持的，哪些是不支持的。这条线要你自己来划，或者说你的framework要有态度。”这是我非常认同的观点。Framework要有态度，这意味着你在践行并且在引导一种最佳实践。或者我们可以理解为这是一种架构的约束。我们都知道，在软件设计中，如果没有任何约束，带来的问题反而会更大。约束是一种驱动力，例如我们需要可伸缩性的约束，就需要我们设计的服务不应该是有状态的。框架的态度大意如此。</p>

<p>回过头来看这篇文章介绍的Go设计理念，无时无刻不是在体现设计者施加在这门语言身上的态度。必须注意，这种态度或者说设计理念又绝对离不开这门语言的设计愿景。若是脱离这种具体场景来看Go语言，或许有众多不合理之处，但我们并不能依此妄加论断。正如话剧演员在舞台上的表演，总带着几分略带夸张的表情与语气，我们却不能指责这种表演不够生活化。当我们在思考一个设计决策是否合理时，是否参考了当时的场景做出判断呢？进一步讲，当我们自己在进行设计决策时，又是否充分地考虑了具体的场景呢？例如，Go语言之所以采用C语言风格的花括号，其考量并非简单地延续C语言风格那么简单，在前面提及的愿景的大前提下，设计者必须考虑如果使用Python或Haskell风格的空格缩进，对于大规模程序而言，可能会造成太多的问题。如文中所云：“我们的观点是，虽然空格缩进对于小规模的程序来说非常适用，但对大点的程序可不尽然，而且程序规模越大、代码库中的代码语言种类越多，空格缩进造成的问题就会越多。为了安全可靠，舍弃这点便利还是更好一点，因此Go采用了花括号表示的语句块。”</p>

<!--more-->


<p>再看Go语言的依赖处理，它施加了一个看似比较独裁的约束，即“不允许其依赖图中有循环性的包含关系，编译器和链接器都会对此进行检查以确保不存在循环依赖”。设计者并不否认循环依赖存在一定的价值，然而在大规模程序的前提下，它带来的问题远远超过了可能存在的价值。文中提到：
<blockquote><p>循环依赖要求编译器同时处理大量源文件，从而会减慢增量式build的速度。更重要的是，如果允许循环依赖，我们的经验告诉我们，这种依赖最后会形成大片互相纠缠不清的源代码树，从而让树中各部分也变得很大，难以进行独立管理，最后二进制文件会膨胀，使得软件开发中的初始化、测试、重构、发布以及其它一些任务变得过于复杂。</p></p><p><p>不支持循环import偶尔会让人感到苦恼，但却能让依赖树保持清晰明了，对package的清晰划分也提了个更高的要求。就象Go中其它许多设计决策一样，这会迫使程序员早早地就对一些大规模程序里的问题提前进行思考（在这种情况下，指的是package的边界），而这些问题一旦留给以后解决往往就会永远得不到满意的解决。</p></blockquote></p>

<p>显然，Go语言的设计者并不是要设计一门大而全，兼容并包的全能语言，它严格而合理地压制着设计时可能膨胀的欲望，不与设计愿景相悖，并时刻从工程学的角度看待设计。设计一门语言如此，开发一个产品或项目更应如此。例如对于产品而言，当下流行的Lean Startup对于产品的理念，正是这种实效的工程主义。MVP（最小可验证产品）的划分将精简与避免浪费做到了极致，严格避免功能盲目的扩大化。</p>

<p>Rob Pike还提到：“在依赖关系方面保持良好状况要比代码重用重要”，甚至支持“为了使用一个函数，把所需的那一小段代码拷贝过来要比拉进来一个比较大的库强”。虽然我们在设计与开发时，常常会严格遵循DRY原则，同时也尽可能地追求重用，因为我们知道重复其实是一种“恶”。若要最大限度地重用，就必须保证实体的细粒度。从类级别来讲，粒度越细，就意味着类的数量越多，这可能会加大系统的复杂度。Kent Beck提出的简单设计中，第四条即为保证类的数量尽可能少。整体结合来看，实质是指在没有看到重用以及变化的征兆前，应尽可能避免类的数量被无谓地扩大。熊节将其概述为“如无必要，勿增实体”，非常准确。显然，细粒度的类虽然可以在重用上带来好处，但却可能使得系统变得更复杂。细粒度的类还在可控制的范畴，因为我们可以采用一些方式例如Facade或Mediator模式来简化或隐藏多个细小类之间的协作。然而，对于模块（指物理模块）层面来讲，粒度过细的模块会导致对依赖的管理变得复杂。我曾经在一个.NET项目中看到过多达100多个程序集，若尝试在Visual Studio中为其生成依赖图，可能会耗尽内存。而且这些细粒度的程序集，也会导致本地构建时间的增长。关于.NET项目中依赖管理的问题，Patrick Smaccla的文章《<a href="http://www.infoq.com/cn/articles/NDepend">避免在.NET代码中出现不恰当依赖</a>》有详细论述。然而，若是不能保证模块的细粒度，根据Robert Martin提出的包复用原则，则可能导致对一个细小功能的重用，带来对整个包的依赖。</p>

<p>看来，我们有必要正视依赖与重用之间存在的鱼与熊掌不可兼得的问题。我的意见是当出现此类问题时，我们可以考虑职责分配上是否出现问题。如果模块的分解遵循了“高内聚”原则，可能此类依赖就只会发生在模块的内部。另一种思路是考虑我提出的所谓“依赖的沉淀”，即随时绘制组件图或包图，清晰地标明依赖的关系和方向，并根据权值来判断该模块应该位于纵向的物理分布层级的哪一层。具体细节可参考我写的一篇文章《<a href="http://agiledon.github.io/blog/2013/03/03/assigning-responsibility-between-modules/">模块间的职责分配</a>》。</p>

<p>文中还提到了Go语言故意缺失的一个特性就是不支持缺省参数。设计者认为：
<blockquote><p>缺省参数太容易通过添加更多的参数来给API设计缺陷打补丁，进而导致太多使程序难以理清深圳费解的交互参数。默认参数的缺失要求更多的函数或方法被定义，因为一个函数不能控制整个接口，但这使得一个API更清晰易懂。哪些函数也都需要独立的名字， 使程序更清楚存在哪些组合，同时也鼓励更多地考虑命名--一个有关清晰性和可读性的关键因素。</p></blockquote></p>

<p>姑且不谈这一设计的驱动因素是否可取，这里显然教会了我们在软件设计时应该懂得如何去权衡。权衡的能力是架构师必备的技能，就好像老婆和老妈同时落水了，你该去救哪一个，这个命题总是让人不舒服，因而不肯回答。说来简单，在进行设计决策时，如果要权衡多个指标，一定要以最重要的哪个指标为主。问题是当我们不知道哪个指标更重要时，应该怎么办？我想，答案还是应该从愿景中去寻找。根据Go语言的愿景，对于大规模程序而言，清晰易懂的API会降低维护成本，并在一定程度上保障软件的质量，这显然比API的兼容性更为重要。</p>

<p>Go语言对于可见性的设计非常漂亮，“名字自己包含了可见性的信息，而不是使用常见的private,public等关键字来标识可见性：标识符首字母的大小写决定了可见性。如果首字母是大写字母，这个标识符是exported(public); 否则是私有的。”最初看来，这样的约定非常怪异，可是仔细琢磨，你不觉得通过这样一个简单的约定，让程序一下子变得精简了许多吗？其实只要明确了这一约定，代码的可见性仍然是清晰可知的。从某种程度讲，甚至比显式地声明public或private更加清晰。</p>

<p>Go语言对于继承的处理也显得特立独行，因为在Go语言中，没有类型层级（type hierarchy）的概念。它选择了组合而非继承，在于它对继承滥用表达了足够的忧虑和担心。作者认为：“类型层次结构这种模型会促成早期的过度设计，因为程序员要尽力对软件可能需要的各种可能的用法进行预测，不断地为了避免挂一漏万，不断的增加类型和抽象的层次。这种做法有点颠倒了，系统各个部分之间交互的方式本应该随着系统的发展而做出相应的改变，而不应该在一开始就固定下来。”我对此持保留意见，但在支持接口的前提下，这种规避继承的做法，仍有可取之处。因为接口可以支持OO中多态的特性，而组合又能保证逻辑的重用。这意味着，继承给我们带来的好处已经找到了合理的替代品。</p>

<p>Go抛弃了大多数传统语言所支持的异常机制，而转而使用error。这种机制建立在一个前提，即Go语言支持多个返回值。倘若像Java、C#等多数语言那样，仅支持一个返回值，则异常机制就变得完全有必要了。鉴于对多返回值的支持，且Go中的error又是抽象的接口类型，这样的设计就变得合乎情理了。</p>

<p>我们注意到Go语言中一些与众不同的特征，其实皆为设计者设计理念的体现，从中我们可以看到设计者做出设计决策的依据。显然，这些决策皆围绕着最高的设计愿景，并结合实际的工程场景，在通过合理权衡的前提下做出的。这种决策之道，值得软件架构师与设计师借鉴。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[模块间的职责分配]]></title>
    <link href="http://agiledon.github.com/blog/2013/03/03/assigning-responsibility-between-modules/"/>
    <updated>2013-03-03T20:19:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/03/03/assigning-responsibility-between-modules</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/03/module.png"></p>

<p>职责分配不仅限于对象之间。如果将对象看做是细粒度的封装，则模块作为组合多个对象的设计元素，可以看做是粗粒度的封装。倘若在模块之间分配职责失当，带来的影响会比对象职责分配不合理更大。这是因为只要在OO设计中进行了适度的封装，在一定程度上体现了隐藏细节的设计理念，对象的职责分配失当就不会溢出边界，对其余对象不会产生太大的影响。</p>

<p>模块间的职责分配好似对对象进行一种归类，只有属于同一类别的对象才能被分配到一个模块中。这可以说是对“高内聚”原则的简单理解。注意，模块常常是对架构层次结构的横向切割，不同的模块可能处于不同的逻辑层。因此，大的设计问题可能牵涉到分层问题。从架构层面来讲，或许我们有必要在获得模块的详细设计之前，审慎地给出一个系统逻辑架构，会有助于模块间的职责分配。</p>

<!--more-->


<p>与对象职责分配一样，模块间的职责分配也有“坏味道”存在。常见的坏味道就是“循环依赖”，即模块A依赖模块B，模块B依赖模块C，模块C又依赖模块A。这有点像三角恋爱关系，扯不清，理还乱，让人头疼。所以我的一个设计实践，就是从设计一开初，就要绘制软件系统的包图，通过直观的图形来帮助我们识别这种依赖的乱麻。</p>

<p>另一种坏味道我称之为“爱屋及乌”，简单说来，其实就是违背了Robert Martin提出的有关包设计的“共同复用原则（CRP）”，即“一个包中的所有类应该是共同重用的。”如果一个包的职责分配出现问题，违背了这种共同重用，就可能导致一个包为了使用另一个包的某一个特性，必须把整个包都放进来，哪怕这个包中的其他特性对于使用的包而言完全无用。这就好像我贪恋钱财，娶了一个垂垂老矣的富婆，为了钱，也不在乎丑陋的容颜和高我数倍的年龄了。</p>

<p>例如在我之前设计的一个系统中，出现了这样的包图：
<img class="center" src="/images/2013/03/module01.png"></p>

<p>该系统属于基于元数据的报表系统，engine.report包负责读取定义在配置文件中的报表模板，并在运行时绑定数据，最终输出报表。报表的数据则由engine.data包来承担，它会根据配置的元数据生成SQL语句，访问数据库，动态得到报表所需的数据。engine.entity是在之后引入的一个包，它承担了类似ORM的功能，能够将engine.data包返回的数据，通过配置的映射信息，生成Entity对象。而该Entity对象则作为报表数据绑定的基本元素。至于tool.reportdesigner，则是一个Swing界面的报表设计器应用程序，用户通过界面的设计操作，可以生成我们需要的报表模板。</p>

<p>倘若没有绘制这个包图，而是直接阅读代码，或许很难发现这其中蕴含的设计问题。包图清晰直观，首先我们看到了engine.report与engine.entity之间存在双向依赖（它是循环依赖的特殊形式），并在engine.report、engine.entity与engine.data三者之间发现了循环依赖。其次，我们发现tool.reportdesigner依赖于engine.report，但由于它只负责报表模板的设计，并不需要engine.report包中的运行时数据绑定，以及报表导出功能。显然，前者违背了“循环依赖”，后者违背了“爱屋及乌”。</p>

<p>究其原因，我们发现罪魁祸首就在于engine.report包中的xml组件。该组件的功能与配置相关，其中还包含了许多配置在xsd文件中自动生成的jaxb对象。它并不仅仅是Report独有的功能，相反，这个包图的所有包事实上都需要用到这个功能。换言之，这些包均需要依赖于xml。最简洁的改进方案就是将它抽离出来，放到一个单独的包中。改进后的包图如下：
<img class="center" src="/images/2013/03/module02.png"></p>

<p>为何我将xml设计为infrastructure.xml包？这完全是因为依赖的关系。假设我们将每个依赖都设置其权值为1，则一个包被依赖得越多，其依赖权值就越大。假设这些权值就等同于重量，然后我们设想将这些包都丢到一湖秋水中，分次浮沉。显然，权值越多的包就会慢慢沉淀下去，而权值越少的包最后会浮在上面。我称这种现象为“依赖沉淀”。通过这种方式，可以在一定程度上帮助我们对软件系统的层进行有效划分。
<img class="center" src="/images/2013/03/module03.png"></p>

<p>依赖管理是开发者可能面临的地狱。如果还加上对各种版本包的依赖，这个地狱就可能处于十八层的水深火热中了。依赖管理是一个大课题，但如果模块间的职责分配合理，或许会是一个不错的开始。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阅读的设计体悟]]></title>
    <link href="http://agiledon.github.com/blog/2013/03/02/harvest-from-reading/"/>
    <updated>2013-03-02T21:46:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/03/02/harvest-from-reading</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/03/jsbookcover.jpg">
不管语言的变化有多大，关于程序设计的基本编程思想和设计本质，应是殊途同归。两年前阅读了Jonathan Snook的著作《Javascript捷径教程Accelerated DOM Scripting with Ajax, APIs, and Libraries》。在书中，他带领读者构建了一个简单的动画对象。简单的例子，轻描淡写的描述，却似乎展现了朴素的基本设计思想。</p>

<!--more-->


<p>下面记录了一些阅读感悟。例如，书中这样写道：
<blockquote><p>页面里要用到的动画对象一般都不止一个，所以应该把它定义成一个类。定义一个有5个参数的函数：要加上动画的元素、要改变的属性、属性的起始值、属性的结束值、动画的持续时间。<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">duration</span><span class="p">){}</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></p><p><p>不管编写什么代码，都应该先把实现想透彻。每个决定都有正反两方面的后果，你应该想清楚每个决定的原因。</p></blockquote></p>

<p>这代表一个朴素的思想，那就是从实现原理来进行设计决定。注意这里的实现原理，并不是要关注实现的细节，而是要考虑影响实现的因素，并从调用者的角度思考接口或函数的输入与输出值。以本例而言，如果事先不明确动画效果的营造方式，是根据时间的变化动态变更element属性的方式来完成，就无法确定Animation函数。设计不是空中楼阁，抽象固然是重要的，但功能实现的基本原理仍然需要事先思考通透，否则，设计就可能走弯路。拿到一个功能，先要弄清楚它的目标是什么，有没有质量属性的要求，未来的变化如何，还有这一功能的实现原理。例如，我们要提供服务定制的功能，就需要实现明确“服务”的定义，如何完成服务的注册，服务的发布，服务的订阅，谁会订阅这些服务，服务的安全如何保障，如何解决服务与实现的脱耦。只有把这些问题想清楚了，设计才会靠谱。
<blockquote><p>看看前面的代码，元素ID是作为一个字符串传递进来的，那么在动画对象中获取该元素就有两种方法：一是通过DOM方法document.getElementById()；二是采用Javascript库的调用，如${}。……既然我们想让这个动画对象能适合各种情况，那还是用DOM方法比较好，保证它不依赖于任何库。<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span><br/></span><span class='line'><span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">ducument</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span><br/></span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">el</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></blockquote></p>

<p>这段话仍然体现了一种设计决策。它的实现目标是不与任何JS库耦合。这就需要保证实现的通用性。
<blockquote><p>要是你打算执行动画的元素没有ID怎么办呢？为了让这个类更灵活，让我们把它改成既可以传入元素引用，又可以传入ID字符串。如果传入的是ID字符串而不是对象引用，程序就会通过DOM方法去获取元素。两全其美！<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span><br/></span><span class='line'><span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span><br/></span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">el</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span><br/></span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">el</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></blockquote></p>

<p>这又是一种编码修炼了。除了要在设计上保证灵活性之外，我们在编码时也需养成保证代码完整性与健壮性的习惯，并体贴地为调用者着想。有这么一条设计原理，就是伯斯塔尔法则(Postel's Law)：“发送时要保守；接收时要开放。”这里的实现无疑遵循了这样一个法则。我们在编码时，考虑到这些因素了吗？</p>

<p>Ok，继续我们的阅读。
<blockquote><p>实例化一个对象要用到5个参数，但一眼看上去很难看出参数里的那些数字都代表什么含义。……为此你可以把参数改成字面量对象，键的名称看起来更直观一些。而且如此改动能使API更加灵活，因为即使今后增加了更多的参数，实例化对象的代码也不会变得更复杂。<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span><br/></span><span class='line'><span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">options</span><span class="p">.</span><span class="nx">element</span><span class="p">;</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}</span><br/></span><span class='line'><span class="kd">var</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="nx">element</span><span class="o">:</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;elementId&#39;</span><span class="p">),</span><br/></span><span class='line'><span class="nx">property</span><span class="o">:</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span><br/></span><span class='line'><span class="nx">from</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span><br/></span><span class='line'><span class="nx">to</span><span class="o">:</span><span class="mi">200</span><span class="p">,</span><br/></span><span class='line'><span class="nx">duration</span><span class="o">:</span><span class="mi">1000</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">};</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></blockquote></p>

<p>无疑，这体现了面向对象的“封装”思想。通过封装既保证了代码的清洁与可读性，同时还有利于未来的扩展。这与OCP（开放-封闭原则）是一脉相承的。代码是有结构的，或者体现为函数，或者体现为对象，事实上都是一种按照属性与职责进行的分类。分类是保持清洁、避免重复的唯一法门。从简朴的角度来说，所有的设计其实都是在做着分类的游戏。分类体现了定义的抽象，职责的分配，结构的划分；如果再加上类别之间的协作，就是设计的全部了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[职责与封装]]></title>
    <link href="http://agiledon.github.com/blog/2013/02/20/responsibility-and-encapsulation/"/>
    <updated>2013-02-20T21:49:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/02/20/responsibility-and-encapsulation</id>
    <content type="html"><![CDATA[<p>面向对象设计的关键，我认为是识别职责，封装合理的对象。缺乏合理的封装，就会缺少正确的领域对象，使得属于共同职责的领域信息散乱分布到系统的各个方法中，导致概念不够清晰，职责混乱，以及代码的重复。然而，如果没有正确地识别职责，又可能导致封装无从谈起，因为我们获得的需求可能是散乱的，既难以抽象概念，又缺乏层次。故而，职责与封装是相辅相成的概念。如下图所示：
<img class="center" src="/images/2013/02/responsibility01.png"></p>

<p>我们不能简单地将封装当做是“信息隐藏”。所谓隐藏信息以及具体行为的细节，确实是封装的本质所在，但面向对象思想中的封装，其目的还在于对领域概念以及设计概念的识别。前者是对业务模型的抽象，如电子商务系统中的Product、Order、OrderItem等概念；后者是对设计模型的改进，如在设计模式中引入策略对象、命令对象，DDD中提倡的Repository、Factory对象。这也是为何许多设计者很容易理解封装的概念，但却始终无法做到合理封装的根本原因。</p>

<!--more-->


<p>此时，我们需要运用职责驱动设计，通过对职责的识别来提炼这些概念。概念可以起到分类的作用，根据职责对行为与数据进行分类，找到其应该归属的对象，散乱的逻辑就会变得清晰起来。就好似我们对彩球按照颜色进行分类，并放置到不同的位置：
<img class="center" src="/images/2013/02/responsibility02.png"></p>

<p>不同的颜色有分明不同的特征，只要不是色盲，分类自然水到渠成。现实中的系统需求自然不如颜色这般泾渭分明，要从纷繁复杂的混沌需求中超脱出来，最好的办法就是按照不同的角度或层次去寻找职责，并用最简单的语言一句话描述这些职责。根据职责的特征，我大致将职责分为三个层次，由外自内分别为：业务价值、业务功能与业务实现，如下图所示：
<img class="center" src="/images/2013/02/responsibility03.png"></p>

<p>业务价值基本上体现了这个需求用例（或用户故事）存在的目的，即解释了需求的Why。简言之，只有提供了该职责，则此需求对于客户才是有价值的。这也符合用户故事INVEST原则中的V（Valuable）。没有价值的需求，自然是应该放弃的。故而在识别业务价值时，常常从用户的视角来分析，辨别。</p>

<p>业务价值是职责驱动的入口，因为在寻找到了业务价值之后，我们就可以剖析该价值需要哪些支撑功能（它可以解释需求的What），再由功能继续深入分析，找到实现功能的职责（它可以解释需求的How）。因此，这个模型是一个层层推进的过程。</p>

<p>职责驱动不仅仅可以从文字需求入手，同样可以针对已经实现的代码。甚至我们可以将这种职责驱动看做是一种阅读代码的技巧，通过寻找业务价值，进而分析业务功能和业务实现，对代码形成一个整体的感观，进而通过合理地分配职责改善原有代码。如下代码是《修改代码的艺术》一书中给出的例子：
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>import javax.mail.&lt;em>;
</span><span class='line'>import javax.mail.internet.&lt;/em>;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>public class MailingListServer {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>public static final String SUBJECT_MARKER = "[list]";
</span><span class='line'>public static final String LOOP_HEADER = "X-LOOP";
</span><span class='line'>
</span><span class='line'>public static void main(String[] args) {
</span><span class='line'>    if (args.length != 8) {
</span><span class='line'>        System.err.println("Usage: java MailingList &lt;popHost&gt; " + 
</span><span class='line'>        "&lt;smtpHost&gt; &lt;pop3user&gt; &lt;pop3password&gt; &lt;smtpuser&gt; &lt;smtppassword&gt; &lt;listname&gt; " +
</span><span class='line'>        "&lt;relayinterval");
</span><span class='line'>    }
</span><span class='line'>    return;
</span><span class='line'>
</span><span class='line'>    HostInformation host = new HostInformation(arg[0]);
</span><span class='line'>    String listAddress = args[6];
</span><span class='line'>    int interval = new Integer(args[7]).intValue();
</span><span class='line'>    Roster roster = null;
</span><span class='line'>    try {
</span><span class='line'>        roster = new FileRoster("roster.txt");
</span><span class='line'>    }catch(Exception e) {
</span><span class='line'>
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    try {
</span><span class='line'>        do {
</span><span class='line'>            try {
</span><span class='line'>                Properties properties = System.getProperties();
</span><span class='line'>                Session session = Session.getDefaultInstance(properties, null);
</span><span class='line'>                Store store = session.getStore("pop3");
</span><span class='line'>                store.connect(host.pop3Host, -1, host.pop3User, host.pop3Password);
</span><span class='line'>                Folder defaultFolder = store.getDefaultFolder();
</span><span class='line'>                if (defaultFolder == null) {
</span><span class='line'>                    return;
</span><span class='line'>                }
</span><span class='line'>                Folder folder = defaultFolder.getFolder("INBOX");
</span><span class='line'>                if (folder == null) {
</span><span class='line'>                    return;
</span><span class='line'>                }
</span><span class='line'>                folder.open(FOLDER.READ_WRITE);
</span><span class='line'>                process(host, listAddress, roster, session, store, folder);
</span><span class='line'>            }catch () {
</span><span class='line'>
</span><span class='line'>            }
</span><span class='line'>            try {
</span><span class='line'>                Thread.sleep(interval * 1000);
</span><span class='line'>            } catch() {
</span><span class='line'>
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>        } while (true)
</span><span class='line'>    }catch () {
</span><span class='line'>
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>private static void process(
</span><span class='line'>    HostInformation host, String listAddress, Roster roster,
</span><span class='line'>    Session session, Store store, Folder folder) throws MessagingException {
</span><span class='line'>    try {
</span><span class='line'>        if (folder.getMessageCount() != 0) {
</span><span class='line'>            Message[] messages = folder.getMessages();
</span><span class='line'>            doMessage(host, listAddress, roster, session, folder, messages);
</span><span class='line'>        }
</span><span class='line'>    }catch () {
</span><span class='line'>
</span><span class='line'>    }finally {
</span><span class='line'>        folder.close(true);
</span><span class='line'>        store.close();
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>private static void doMessage(
</span><span class='line'>    HostInformation host,
</span><span class='line'>    String listAddress,
</span><span class='line'>    Roster roster,
</span><span class='line'>    Session session,
</span><span class='line'>    Folder folder,
</span><span class='line'>    Message[] messages) throws MessageingException {
</span><span class='line'>    FetchProfile fp = new FetchProfile();
</span><span class='line'>    fp.add(FetchProfile.Item.ENVELOPE);
</span><span class='line'>    fp.add(FetchProfile.Item.FLAGS);
</span><span class='line'>    fp.add("X-Mailer");
</span><span class='line'>    folder.fetch(messages, fp);
</span><span class='line'>    for (int i = 0; i &lt; messages.length; i++) {
</span><span class='line'>        Message message = messages[i];
</span><span class='line'>        if (message.getFlags().contains(Flags.Flag.DELETED)) continue;
</span><span class='line'>        System.out.println("message received: " + message.getSubject());
</span><span class='line'>        if (!roster.constainsOneOf(message.getFrom())) continue;
</span><span class='line'>        MimeMessage forward = new MimeMessage(session);
</span><span class='line'>        Address[] fromAddress = message.getFrom();
</span><span class='line'>        InternetAddress from = null;
</span><span class='line'>        if (fromAddress != null &amp;&amp; fromAdress.length &gt; 0) {
</span><span class='line'>            from = new InternetAddress(fromAddress[0].toString());
</span><span class='line'>        }
</span><span class='line'>        forward.setFrom(from);
</span><span class='line'>        forward.setReplyTo(new Address[] {
</span><span class='line'>            new InternetAddress(listAddress)
</span><span class='line'>        });
</span><span class='line'>
</span><span class='line'>        forward.addRecipients(Message.RecipientType.BCC, roster.getAddresses());
</span><span class='line'>        String subject = message.getSubject();
</span><span class='line'>        if (-1 == message.getSubject().indexOf(SUBJECT_MARKER)) {
</span><span class='line'>            subject = SUBJECT_MARKER + " " + message.getSubject();
</span><span class='line'>        }
</span><span class='line'>        forward.setSubject(subject);
</span><span class='line'>        forward.setSentDate(message.getSentDate());
</span><span class='line'>        forward.addHeader(LOOP_HEADER, listAddress);
</span><span class='line'>        Object content = message.getContent();
</span><span class='line'>        if (content instanceof Multipart) {
</span><span class='line'>            forward.setContent((Multipart)content);
</span><span class='line'>        } else {
</span><span class='line'>            forward.setText((String)content);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        Properties props = new Properties();
</span><span class='line'>        props.put("mail.smtp.host", host.smtpHost);
</span><span class='line'>
</span><span class='line'>        Session smtpSession = Session.getDefaultInstance(props, null);
</span><span class='line'>        Transport transport = smtpSession.getTransport("smtp");
</span><span class='line'>        transport.connect(host.smtpHost, host.smtpUser, host.smtpPassword);
</span><span class='line'>        transport.sendMessage(forward, roster.getAddresses());
</span><span class='line'>        message.setFlag(Flags.Flag.DELETED, true);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这段代码集中了所有劣质代码的特性，如可读性差，可测试性差，可重用性差，可扩展性差，也很难体现设计者的意图。</p>

<p>是的，意图！意图就是体现业务价值的关键所在，最好能够通过类的名称直接传达这种业务价值。显然，上述代码完全没有做到这一点。通过仔细阅读这段代码，然后从职责的角度入手，就驱使我们思考它究竟做了什么？显然，这段代码的功能就是侦听邮件服务器，并根据实现给定的邮件名单，将收到的邮件转发给邮件名单的相关人士。所以，它的业务价值就是转发邮件。</p>

<p>要做到转发邮件，基本的功能是要能够侦听邮件服务器。我们可以将侦听看做是业务功能。通常，对于实际的需求而言，职责模型并非简单的三层结构，它可能是一种递归的方式，也即可以对业务价值、业务功能甚至业务实现进行不断深入的分解。例如，对于这里的侦听业务功能而言，还可以分解为下一个业务功能，即接收邮件。同时，要实现邮件的转发，还需要发送邮件的支撑。下面就是我们所能够识别出来的职责：</p>

<pre><code>* 转发邮件
    ** 侦听邮件
        *** 接收邮件
    ** 发送邮件
</code></pre>

<p>面对如此简短的职责描述，再要识别对象所要封装的概念就变得非常容易了。下图是根据识别出来的职责获得的类图结构：
<img class="center" src="/images/2013/02/responsibility04.png"></p>

<p>比较这个设计模型与之前的代码，新的模型无疑在职责分配上占了胜场。并且，每个对象的名称都很好地传达了它所能完成的功能。由于封装将职责的实现细节有效地隐藏，并为它们各自划分了空间，形成各自的职责单元，然后再以弱耦合的形式进行协作。因而，我们可以很容易地对它们进行单元测试，或者对参与协作的行为进行Mock。接口的引入则是为了未来的功能扩展，例如我们不再使用javax.mail库来实现邮件收发，就可以提供不同的实现类。可独立封装的MessageReceiver与MessageSender还可以为系统的其他模块所重用。职责与封装相得益彰，有效地改善了整个设计模型。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HDFS的架构]]></title>
    <link href="http://agiledon.github.com/blog/2013/02/16/architecture-of-hdfs/"/>
    <updated>2013-02-16T15:33:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/02/16/architecture-of-hdfs</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/2013/02/hdfs.jpg">
HDFS(Hadoop Distributed File System)作为<a href="http://hadoop.apache.org">Hadoop</a>下的一个子项目，是目前使用极为广泛的分布式文件系统。它的设计目的是提供一个高容错，且能部署在廉价硬件的分布式系统；同时，它能支持高吞吐量，适合大规模数据集应用。这一目标可以看做是HDFS的架构目标。显然，这样的架构设计主要还是满足系统的质量属性，包括如何保证分布式存储的可靠性，如何很好地支持硬件的水平扩展，如何支持对大数据处理的高性能以及客户端请求的高吞吐量。所以，HDFS的架构设计颇有参考价值，在Hadoop的Apache官方网站上也给出了<a href="http://hadoop.apache.org/docs/current/hdfs_design.html">HDFS的架构指南</a>。在<a href="http://www.aosabook.org/en/index.html">The Architecture of Open Source Applications</a>卷I的第8章也详细介绍了HDFS的架构。</p>

<p>HDFS的高层设计看起来很简单，主要包含NameNode与DataNode，它们之间的通信，包括客户端与HDFS NameNode服务器的通信则基于TCP/IP。客户端通过一个可配置的TCP端口连接到NameNode，通过ClientProtocol协议与NameNode交互。而DataNode使用DatanodeProtocol协议与NameNode交互。一个远程过程调用(RPC)模型被抽象出来封装ClientProtocol和Datanodeprotocol协议。</p>

<!--more-->


<p>通常，一个HDFS Cluter由一个NameNode和多个DataNode组成，且在大多数情况下，会由一台专门的机器运行NameNode实例。下图是HDFS的High Level Architecture：
<img class="center" src="/images/2013/02/hdfs01.gif"></p>

<div align="center">本图来自<a href="http://www.ibm.com/developerworks/library/wa-introhdfs/">IBM DeveloperWorks</a></div>


<p>注意，在这个架构图中，观察各节点之间的通信，容易造成一个误解是NameNode会直接与DataNode通信。实则不然。虽然，NameNode可以看做是DataNode的管理者甚至是仲裁者，但由于DataNode的数量通常很多，且都是分布式部署在不同的机器上，若NameNode需要主动发起对各个DataNode的请求，会导致NameNode的负载过大，且对于网络的要求也极高。因此，在设计上，NameNode不会主动发起RPC，而是响应来自客户端或Datanode的RPC请求。如果NameNode需要获得指定DataNode的信息，则是通过DataNode调用函数后的一个简单返回值。每个DataNode都会维护一个开放的Socket，以支持客户端代码或其他DataNode的读写请求。NameNode知道该Socket的Host与Port。</p>

<p><img class="left" src="/images/2013/02/hdfs02.png">
一个好的架构必然遵循了好的架构原则。HDFS架构有许多值得我们借鉴或参考的设计决策，其中它所遵循的架构原则，对HDFS满足架构目标起到了决定性的作用。这些原则包括：元数据与数据分离；主/从架构；一次写入多次读取；移动计算比移动数据更划算。</p>

<h4>元数据与数据分离</h4>

<p>这主要体现在NameNode与DataNode之分，这种分离是HDFS最关键的架构决策。这两种节点的分离，意味着关注点的分离。对于一个文件系统而言，文件本身的属性（即元数据）与文件所持有的数据属于两个不同的关注点。一个简单的例子是文件名的更改。如果不实现分离，针对一个属性的修改，就可能需要对数据块进行操作，这是不合理的。如果不分离这两种节点，也不利于文件系统的分布式部署，因为我们很难找到一个主入口点。显然，这一原则是与后面提到的主/从架构是一脉相承的。</p>

<p>NameNode负责维护文件系统的名字空间，任何对文件系统名字空间或属性的修改都将被NameNode记录下来。NameNode会负责执行与文件系统命名空间的操作，包括打开、关闭、重命名文件或目录。它同时还要负责决定数据块到DataNode的映射。从某种意义上讲，NameNode是所有HDFS元数据的仲裁者和资源库。</p>

<p>DataNode则负责响应文件系统客户端发出的读写请求，同时还将在NameNode的指导下负责执行数据库的创建、删除以及复制。</p>

<p>因为所有的用户数据都存放在DataNode中，而不会流过NameNode，就使得NameNode的负载变小，且更有利于为NameNode建立副本。</p>

<h4>主/从架构</h4>

<p>主从架构表现的是Component之间的关系，即由主组件控制从组件。在HDFS中，一个HDFS集群是由一个NameNode和一定数目的DataNode组成。NameNode是一个中心服务器，负责管理文件系统的名字空间(namespace)以及客户端对文件的访问。集群中的DataNode一般是一个节点一个，负责管理它所在节点上的存储。</p>

<h4>一次写入多次读写</h4>

<p>一次写入多次读写，即Write Once Read Many，是HDFS针对文件访问采取的访问模型。HDFS中的文件只能写一次，且在任何时间只能有一个Writer。当文件被创建，接着写入数据，最后，一旦文件被关闭，就不能再修改。这种模型可以有效地保证数据一致性，且避免了复杂的并发同步处理，很好地支持了对数据访问的高吞吐量。</p>

<h4>移动计算比移动数据更划算</h4>

<p>移动计算比移动数据更划算，即moving computation is cheaper than moving data。对于数据运算而言，越靠近数据，执行运算的性能就越好，尤其是当数据量非常大的时候，更是如此。由于分布式文件系统的数据并不一定存储在一台机器上，就使得运算的数据常常与执行运算的位置不相同。如果直接去远程访问数据，可能需要发起多次网络请求，且传输数据的成本也相当客观。因此最好的方式是保证数据与运算离得最近。这就带来两种不同的策略。一种是移动数据，另一种是移动运算。显然，移动数据，尤其是大数据的成本非常之高。要让网络的消耗最低，并提高系统的吞吐量，最佳方式是将运算的执行移到离它要处理的数据更近的地方，而不是移动数据。</p>

<p>HDFS在改善吞吐量与数据访问性能上还做出了一个好的设计决策，就是数据块的Staging。当客户端创建文件时，并没有立即将其发送给NameNode，而是将文件数据存储到本地的临时文件中。这个操作是透明的，客户端不会觉察，也不必关心。文件的创建事实上是一个流数据的写，当临时文件累计的数据量超过一个数据块大小时，客户端才会联系NameNode。NameNode将文件名插入文件系统的层次结构中，并且分配一个数据块给它。然后返回Datanode的标识符和目标数据块给客户端。接着，客户端将这块数据从本地临时文件上传到指定的Datanode上。当文件关闭时，在临时文件中剩余的没有上传的数据也会传输到指定的Datanode上。然后客户端告诉Namenode文件已经关闭。此时Namenode才将文件创建操作提交到HDFS的文件系统。这个操作的大致时序图如下所示：
<img class="center" src="/images/2013/02/hdfs03.png"></p>

<p>采用这种客户端缓存的方式，可以有效地减少网络请求，避免大数据的写入造成网络堵塞，进而提高网络吞吐量。</p>
]]></content>
  </entry>
  
</feed>
