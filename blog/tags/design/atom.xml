<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Design | 简单文本]]></title>
  <link href="http://agiledon.github.com/blog/tags/design/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2013-04-18T18:15:09+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[模块间的职责分配]]></title>
    <link href="http://agiledon.github.com/blog/2013/03/03/assigning-responsibility-between-modules/"/>
    <updated>2013-03-03T20:19:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/03/03/assigning-responsibility-between-modules</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/03/module.png"></p>

<p>职责分配不仅限于对象之间。如果将对象看做是细粒度的封装，则模块作为组合多个对象的设计元素，可以看做是粗粒度的封装。倘若在模块之间分配职责失当，带来的影响会比对象职责分配不合理更大。这是因为只要在OO设计中进行了适度的封装，在一定程度上体现了隐藏细节的设计理念，对象的职责分配失当就不会溢出边界，对其余对象不会产生太大的影响。</p>

<p>模块间的职责分配好似对对象进行一种归类，只有属于同一类别的对象才能被分配到一个模块中。这可以说是对“高内聚”原则的简单理解。注意，模块常常是对架构层次结构的横向切割，不同的模块可能处于不同的逻辑层。因此，大的设计问题可能牵涉到分层问题。从架构层面来讲，或许我们有必要在获得模块的详细设计之前，审慎地给出一个系统逻辑架构，会有助于模块间的职责分配。</p>

<!--more-->


<p>与对象职责分配一样，模块间的职责分配也有“坏味道”存在。常见的坏味道就是“循环依赖”，即模块A依赖模块B，模块B依赖模块C，模块C又依赖模块A。这有点像三角恋爱关系，扯不清，理还乱，让人头疼。所以我的一个设计实践，就是从设计一开初，就要绘制软件系统的包图，通过直观的图形来帮助我们识别这种依赖的乱麻。</p>

<p>另一种坏味道我称之为“爱屋及乌”，简单说来，其实就是违背了Robert Martin提出的“包复用原则”，即一个包为了使用另一个包的某一个特性，必须把整个包都放进来，哪怕这个包中的其他特性对于使用的包而言完全无用。这就好像我贪恋钱财，娶了一个垂垂老矣的富婆，为了钱，也不在乎丑陋的容颜和高我数倍的年龄了。</p>

<p>例如在我之前设计的一个系统中，出现了这样的包图：
<img class="center" src="/images/2013/03/module01.png"></p>

<p>该系统属于基于元数据的报表系统，engine.report包负责读取定义在配置文件中的报表模板，并在运行时绑定数据，最终输出报表。报表的数据则由engine.data包来承担，它会根据配置的元数据生成SQL语句，访问数据库，动态得到报表所需的数据。engine.entity是在之后引入的一个包，它承担了类似ORM的功能，能够将engine.data包返回的数据，通过配置的映射信息，生成Entity对象。而该Entity对象则作为报表数据绑定的基本元素。至于tool.reportdesigner，则是一个Swing界面的报表设计器应用程序，用户通过界面的设计操作，可以生成我们需要的报表模板。</p>

<p>倘若没有绘制这个包图，而是直接阅读代码，或许很难发现这其中蕴含的设计问题。包图清晰直观，首先我们看到了engine.report与engine.entity之间存在双向依赖（它是循环依赖的特殊形式），并在engine.report、engine.entity与engine.data三者之间发现了循环依赖。其次，我们发现tool.reportdesigner依赖于engine.report，但由于它只负责报表模板的设计，并不需要engine.report包中的运行时数据绑定，以及报表导出功能。显然，前者违背了“循环依赖”，后者违背了“爱屋及乌”。</p>

<p>究其原因，我们发现罪魁祸首就在于engine.report包中的xml组件。该组件的功能与配置相关，其中还包含了许多配置在xsd文件中自动生成的jaxb对象。它并不仅仅是Report独有的功能，相反，这个包图的所有包事实上都需要用到这个功能。换言之，这些包均需要依赖于xml。最简洁的改进方案就是将它抽离出来，放到一个单独的包中。改进后的包图如下：
<img class="center" src="/images/2013/03/module02.png"></p>

<p>为何我将xml设计为infrastructure.xml包？这完全是因为依赖的关系。假设我们将每个依赖都设置其权值为1，则一个包被依赖得越多，其依赖权值就越大。假设这些权值就等同于重量，然后我们设想将这些包都丢到一湖秋水中，分次浮沉。显然，权值越多的包就会慢慢沉淀下去，而权值越少的包最后会浮在上面。我称这种现象为“依赖沉淀”。通过这种方式，可以在一定程度上帮助我们对软件系统的层进行有效划分。
<img class="center" src="/images/2013/03/module03.png"></p>

<p>依赖管理是开发者可能面临的地狱。如果还加上对各种版本包的依赖，这个地狱就可能处于十八层的水深火热中了。依赖管理是一个大课题，但如果模块间的职责分配合理，或许会是一个不错的开始。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阅读的设计体悟]]></title>
    <link href="http://agiledon.github.com/blog/2013/03/02/harvest-from-reading/"/>
    <updated>2013-03-02T21:46:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/03/02/harvest-from-reading</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/03/jsbookcover.jpg">
不管语言的变化有多大，关于程序设计的基本编程思想和设计本质，应是殊途同归。两年前阅读了Jonathan Snook的著作《Javascript捷径教程Accelerated DOM Scripting with Ajax, APIs, and Libraries》。在书中，他带领读者构建了一个简单的动画对象。简单的例子，轻描淡写的描述，却似乎展现了朴素的基本设计思想。</p>

<!--more-->


<p>下面记录了一些阅读感悟。例如，书中这样写道：
<blockquote><p>页面里要用到的动画对象一般都不止一个，所以应该把它定义成一个类。定义一个有5个参数的函数：要加上动画的元素、要改变的属性、属性的起始值、属性的结束值、动画的持续时间。<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">duration</span><span class="p">){}</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></p><p><p>不管编写什么代码，都应该先把实现想透彻。每个决定都有正反两方面的后果，你应该想清楚每个决定的原因。</p></blockquote></p>

<p>这代表一个朴素的思想，那就是从实现原理来进行设计决定。注意这里的实现原理，并不是要关注实现的细节，而是要考虑影响实现的因素，并从调用者的角度思考接口或函数的输入与输出值。以本例而言，如果事先不明确动画效果的营造方式，是根据时间的变化动态变更element属性的方式来完成，就无法确定Animation函数。设计不是空中楼阁，抽象固然是重要的，但功能实现的基本原理仍然需要事先思考通透，否则，设计就可能走弯路。拿到一个功能，先要弄清楚它的目标是什么，有没有质量属性的要求，未来的变化如何，还有这一功能的实现原理。例如，我们要提供服务定制的功能，就需要实现明确“服务”的定义，如何完成服务的注册，服务的发布，服务的订阅，谁会订阅这些服务，服务的安全如何保障，如何解决服务与实现的脱耦。只有把这些问题想清楚了，设计才会靠谱。
<blockquote><p>看看前面的代码，元素ID是作为一个字符串传递进来的，那么在动画对象中获取该元素就有两种方法：一是通过DOM方法document.getElementById()；二是采用Javascript库的调用，如${}。……既然我们想让这个动画对象能适合各种情况，那还是用DOM方法比较好，保证它不依赖于任何库。<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span><br/></span><span class='line'><span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">ducument</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span><br/></span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">el</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></blockquote></p>

<p>这段话仍然体现了一种设计决策。它的实现目标是不与任何JS库耦合。这就需要保证实现的通用性。
<blockquote><p>要是你打算执行动画的元素没有ID怎么办呢？为了让这个类更灵活，让我们把它改成既可以传入元素引用，又可以传入ID字符串。如果传入的是ID字符串而不是对象引用，程序就会通过DOM方法去获取元素。两全其美！<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">element</span><span class="p">,</span> <span class="nx">property</span><span class="p">,</span> <span class="nx">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">,</span> <span class="nx">duration</span><span class="p">)</span><br/></span><span class='line'><span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">element</span><span class="p">;</span><br/></span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="k">typeof</span> <span class="nx">el</span> <span class="o">==</span> <span class="s1">&#39;string&#39;</span><span class="p">)</span> <span class="nx">el</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="nx">element</span><span class="p">);</span><br/></span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">el</span><span class="p">)</span> <span class="k">return</span> <span class="kc">false</span><span class="p">;</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></blockquote></p>

<p>这又是一种编码修炼了。除了要在设计上保证灵活性之外，我们在编码时也需养成保证代码完整性与健壮性的习惯，并体贴地为调用者着想。有这么一条设计原理，就是伯斯塔尔法则(Postel's Law)：“发送时要保守；接收时要开放。”这里的实现无疑遵循了这样一个法则。我们在编码时，考虑到这些因素了吗？</p>

<p>Ok，继续我们的阅读。
<blockquote><p>实例化一个对象要用到5个参数，但一眼看上去很难看出参数里的那些数字都代表什么含义。……为此你可以把参数改成字面量对象，键的名称看起来更直观一些。而且如此改动能使API更加灵活，因为即使今后增加了更多的参数，实例化对象的代码也不会变得更复杂。<br/><div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">function</span> <span class="nx">Animation</span><span class="p">(</span><span class="nx">options</span><span class="p">)</span><br/></span><span class='line'><span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="kd">var</span> <span class="nx">el</span> <span class="o">=</span> <span class="nx">options</span><span class="p">.</span><span class="nx">element</span><span class="p">;</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">}</span><br/></span><span class='line'><span class="kd">var</span> <span class="nx">options</span> <span class="o">=</span> <span class="p">{</span><span class="o">&lt;</span><span class="err">/p&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">pre</span><span class="o">&gt;&lt;</span><span class="nx">code</span><span class="o">&gt;</span><span class="nx">element</span><span class="o">:</span><span class="nb">document</span><span class="p">.</span><span class="nx">getElementById</span><span class="p">(</span><span class="s1">&#39;elementId&#39;</span><span class="p">),</span><br/></span><span class='line'><span class="nx">property</span><span class="o">:</span> <span class="s1">&#39;left&#39;</span><span class="p">,</span><br/></span><span class='line'><span class="nx">from</span><span class="o">:</span><span class="mi">0</span><span class="p">,</span><br/></span><span class='line'><span class="nx">to</span><span class="o">:</span><span class="mi">200</span><span class="p">,</span><br/></span><span class='line'><span class="nx">duration</span><span class="o">:</span><span class="mi">1000</span><br/></span><span class='line'><span class="o">&lt;</span><span class="err">/code&gt;&lt;/pre&gt;</span><br/></span><span class='line'><br/></span><span class='line'><span class="o">&lt;</span><span class="nx">p</span><span class="o">&gt;</span><span class="p">};</span><br/></span></code></pre></td></tr></table></div></figure></notextile></div></p></blockquote></p>

<p>无疑，这体现了面向对象的“封装”思想。通过封装既保证了代码的清洁与可读性，同时还有利于未来的扩展。这与OCP（开放-封闭原则）是一脉相承的。代码是有结构的，或者体现为函数，或者体现为对象，事实上都是一种按照属性与职责进行的分类。分类是保持清洁、避免重复的唯一法门。从简朴的角度来说，所有的设计其实都是在做着分类的游戏。分类体现了定义的抽象，职责的分配，结构的划分；如果再加上类别之间的协作，就是设计的全部了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[职责与封装]]></title>
    <link href="http://agiledon.github.com/blog/2013/02/20/responsibility-and-encapsulation/"/>
    <updated>2013-02-20T21:49:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/02/20/responsibility-and-encapsulation</id>
    <content type="html"><![CDATA[<p>面向对象设计的关键，我认为是识别职责，封装合理的对象。缺乏合理的封装，就会缺少正确的领域对象，使得属于共同职责的领域信息散乱分布到系统的各个方法中，导致概念不够清晰，职责混乱，以及代码的重复。然而，如果没有正确地识别职责，又可能导致封装无从谈起，因为我们获得的需求可能是散乱的，既难以抽象概念，又缺乏层次。故而，职责与封装是相辅相成的概念。如下图所示：
<img class="center" src="/images/2013/02/responsibility01.png"></p>

<p>我们不能简单地将封装当做是“信息隐藏”。所谓隐藏信息以及具体行为的细节，确实是封装的本质所在，但面向对象思想中的封装，其目的还在于对领域概念以及设计概念的识别。前者是对业务模型的抽象，如电子商务系统中的Product、Order、OrderItem等概念；后者是对设计模型的改进，如在设计模式中引入策略对象、命令对象，DDD中提倡的Repository、Factory对象。这也是为何许多设计者很容易理解封装的概念，但却始终无法做到合理封装的根本原因。</p>

<!--more-->


<p>此时，我们需要运用职责驱动设计，通过对职责的识别来提炼这些概念。概念可以起到分类的作用，根据职责对行为与数据进行分类，找到其应该归属的对象，散乱的逻辑就会变得清晰起来。就好似我们对彩球按照颜色进行分类，并放置到不同的位置：
<img class="center" src="/images/2013/02/responsibility02.png"></p>

<p>不同的颜色有分明不同的特征，只要不是色盲，分类自然水到渠成。现实中的系统需求自然不如颜色这般泾渭分明，要从纷繁复杂的混沌需求中超脱出来，最好的办法就是按照不同的角度或层次去寻找职责，并用最简单的语言一句话描述这些职责。根据职责的特征，我大致将职责分为三个层次，由外自内分别为：业务价值、业务功能与业务实现，如下图所示：
<img class="center" src="/images/2013/02/responsibility03.png"></p>

<p>业务价值基本上体现了这个需求用例（或用户故事）存在的目的，即解释了需求的Why。简言之，只有提供了该职责，则此需求对于客户才是有价值的。这也符合用户故事INVEST原则中的V（Valuable）。没有价值的需求，自然是应该放弃的。故而在识别业务价值时，常常从用户的视角来分析，辨别。</p>

<p>业务价值是职责驱动的入口，因为在寻找到了业务价值之后，我们就可以剖析该价值需要哪些支撑功能（它可以解释需求的What），再由功能继续深入分析，找到实现功能的职责（它可以解释需求的How）。因此，这个模型是一个层层推进的过程。</p>

<p>职责驱动不仅仅可以从文字需求入手，同样可以针对已经实现的代码。甚至我们可以将这种职责驱动看做是一种阅读代码的技巧，通过寻找业务价值，进而分析业务功能和业务实现，对代码形成一个整体的感观，进而通过合理地分配职责改善原有代码。如下代码是《修改代码的艺术》一书中给出的例子：
<div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>import javax.mail.&lt;em>;
</span><span class='line'>import javax.mail.internet.&lt;/em>;&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>public class MailingListServer {&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>public static final String SUBJECT_MARKER = "[list]";
</span><span class='line'>public static final String LOOP_HEADER = "X-LOOP";
</span><span class='line'>
</span><span class='line'>public static void main(String[] args) {
</span><span class='line'>    if (args.length != 8) {
</span><span class='line'>        System.err.println("Usage: java MailingList &lt;popHost&gt; " + 
</span><span class='line'>        "&lt;smtpHost&gt; &lt;pop3user&gt; &lt;pop3password&gt; &lt;smtpuser&gt; &lt;smtppassword&gt; &lt;listname&gt; " +
</span><span class='line'>        "&lt;relayinterval");
</span><span class='line'>    }
</span><span class='line'>    return;
</span><span class='line'>
</span><span class='line'>    HostInformation host = new HostInformation(arg[0]);
</span><span class='line'>    String listAddress = args[6];
</span><span class='line'>    int interval = new Integer(args[7]).intValue();
</span><span class='line'>    Roster roster = null;
</span><span class='line'>    try {
</span><span class='line'>        roster = new FileRoster("roster.txt");
</span><span class='line'>    }catch(Exception e) {
</span><span class='line'>
</span><span class='line'>    }
</span><span class='line'>
</span><span class='line'>    try {
</span><span class='line'>        do {
</span><span class='line'>            try {
</span><span class='line'>                Properties properties = System.getProperties();
</span><span class='line'>                Session session = Session.getDefaultInstance(properties, null);
</span><span class='line'>                Store store = session.getStore("pop3");
</span><span class='line'>                store.connect(host.pop3Host, -1, host.pop3User, host.pop3Password);
</span><span class='line'>                Folder defaultFolder = store.getDefaultFolder();
</span><span class='line'>                if (defaultFolder == null) {
</span><span class='line'>                    return;
</span><span class='line'>                }
</span><span class='line'>                Folder folder = defaultFolder.getFolder("INBOX");
</span><span class='line'>                if (folder == null) {
</span><span class='line'>                    return;
</span><span class='line'>                }
</span><span class='line'>                folder.open(FOLDER.READ_WRITE);
</span><span class='line'>                process(host, listAddress, roster, session, store, folder);
</span><span class='line'>            }catch () {
</span><span class='line'>
</span><span class='line'>            }
</span><span class='line'>            try {
</span><span class='line'>                Thread.sleep(interval * 1000);
</span><span class='line'>            } catch() {
</span><span class='line'>
</span><span class='line'>            }
</span><span class='line'>
</span><span class='line'>        } while (true)
</span><span class='line'>    }catch () {
</span><span class='line'>
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>private static void process(
</span><span class='line'>    HostInformation host, String listAddress, Roster roster,
</span><span class='line'>    Session session, Store store, Folder folder) throws MessagingException {
</span><span class='line'>    try {
</span><span class='line'>        if (folder.getMessageCount() != 0) {
</span><span class='line'>            Message[] messages = folder.getMessages();
</span><span class='line'>            doMessage(host, listAddress, roster, session, folder, messages);
</span><span class='line'>        }
</span><span class='line'>    }catch () {
</span><span class='line'>
</span><span class='line'>    }finally {
</span><span class='line'>        folder.close(true);
</span><span class='line'>        store.close();
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>private static void doMessage(
</span><span class='line'>    HostInformation host,
</span><span class='line'>    String listAddress,
</span><span class='line'>    Roster roster,
</span><span class='line'>    Session session,
</span><span class='line'>    Folder folder,
</span><span class='line'>    Message[] messages) throws MessageingException {
</span><span class='line'>    FetchProfile fp = new FetchProfile();
</span><span class='line'>    fp.add(FetchProfile.Item.ENVELOPE);
</span><span class='line'>    fp.add(FetchProfile.Item.FLAGS);
</span><span class='line'>    fp.add("X-Mailer");
</span><span class='line'>    folder.fetch(messages, fp);
</span><span class='line'>    for (int i = 0; i &lt; messages.length; i++) {
</span><span class='line'>        Message message = messages[i];
</span><span class='line'>        if (message.getFlags().contains(Flags.Flag.DELETED)) continue;
</span><span class='line'>        System.out.println("message received: " + message.getSubject());
</span><span class='line'>        if (!roster.constainsOneOf(message.getFrom())) continue;
</span><span class='line'>        MimeMessage forward = new MimeMessage(session);
</span><span class='line'>        Address[] fromAddress = message.getFrom();
</span><span class='line'>        InternetAddress from = null;
</span><span class='line'>        if (fromAddress != null &amp;&amp; fromAdress.length &gt; 0) {
</span><span class='line'>            from = new InternetAddress(fromAddress[0].toString());
</span><span class='line'>        }
</span><span class='line'>        forward.setFrom(from);
</span><span class='line'>        forward.setReplyTo(new Address[] {
</span><span class='line'>            new InternetAddress(listAddress)
</span><span class='line'>        });
</span><span class='line'>
</span><span class='line'>        forward.addRecipients(Message.RecipientType.BCC, roster.getAddresses());
</span><span class='line'>        String subject = message.getSubject();
</span><span class='line'>        if (-1 == message.getSubject().indexOf(SUBJECT_MARKER)) {
</span><span class='line'>            subject = SUBJECT_MARKER + " " + message.getSubject();
</span><span class='line'>        }
</span><span class='line'>        forward.setSubject(subject);
</span><span class='line'>        forward.setSentDate(message.getSentDate());
</span><span class='line'>        forward.addHeader(LOOP_HEADER, listAddress);
</span><span class='line'>        Object content = message.getContent();
</span><span class='line'>        if (content instanceof Multipart) {
</span><span class='line'>            forward.setContent((Multipart)content);
</span><span class='line'>        } else {
</span><span class='line'>            forward.setText((String)content);
</span><span class='line'>        }
</span><span class='line'>
</span><span class='line'>        Properties props = new Properties();
</span><span class='line'>        props.put("mail.smtp.host", host.smtpHost);
</span><span class='line'>
</span><span class='line'>        Session smtpSession = Session.getDefaultInstance(props, null);
</span><span class='line'>        Transport transport = smtpSession.getTransport("smtp");
</span><span class='line'>        transport.connect(host.smtpHost, host.smtpUser, host.smtpPassword);
</span><span class='line'>        transport.sendMessage(forward, roster.getAddresses());
</span><span class='line'>        message.setFlag(Flags.Flag.DELETED, true);
</span><span class='line'>    }
</span><span class='line'>}
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>}</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>这段代码集中了所有劣质代码的特性，如可读性差，可测试性差，可重用性差，可扩展性差，也很难体现设计者的意图。</p>

<p>是的，意图！意图就是体现业务价值的关键所在，最好能够通过类的名称直接传达这种业务价值。显然，上述代码完全没有做到这一点。通过仔细阅读这段代码，然后从职责的角度入手，就驱使我们思考它究竟做了什么？显然，这段代码的功能就是侦听邮件服务器，并根据实现给定的邮件名单，将收到的邮件转发给邮件名单的相关人士。所以，它的业务价值就是转发邮件。</p>

<p>要做到转发邮件，基本的功能是要能够侦听邮件服务器。我们可以将侦听看做是业务功能。通常，对于实际的需求而言，职责模型并非简单的三层结构，它可能是一种递归的方式，也即可以对业务价值、业务功能甚至业务实现进行不断深入的分解。例如，对于这里的侦听业务功能而言，还可以分解为下一个业务功能，即接收邮件。同时，要实现邮件的转发，还需要发送邮件的支撑。下面就是我们所能够识别出来的职责：</p>

<pre><code>* 转发邮件
    ** 侦听邮件
        *** 接收邮件
    ** 发送邮件
</code></pre>

<p>面对如此简短的职责描述，再要识别对象所要封装的概念就变得非常容易了。下图是根据识别出来的职责获得的类图结构：
<img class="center" src="/images/2013/02/responsibility04.png"></p>

<p>比较这个设计模型与之前的代码，新的模型无疑在职责分配上占了胜场。并且，每个对象的名称都很好地传达了它所能完成的功能。由于封装将职责的实现细节有效地隐藏，并为它们各自划分了空间，形成各自的职责单元，然后再以弱耦合的形式进行协作。因而，我们可以很容易地对它们进行单元测试，或者对参与协作的行为进行Mock。接口的引入则是为了未来的功能扩展，例如我们不再使用javax.mail库来实现邮件收发，就可以提供不同的实现类。可独立封装的MessageReceiver与MessageSender还可以为系统的其他模块所重用。职责与封装相得益彰，有效地改善了整个设计模型。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HDFS的架构]]></title>
    <link href="http://agiledon.github.com/blog/2013/02/16/architecture-of-hdfs/"/>
    <updated>2013-02-16T15:33:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/02/16/architecture-of-hdfs</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/2013/02/hdfs.jpg">
HDFS(Hadoop Distributed File System)作为<a href="http://hadoop.apache.org">Hadoop</a>下的一个子项目，是目前使用极为广泛的分布式文件系统。它的设计目的是提供一个高容错，且能部署在廉价硬件的分布式系统；同时，它能支持高吞吐量，适合大规模数据集应用。这一目标可以看做是HDFS的架构目标。显然，这样的架构设计主要还是满足系统的质量属性，包括如何保证分布式存储的可靠性，如何很好地支持硬件的水平扩展，如何支持对大数据处理的高性能以及客户端请求的高吞吐量。所以，HDFS的架构设计颇有参考价值，在Hadoop的Apache官方网站上也给出了<a href="http://hadoop.apache.org/docs/current/hdfs_design.html">HDFS的架构指南</a>。在<a href="http://www.aosabook.org/en/index.html">The Architecture of Open Source Applications</a>卷I的第8章也详细介绍了HDFS的架构。</p>

<p>HDFS的高层设计看起来很简单，主要包含NameNode与DataNode，它们之间的通信，包括客户端与HDFS NameNode服务器的通信则基于TCP/IP。客户端通过一个可配置的TCP端口连接到NameNode，通过ClientProtocol协议与NameNode交互。而DataNode使用DatanodeProtocol协议与NameNode交互。一个远程过程调用(RPC)模型被抽象出来封装ClientProtocol和Datanodeprotocol协议。</p>

<!--more-->


<p>通常，一个HDFS Cluter由一个NameNode和多个DataNode组成，且在大多数情况下，会由一台专门的机器运行NameNode实例。下图是HDFS的High Level Architecture：
<img class="center" src="/images/2013/02/hdfs01.gif"></p>

<div align="center">本图来自<a href="http://www.ibm.com/developerworks/library/wa-introhdfs/">IBM DeveloperWorks</a></div>


<p>注意，在这个架构图中，观察各节点之间的通信，容易造成一个误解是NameNode会直接与DataNode通信。实则不然。虽然，NameNode可以看做是DataNode的管理者甚至是仲裁者，但由于DataNode的数量通常很多，且都是分布式部署在不同的机器上，若NameNode需要主动发起对各个DataNode的请求，会导致NameNode的负载过大，且对于网络的要求也极高。因此，在设计上，NameNode不会主动发起RPC，而是响应来自客户端或Datanode的RPC请求。如果NameNode需要获得指定DataNode的信息，则是通过DataNode调用函数后的一个简单返回值。每个DataNode都会维护一个开放的Socket，以支持客户端代码或其他DataNode的读写请求。NameNode知道该Socket的Host与Port。</p>

<p><img class="left" src="/images/2013/02/hdfs02.png">
一个好的架构必然遵循了好的架构原则。HDFS架构有许多值得我们借鉴或参考的设计决策，其中它所遵循的架构原则，对HDFS满足架构目标起到了决定性的作用。这些原则包括：元数据与数据分离；主/从架构；一次写入多次读取；移动计算比移动数据更划算。</p>

<h4>元数据与数据分离</h4>

<p>这主要体现在NameNode与DataNode之分，这种分离是HDFS最关键的架构决策。这两种节点的分离，意味着关注点的分离。对于一个文件系统而言，文件本身的属性（即元数据）与文件所持有的数据属于两个不同的关注点。一个简单的例子是文件名的更改。如果不实现分离，针对一个属性的修改，就可能需要对数据块进行操作，这是不合理的。如果不分离这两种节点，也不利于文件系统的分布式部署，因为我们很难找到一个主入口点。显然，这一原则是与后面提到的主/从架构是一脉相承的。</p>

<p>NameNode负责维护文件系统的名字空间，任何对文件系统名字空间或属性的修改都将被NameNode记录下来。NameNode会负责执行与文件系统命名空间的操作，包括打开、关闭、重命名文件或目录。它同时还要负责决定数据块到DataNode的映射。从某种意义上讲，NameNode是所有HDFS元数据的仲裁者和资源库。</p>

<p>DataNode则负责响应文件系统客户端发出的读写请求，同时还将在NameNode的指导下负责执行数据库的创建、删除以及复制。</p>

<p>因为所有的用户数据都存放在DataNode中，而不会流过NameNode，就使得NameNode的负载变小，且更有利于为NameNode建立副本。</p>

<h4>主/从架构</h4>

<p>主从架构表现的是Component之间的关系，即由主组件控制从组件。在HDFS中，一个HDFS集群是由一个NameNode和一定数目的DataNode组成。NameNode是一个中心服务器，负责管理文件系统的名字空间(namespace)以及客户端对文件的访问。集群中的DataNode一般是一个节点一个，负责管理它所在节点上的存储。</p>

<h4>一次写入多次读写</h4>

<p>一次写入多次读写，即Write Once Read Many，是HDFS针对文件访问采取的访问模型。HDFS中的文件只能写一次，且在任何时间只能有一个Writer。当文件被创建，接着写入数据，最后，一旦文件被关闭，就不能再修改。这种模型可以有效地保证数据一致性，且避免了复杂的并发同步处理，很好地支持了对数据访问的高吞吐量。</p>

<h4>移动计算比移动数据更划算</h4>

<p>移动计算比移动数据更划算，即moving computation is cheaper than moving data。对于数据运算而言，越靠近数据，执行运算的性能就越好，尤其是当数据量非常大的时候，更是如此。由于分布式文件系统的数据并不一定存储在一台机器上，就使得运算的数据常常与执行运算的位置不相同。如果直接去远程访问数据，可能需要发起多次网络请求，且传输数据的成本也相当客观。因此最好的方式是保证数据与运算离得最近。这就带来两种不同的策略。一种是移动数据，另一种是移动运算。显然，移动数据，尤其是大数据的成本非常之高。要让网络的消耗最低，并提高系统的吞吐量，最佳方式是将运算的执行移到离它要处理的数据更近的地方，而不是移动数据。</p>

<p>HDFS在改善吞吐量与数据访问性能上还做出了一个好的设计决策，就是数据块的Staging。当客户端创建文件时，并没有立即将其发送给NameNode，而是将文件数据存储到本地的临时文件中。这个操作是透明的，客户端不会觉察，也不必关心。文件的创建事实上是一个流数据的写，当临时文件累计的数据量超过一个数据块大小时，客户端才会联系NameNode。NameNode将文件名插入文件系统的层次结构中，并且分配一个数据块给它。然后返回Datanode的标识符和目标数据块给客户端。接着，客户端将这块数据从本地临时文件上传到指定的Datanode上。当文件关闭时，在临时文件中剩余的没有上传的数据也会传输到指定的Datanode上。然后客户端告诉Namenode文件已经关闭。此时Namenode才将文件创建操作提交到HDFS的文件系统。这个操作的大致时序图如下所示：
<img class="center" src="/images/2013/02/hdfs03.png"></p>

<p>采用这种客户端缓存的方式，可以有效地减少网络请求，避免大数据的写入造成网络堵塞，进而提高网络吞吐量。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件开发未必等同于盖房子]]></title>
    <link href="http://agiledon.github.com/blog/2013/02/07/comments-on-why-we-should-build-software/"/>
    <updated>2013-02-07T15:13:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/02/07/comments-on-why-we-should-build-software</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/02/sketch.jpg">
微软研究院首席研究员Leslie Lamport发表了文章<a href="http://www.wired.com.edgesuite.net/opinion/2013/01/code-bugs-programming-why-we-need-specs/#more-122883">Why We Should Build Software Like We Build Houses</a>，吐槽了对如今程序员不愿意做分析，画草图，而是直接开始编码的现状。看了这篇文章后，我对Lamport的观点有一些想法，觉得不吐不快。</p>

<p>其实从文章标题以及作者开篇名义提出的问题来看，显然基于一个假设，或者说事先设定的隐喻，那就是用建筑业来形容软件开发。作者认为建筑设计师在修建房屋之前都会绘制一幅详尽的计划（或蓝图），而软件开发人员却并不这样。以两个不同的行业做对比，认为一个行业这么做了，另一个行业不这样做就有问题，这个假设合理吗？虽然，软件行业中所谓Architecture以及Build的概念确乎来自于建筑行业，甚至这种隐喻在许多年前为诸多大师认可，因而提出诸如软件工程等思想；虽然，它山之石可以攻玉，借鉴别的领域的最佳实践，确乎可以帮助软件开发收获灵感，避免去走太多弯路；然而，毕竟二者之间并不能完全划等号。</p>

<!--more-->


<p>作者似乎看到了这一点，担心这一理论站不住脚，于是在文中驳斥了他自己代表其他程序员提出的问题：“They think tearing down walls is hard but changing code is easy, so blueprints of programs aren’t necessary.”以此来说明，既然修改代码比推倒一堵墙要难，那么修建房子尚且要画蓝图，为何编写代码就不画蓝图呢？看起来，这一论断是合乎逻辑性的，但我始终觉得作者一直在混淆Design与Coding这两个概念。</p>

<p>确如作者所说，许多程序员在Coding的时候，并未做太多分析以及画草图的工作，但他似乎忽略了，更多的程序员在Coding之前，其实还经历了大量的Design工作。这个Design工作与Lamport所谓的绘制草图，有何区别呢？即使采用TDD的做法，通常的做法仍然是需要运用分解任务的方式，来分析需求，理清设计思路，以辨别或识别出领域概念，进而合理地分配职责。就我个人而言，很多时候，我也会对领域模型画一些粗略的类图或时序图；而在开发期间，我们也会就软件开发撰写一些文档，并放在团队wiki上共享出来。</p>

<p>这是让我对本文产生疑惑的地方——那就是作者妄图批判的开发软件的做法其实根本算是一种子虚乌有。</p>

<p>我猜测，作者真正想表达的意思是，因为有了Specification，就能更好地理解设计意图，在将来代码产生变化时，也能够参考此文档，以便于更好地修改代码。这一观点并没有错误，但软件业的开发者不是一直这样践行着吗？多数程序员对文档的诟病是：如何同步文档，使得文档表达的内容能够真实反映程序的实现。对这个问题，作者避而不答。然而，这个问题恰恰是建筑业与软件业一个主要的区别。整体而言，软件业更多地是一种演进而迭代的过程，而世界上大多数建筑（不排除有个别例外，但显然这对于软件业而言，却是常态），在建筑设计师完成设计后，不会做出太多的改变。</p>

<p>正是因为文档的这些问题，才有人提出代码即文档，从而开始推动代码的可读性。当然，也是为了更好地应对变化，才会要求代码具有可扩展性。即使如此，也从来不会有人去彻底地否定文档，尤其针对极为复杂的软件系统而言。</p>

<p>因而，我并不觉得这篇文章有何价值。软件业的最大问题并非从业人员不去编写Specification，多数还是沟通交流的问题，如何正确地理解需求，如何正确地理解设计，如何快速地发布可工作的软件，以期得到用户真正满足其内心需求的反馈。更多的问题还包括诸如管理问题，技术难题，部署问题等等。Specification编写的问题或许存在，需要解决的优先级并没有如此之高。</p>
]]></content>
  </entry>
  
</feed>
