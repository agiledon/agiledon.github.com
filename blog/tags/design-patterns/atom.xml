<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: Design Patterns | 逸言]]></title>
  <link href="http://agiledon.github.com/blog/tags/design-patterns/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2015-01-22T09:25:28+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Java设计模式译者序]]></title>
    <link href="http://agiledon.github.com/blog/2013/02/22/preface-of-java-design-patterns/"/>
    <updated>2013-02-22T16:52:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/02/22/preface-of-java-design-patterns</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/02/dpinjava.jpeg">
如今，介绍和讲解设计模式的书籍可谓汗牛充栋。无论是定义、解读、延伸还是扩展，都是基于面向对象的设计原则，用了放大镜对着GOF提出的23种设计模式，如科学解剖一般，剖析每一道脉络，观察每一片纹理，细微至纤毫毕现，真可以说是道尽个中妙处；许多精妙阐述，又如黄钟大吕，振聋发聩，醍醐灌顶。</p>

<p>是否设计模式的精妙之处，业已为这些著作所穷尽？然，又未必尽然！以模式而论，若只局限在这23种模式的范围内，几乎每种模式的变化，都可以被悉心推演出来；每种模式的结构，也已被阐述得淋漓尽致。然而，若论及设计，则如大道苍穹，实则是不可穷尽的。基本上，设计的复杂程度已不亚于一个纷繁的世界，而软件，就是我们要构造的这个世界。</p>

<p>因此，再出现一本讲解设计模式的书，就不足为怪了。那么，它值得你去阅读吗？</p>

<!--more-->


<p>讨论一本书是否值得阅读，应基于书本身的价值去判断，判断的标准则依据读者的目标而定。从读者而非译者的角度看待本书，个人认为，它确乎是有价值的。这些价值主要体现在三个方面。</p>

<p>GOF对于23种设计模式的分类已经深入人心，即众所周知的创建型模式、结构型模式与行为型模式。这一分类浅显易懂，明白无误的表达了模式的意图与适用场景。但是，这一分类仍有不足之处。例如建造者模式除了关注对象的创建之外，还需处理好对象之间的结构；又例如桥接模式对于抽象与实现的解耦，在一定程度上又体现了对行为的抽象；再比如行为模式中的迭代器模式，其实还涵盖了创建迭代器的职责。本书对于设计模式的分类不落窠臼，根据作者对于设计模式的思考，别出心裁地给出了自己的一种分类，即分为接口型模式、职责型模式、构造型模式、操作型模式与扩展型模式。如果仔细阅读和思考这些模式，你会发现这五类分类很好地抓住了相关模式的设计本质。譬如，扩展型模式关注的是代码功能的扩展，因而很自然地就可以把装饰器模式与访问者模式归入这一类。</p>

<p>彰显本书价值的第二方面在于贯穿本书始终的习题练习，作者将其称之为“挑战”。确实如此，这些挑战仿佛是作者故意为读者设定的“陷阱”，“障碍”，是登堂入室所必须跨过的门槛。最关键的一点是，通过这些“挑战”，就从单方面的灌输知识，变成了一定程度的双向互动。作者就像课堂上的老师，提出问题引人思考；读者就是学生，面对老师“咄咄逼人”的提问，必须打起十二分的精神，分析问题，寻找问题的答案。最后，循循善诱的老师给出了自己的解决方案。学生可以相互对比，以便于发现自己在设计上还存在的问题。因此，本书不适合那些惫懒的读者，不适合那些喜欢被动接收知识输入，不善于思考，不善于总结的程序员。</p>

<p>真正让本书获得赞誉的还是本书给出的案例，不过，也很有可能因此收获负面的批评。本书的案例是一个虚拟的真实项目。Oozinoz公司纯属子虚乌有，完全是由作者杜撰出来的一家虚拟公司；但这个案例又如此的真实，既牵涉到复杂的领域逻辑，又面对客户提出的种种需求变化，与我们工作中需要开发的项目何其相似！可能面临的批评是，为了学习设计模式，可能读者还需要成为一名烟火专家。然而，我谨以最谦卑的态度恳求诸位，在满怀怨气、恶毒诅咒作者（也可能包括躺着中枪的译者）之前，先想想我们平时开发的软件，是否存在相似复杂度的领域需求呢？让我们再仔细想想，倘若作者给出一个纯粹编造出来的玩具项目，贴近生活，浅显易懂，学习起来势如破竹，一路通关，是否真的意味着你已经明白如何在真实项目中运用设计模式？窃以为，学习尤其是技术学习，并不都是舒舒服服寓教于乐，躺着，玩着以及笑着也能学好设计模式。你以为的懂，以为的悟，其实还是一种虚妄。你抓住的是水中央的月影，一旦遇到真实案例，就好似石头打破水面的宁静，一切都会破碎。</p>

<p>本书的原版事实上获得了业界的广泛赞誉，同时也是John Vlissides主编的“软件模式”丛书之一。John Vlissides就是著名的GOF其中之一位，可惜他已在多年前离开人世。本书作者是John Vlissides的生前好友，本书内容曾经得到过他的建议。从书的内容来看，部分Java案例显得有些过时；不过，就设计而言，拥有悠久的历史，有时候意味着它可能成为经典。不错，与经典的GOF《设计模式》相比，本书无疑要失色许多。GOF《设计模式》的光芒在于它的开创性。只要是讲解设计模式，没有哪一本书的光芒可以盖过GOF的著作。它就像是一颗恒星，其他有关设计模式的书籍，是围绕着它公转的一颗颗行星，都是借着恒星的光芒反射出属于自己的光亮。 然而，从光芒的热度与亮度来讲，也许行星才是当前的你最适合的。</p>

<p>阅读本书的读者，除了需要具备一些面向对象与设计模式的基础知识外，还需要有足够的耐心，并保存一份渴望与热情。耐心可以帮助你坚持细读与精读，持之以恒地深入理解本书的案例分析，努力面对作者给出的挑战。而这种耐心则需要提高技术能力的渴望，探求技术奥秘的热情来时刻保鲜。</p>

<p>本书的翻译由我的同事史磊与我共同完成，并最后由我完成审校工作。在翻译本书时，我还参考了由龚波、赵彩琳、陈蓓翻译的前一个版本，在此向他（她）们表示衷心地感谢。因为工作繁忙的缘故，本书的翻译工作一直断断续续持续了近一年的时间，如今交稿，既有卸下重任的轻松畅快，却又因为自己的惫懒使得翻译工作进展缓慢而深感愧疚。这里需要感谢本书编辑符隆美女士给予我的耐心与支持。</p>

<p>在写作这篇译者序时，同事史磊已经远赴ThoughtWorks南非工作，而我则从北京回到了ThoughtWorks成都。非常怀念我们在北京Office一起工作的日子。我们曾经在同一个项目结对编程，本书的翻译也可以说是结对完成，算是一次愉快的翻译体验。鉴于本人能力水平有限，翻译或有疏漏或错误，还请读者不吝赐教，并通过<a href="http://aigledon.github.com">我的博客</a>与我联系。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式的一些变化]]></title>
    <link href="http://agiledon.github.com/blog/2013/02/02/change-of-design-patterns/"/>
    <updated>2013-02-02T22:28:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/02/02/change-of-design-patterns</id>
    <content type="html"><![CDATA[<p>经历了几次过度设计，我对一些设计模式开始抱有谨慎的戒惧。我希望能够合理地运用设计模式，而非为模式而模式。事实上，现在的我较少会有意识地运用设计模式；更多地是通过职责来驱动，以期获得合理的职责分配。之后，再通过辨别代码的坏味道，运用重构来改善设计。大多数情况下，这种方式对于设计而言，已经足够。不过，有时我们仍有必要根据具体场景，做出合理判断和决策。</p>

<p>我曾经遭遇的一个Story，是要实现一个Web Service，提供update的服务接口。需求要求对服务的Request进行验证。这一验证功能并非Story的核心功能，但其逻辑却比核心逻辑复杂数倍。它需要针对不同情况，遵循多个规则验证Request。这些验证逻辑如此的复杂，以至于我们可以在第一时间做出判断，它必须是单独的职责，绝对不适合放到Service对象中。</p>

<p>这种职责分离还不够。因为每一条验证规则，都可以视为一个单独的验证职责。若将每种验证规则封装为一个验证对象，就能很好地满足SRP。每个验证对象只需要做好自己的事情即可，结果只有两个，要么错误，要么通过。若当验证逻辑为一个整体，则可以理解为：只要违背了一条验证规则，出现错误，则可以视为验证不通过；否则将继续验证下一条规则。</p>

<!--more-->


<p>乍一看来，这完全符合职责链模式的要求。我的Pair也完全同意了这一点。当我们按照这一思路进行编码时，我的疑惑随着步伐的前进，变得愈深，好像有什么东西在拽着自己，阻止我们前进。因为我们使用了Spring，故而需要将这个职责的链条通过依赖注入的方式拼接。为了迎合这种要求，标准的职责链模式需要微调。例如，我们写出这样的职责链超类：
``` java
public abstract class UpdateRequestValidator {</p>

<pre><code>private UpdateRequestValidator nextValidator;
public UpdateRequestValidator(UpdateRequestValidator nextValidaor) {
    this.nextValidator = nextValidator;
}

public ValidateResult validate(UpdateRequest request) {
    ValidateResult result = doValidate();
    if (result.isError()) {
        return result;
    }
    return nextValidator.validate();
}

protected abstract ValidateResult doValidate();
</code></pre>

<p>}
```</p>

<p>如果仔细分析这段代码，可以发现我们是在运用装饰器模式的手法来实现职责链。这就让人感到奇怪了。由于我们自定义了构造函数，要求传入一个UpdateRequestValidator，似乎可以避免对nextValidator非空的判断。可是，链条的末尾又该放入哪个对象呢？为此，我们还定义了一个NullValidator，它什么都不做，并被要求放到职责链构造的最末尾。</p>

<p>够奇怪吧。这里我们对Spring的配置做出了假设，一厢情愿地要求NullValidator必须作为职责链的最后一个。可是，我们却未对这种假设做出任何约束。</p>

<p>与其如此别扭，还不如对设计做出调整。只要验证逻辑的职责分离与封装是合理的，我们未必一定要运用职责链模式（或者这种不伦不类的装饰器模式）。抛开这种约束后，每个Validator就可以变得更单纯，无需假设这个链条的组成；而是将这个链式逻辑转交给包含了UpdateRequestValidator列表对象的Validator对象，它可以被看成是Validator的合成对象：
``` java
public interface UpdateRequestValidator {</p>

<pre><code>ValidateResult validate(UpdateRequest request);
</code></pre>

<p>}
public class CustomerNotFoundValidator implements UpdateRequestValidator {</p>

<pre><code>@Override
public ValidateResult validate(UpdateRequest request) {
    //do something;
}
</code></pre>

<p>}
public class CompositeUpdateRequestValidator implements UpdateRequestValidator {</p>

<pre><code>private List&lt;UpdateRequestValidator&gt; validators;
@Required
public void setValidators(List&lt;UpdateRequestValidator validators) {
    this.validators = validators;
}
@Override
public ValidateResult validate(UpdateRequest request) {
    ValidateResult result;
    for (UpdateRequestValidator validator : validators) {
        result = validator.validate(request);
        if (result.isError()) {
            return result;
        }
    }
    return result;
}
</code></pre>

<p>}
```</p>

<p>我觉得修改后的设计意图清晰许多了，并且，它对使用者没有了隐含的约束，在Spring的ApplicationContext配置文件中，也能够很好地将我们单独实现的Validator作为List的元素配置给CompositeUpdateRequestValidator。我喜欢这样的调整。</p>

<p>我对装饰器模式持同样态度。正如有人说道：装饰器模式的方式有些像洋葱。洋葱的味道虽好，不过在剥洋葱时，却要小心不要被呛出眼泪。在阅读<a href="http://www.axonframework.org">Axon Framework</a>的源代码时，我发现一种设计方式，可以避免装饰器模式的洋葱构造，却能达到同样的装饰效果。我将其成为Interceptor模式。</p>

<p>需求是希望对CommandHandler对象的命令请求进行包装（或装饰），例如为命令请求提供日志或事务功能。这些功能可以是组合的。传统的方式是运用装饰器模式，例如：
``` java
public interface CommandHandler {</p>

<pre><code>void handle();
</code></pre>

<p>}
public class LoggingCommand implements CommandHandler{</p>

<pre><code>private CommandHandler commandHandler;
public LoggingCommand(CommandHandler commandHandler) {
    this.commandHandler = commandHandler;
}

@Override
public void handle() {
    logInfo("begin execute command");

    commandHandler.handle();

    logInfo("end execute command");
}
</code></pre>

<p>}
public class TransactionCommand implements CommandHandler {</p>

<pre><code>private CommandHandler commandHandler;
public TransactionCommand(CommandHandler commandHandler) {
    this.commandHandler = commandHandler;
}

@Override
public void handle() {
    myTransaction.beginTransaction();
    try {
        commandHandler.handle();
        myTransaction.commitTransaction();
    } catch (Exception ex) {
        myTransaction.rollbackTransaction();
    }
}
</code></pre>

<p>}
```</p>

<p>假设有一个命令对象PlaceOrderCommandHandler，同时需要日志和事务功能，就需要如下构造方式：
<code>java
CommandHandler command = new TransactionCommand(new LoggingCommand(new PlaceOrderCommandHandler()));
</code></p>

<p>这种构造方式既复杂，也不容易使用Spring来注入。Axon的设计方式转变了设计视角，将这种对命令的包装，看做是对命令请求的一种拦截，这就好似AOP的pointcut一般。它定义了一个InterceptorChain，负责完成整个拦截器链条的组装，并将这些拦截职责通过Chain完成一层层的传递。设计如下：
``` java
public interface CommandHandlerInterceptor {</p>

<pre><code>void handle(InterceptorChain interceptorChain);
</code></pre>

<p>}
public class LoggingInterceptor implements CommandHandlerInterceptor {</p>

<pre><code>@Override
public void handle(InterceptorChain interceptorChain) {
    info("LOG: begin");
    interceptorChain.proceed();
    info("LOG: end");
}
</code></pre>

<p>}
public class TransactionInterceptor implements CommandHandlerInterceptor {</p>

<pre><code>@Override
public void handle(InterceptorChain interceptorChain) {
    transaction.beginTransaction();
    try {
        interceptorChain.proceed();
        transaction.commitTransaction();
    } catch (Exception ex) {
        transaction.rollbackTransaction();
    }


}
</code></pre>

<p>}
public class InterceptorChain {</p>

<pre><code>private Iterator&lt;? extends  CommandHandlerInterceptor&gt; interceptorChain;
private CommandHandler handler;

public void proceed() {
    if (interceptorChain.hasNext()) {
        interceptorChain.next().handle(this);
    }

    handler.handle();

}

@Required
public void setHandler(CommandHandler handler) {
    this.handler = handler;
}

@Required
public void setInterceptorChain(Iterator&lt;? extends CommandHandlerInterceptor&gt; interceptorChain) {
    this.interceptorChain = interceptorChain;
}
</code></pre>

<p>}
```</p>

<p>在InterceptorChain类中，handler对象就是我们要包装（或者说拦截）的命令对象。注意，Interceptor对象的handle()方法，是将InterceptorChain对象作为参数传入的。于是就形成了如下的方法调用时序：
<img class="center" src="/images/2013/02/interceptor.png"></p>

<p>只要理解了InterceptorChain起到的委派传递作用，就能很好地理解这个设计。这种方式将之前装饰器模式那种洋葱式的构造转移到列表中，并通过迭代器进行迭代。同时，它将对CommandHandler以及相关拦截器对象的依赖转移到了外面，很好地支持IoC容器对依赖的注入，从而使得代码可以变得更简单，更灵活。</p>

<p>总之，当我们在运用设计模式时，一定要结合当前上下文，对设计模式做出合理的判断，甚至可以大胆地对GOF总结的设计模式进行大刀阔斧地挑战或修改。关键还在于把握设计模式的核心原则，并在“简单设计”的前提下，做出设计的决策。</p>
]]></content>
  </entry>
  
</feed>
