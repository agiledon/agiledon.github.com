<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: FP | 逸言]]></title>
  <link href="http://agiledon.github.com/blog/tags/fp/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2014-09-25T13:23:42+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Magic Scala(1): Call By Name]]></title>
    <link href="http://agiledon.github.com/blog/2014/06/18/magic-scala-1-call-by-name/"/>
    <updated>2014-06-18T23:57:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/06/18/magic-scala-1-call-by-name</id>
    <content type="html"><![CDATA[<p>在Scala中，调用函数有两种形式：Call by value（按值调用）和call by name（按名称调用）。若是call by value，会先计算参数的值，然后再传递给被调用的函数；若是call by name，参数会到实际使用的时候才计算。例如：
{% codeblock lang:scala %}
val logEnable = false</p>

<p>def log(msg: String) =</p>

<pre><code>if (logEnable) println(msg)
</code></pre>

<p>val MSG = "programing is running"</p>

<p>log(MSG + 1 / 0)
{% endcodeblock %}</p>

<p>此时的log函数是call by value。因此在调用log函数时，会先计算传入的参数，此时会计算MSG + 1/0。由于表达式中有0作为被除数，因此会抛出异常：
{% codeblock %}
Exception in thread "main" java.lang.ArithmeticException: / by zero</p>

<pre><code>    at Main$.main(scala-script352098905369979205.scala:16)
    at Main.main(scala-script352098905369979205.scala)
</code></pre>

<p>exit value is 1
Program exited.
{% endcodeblock %}</p>

<p>如果修改log的定义为：
{% codeblock lang:scala %}
def log(msg: => String) =</p>

<pre><code> if (logEnable) println(msg)
</code></pre>

<p>{% endcodeblock %}</p>

<p>当调用log函数：log(MSG + 1/0)时，它首先并不会计算MSG + 1/0表达式，而是先执行log的函数体，即判断logEnable的值。此时logEnable值为false，此时就不会执行该分支println(msg)。既然不会执行println，就不会计算MSG + 1/0。因此就不会抛出异常。</p>

<p>再看另外一个例子。首先定义一个函数：
{% codeblock lang:scala %}
def getOneWhatever():Int = {</p>

<pre><code> println("calling getOneWhatever")
 1
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>然后，再定义两个函数，分别用call by value和call by name的方式：
{% codeblock lang:scala %}
def callByValue(x: Int) = {</p>

<pre><code> println("x1=" + x)
 println("x2=" + x)
</code></pre>

<p>}</p>

<p>def callByName(x: => Int) = {</p>

<pre><code> println("x1=" + x)
 println("x2=" + x)
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>如果执行callByValue(getOneWhatever())，则结果为：
{% codeblock %}
calling getOneWhatever
x1=1
x2=1
{% endcodeblock %}</p>

<p>若执行callByName(getOneWhatever())，则结果为：
{% codeblock %}
calling getOneWhatever
x1=1
calling getOneWhatever
x2=1
{% endcodeblock %}</p>

<p>注意看二者的区别，采用by name的方式，getOneWhatever函数被执行了两次，这是因为在callByName函数中，传入的参数被调用了两次。</p>
]]></content>
  </entry>
  
</feed>
