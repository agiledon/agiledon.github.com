<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | 逸言]]></title>
  <link href="http://agiledon.github.com/blog/categories/design/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2014-10-08T21:36:16+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计中的变与不变]]></title>
    <link href="http://agiledon.github.com/blog/2014/10/08/change-and-stable-of-design/"/>
    <updated>2014-10-08T20:51:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/10/08/change-and-stable-of-design</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2014/thinking.jpg"></p>

<p>古希腊哲学家巴门尼德认为：“人的思想和言语都有一个载体，如果你在这一时间和另外一个时间想到或者谈到同样一件东西，那就说明这件东西在这段时间内没有变化，如有变化的话，你说的就不是同一件东西。”</p>

<p>这让我想起对象的实例。在面向对象设计中，默认情况下并没有约束类的实例是否为可变，这意味着我们可以通过某种方式改变实例的状态。这体现了实例的可变特征。然而，若是站在内存的角度观察实例，则又不然。无论它在内存中存储的状态如何变化，该实例的对象标识依旧是保持不变的。显然，变与不变是相对的。</p>

<p>切换到DDD的命题中，所谓“实体”就是那种具有唯一的可识别可跟踪ID的对象。这个ID并非程序语言在内存中为它分配的对象标识，而是从领域角度来看，由设计者为其识别，由创建者为其分配，因而具有领域语义。实体的状态当然是可变的，然而实体ID在这个实体的生命周期中却是不可变的。</p>

<p>与之相对的是值对象。在DDD中，强调将领域对象严格区分为实体和值对象。一个指导原则是，当你无法分辨某个领域对象究竟是实体还是值对象时，应优先将其建模为值对象。这有助于我们更好地利用值对象的不可变性。</p>

<p>不可变的对象能够更好地维护，因为你不用操心它的值变化，也无需追踪变化的轨迹。不变性天生支持并发。这就衍生出面向对象设计中的Immutable模式。例如Java和C#中的String类型，皆为Immutable模式的实现。</p>

<p>可若放在函数式编程中，这种模式就显得有些可笑了。尤其在纯函数式编程的世界里，任何东西都应该是不变的。</p>

<p>这种不变意味着只要它存在，就不可修改，而且恒古不变。这种追究变化背后的不变性，一直是古希腊哲学乃至科学的基本原则。物质是否永恒不变，在哲学中一直是引人深思的命题或假设；但在函数式编程中，它几乎被证明了。例如，在Haskell中，对List的任何操作，即使调用++对List进行合并，返回的都是全新的List对象，原有对象不会有任何变化。</p>

<p>罗素在《西方哲学简史》中写道：
有的神秘主义者认为永恒并不是指时间上的永久，它是独立于时间之外的，无前无后、无因无果，也没有逻辑可循。</p>

<p>我觉得函数式编程追求的不变性，可以划入这个范畴。</p>

<p>赫拉克利特说：“人不能两次踏进同一条河流”。这是赫拉克利特终极的哲学观，即万物随时在变。软件系统就是这样一条河流，它无时无刻不在变化，正如水不断的流动，需求也总是在变化。但若抛开原子裂变、放射衰变的科学原理，我们似乎也可以将组成整条河流的每一滴水，看做是不变的基本组成要素。这个要素就是Monad中的Identity（幺元或单位元）。这个Identity表达了单一、恒等的概念，例如Int类型中加减法运算半群（SemiGroup）中的Zero，就是一个Identity，因为半群中的任何元素a与Zero结合，依然是元素a本身。</p>

<p>水是如何组成一条河流的呢？这取决于组合子（Combinator）的设计与组合。只要我们找到万物的基本要素，继而设计出各种组合子，就可以演绎出世间不同的物。例如水滴虽可以组合为河流，却也可以组合为橙汁，只要我们加入橙子的另一个组合子即可。这就是面向组合子（Combinator Oriented）的设计思想。显然，它与面向对象的设计哲学背道而驰。</p>

<p>以哲学史观之，函数式思想更符合古典的朴素哲学观。在古希腊哲学家中，泰勒斯认为世界的元素为水，阿那克西美尼认为世界的元素是气，赫拉克利特认为世界的元素是火，而恩培多克勒则糅合了这些思想，认为世界的元素有土、气、火、水四种。而观中国古代哲学，则有五行学说认为宇宙万物都由金木水火土五种基本特性的运行和变化所构成。</p>

<p>不论构成万物的基本元素为何，这种哲学观不正是函数式编程的设计观吗？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[领域驱动设计中的事件建模]]></title>
    <link href="http://agiledon.github.com/blog/2014/09/25/event-modeling-in-ddd/"/>
    <updated>2014-09-25T12:58:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/09/25/event-modeling-in-ddd</id>
    <content type="html"><![CDATA[<p>这两日，我参加了Implementing Domain Driven Disign一书作者Vaughn Vernon组织的IDDD Workshop。培训中，Vernon带领我们针对Domain Event进行了一次建模工作坊。
<img class="center" src="/images/2014/vernonandme.jpg"></p>

<p>在领域驱动设计中，Domain Event变得越来越重要。在Implementing Domain Driven Disign这本书中，Vaughn Vernon甚至将Domain Event上升到了一等公民的地位。</p>

<p>那么，Domain Event到底是什么？Domain Event即领域事件，是指领域中发生的事实（facts）。当满足某个条件时，某个发起者就会触发事件产生。因而在对事件建模时，我们可以关注统一语言中如下的关键词汇：
<strong>“当…”
“如果发生…”
“当…的时候，请通知我”
“发生…时”</strong></p>

<p>“事件为事实（fact）”这一描述让我对“事件”本身有了更准确的认识。它让我想起两篇发表在InfoQ上的文章。一篇文章为《<a href="http://www.infoq.com/cn/articles/Architecture-Datomic">Datomic的架构</a>》。文中提到：“信息是一组事实（facts），事实是指一些已经发生的事情。鉴于任何人都无法改变过去，这也意味着数据库将累积这些事实，而非原地进行更新。虽然过去可以遗忘，但却是不能改变的。”同理推之，若事件即事实，那么它也是不可改变的。对于这些历史发生的“事实”，我们需要“立此存照”——于是，这就引出了Event Store或者Event Sourcing。我会在后续的文章深入分析Event Store与Event Sourcing。</p>

<p>另一篇文章是徐昊的《<a href="http://www.infoq.com/cn/articles/xh-four-color-modeling">运用四色建模法进行领域分析</a>》。文中表达了类似的思想：“任何的业务事件都会以某种数据的形式留下足迹。我们对于事件的追溯可以通过对数据的追溯来完成。……你无法回到从前去看看到底发生了什么，但是却可以在单据的基础上，一定程度的还原当时事情发生的场景。当我们把这些数据的足迹按照时间顺序排列起来，我们几乎可以清晰的推测出这个在过往的一段时间内到底发生了那些事情。”</p>

<p>在四色建模分析法中，徐昊认为应该将“时标性对象（moment-interval）”作为建模的起点。我在这里并不是要介绍四色建模法，这个话题留待以后再讲。我试图阐释的观点在于，如果事件与时间相关，那么在对事件进行建模时，就可以针对业务场景确定一条时间线，并通过分析业务状态的各种变迁，得到我们希望获得的事件模型。这正是这个工作坊的切入点。</p>

<p>整个事件建模的活动可以分为四个步骤：
1. 选定某个自己熟悉的领域，然后针对时间线去寻找那些用过去时态表现的事件；找到这些事件后，用黄色即时贴写出事件名称，形式如：OrderFilled。
2. 针对每个事件，对触发事件的Command对象进行建模，并用绿色即时贴写出Command的名称。对Command对象进行建模并非单纯地为了寻找Command对象，而是为了更深一步地验证之前建模的事件模型。在思考触发事件的对象时，我们可能会发现一些遗漏又或者多余的事件。
3. 判断这些事件应该属于哪个聚合对象，找到它们，然后写在紫色即时贴上。
4. 对这些识别出来的Event、Command、Aggregate进行分类，判断它们到底属于哪个Bounded Context，并用红色即时贴标出。
<img class="center" src="/images/2014/eventmodeling.jpg"></p>

<p>这种Workshop不仅只针对培训，它更应该运用到团队进行领域驱动设计的过程中。这也正是我一直在提倡的所谓“可视化设计”。可视化设计并非一个噱头，更不是为了美观好看，而是希望以直观简单的形式展现设计思路，尤其需要让整个团队成员都能以协作互动的形式参与到这个设计过程中。群策群力，头脑风暴，如此方能获得更好的设计方案，并以这种团队行为的方式完成知识的共享与传递。其实，“架构”究竟是什么，不就是一种软件设计的知识吗？设计架构，重要在于交流，在于知识传递，而不仅仅是严谨完整的解决方案文档。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[可视化设计工作坊]]></title>
    <link href="http://agiledon.github.com/blog/2014/08/09/visualize-design-workshop/"/>
    <updated>2014-08-09T12:55:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/08/09/visualize-design-workshop</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2014/workshop.jpg">
之所以选择可视化手段来进行软件设计——非UI或UX的设计——是基于我对设计的理解：<strong>设计并非文档，而是交流</strong>。那种依靠一位英雄来完成所有的设计，并编撰为详尽的文档，然后让程序员连蒙带猜按图索骥的设计方式，完全不可取。尤其在一个自组织的开发团队中，我们希望人人都是程序员，人人都是软件设计师，人人都是架构师。</p>

<p>那么，该如何做到充分的交流，就像风吹过树林，不分彼此的摇动每一片树叶？我想到最简单直截的方式：可视化。然而，此可视化非UML之所谓的“一图胜千言”。没错，我们当然需要绘制设计图，而且必须绘制设计图，但我们更希望是以草图的形式，并辅以视觉引导，来推着团队的每个成员，渐进地完善设计，直到抵达设计的真相。我们没有门派偏见，亦不愿邯郸学步，因而我们既信奉“拿来主义”，又会依据设计的本质原则与真谛，进行了细微的创新。创新未必一定是无中生有，“旧瓶装新酒”或是对经典的追随，“新瓶装旧酒”又何尝不能看作是创意的包装！</p>

<p>此次在TID会议上的可视化设计工作坊算是我与姜志辉针对此主题的一次彩排吧。我们从未就此话题有过深度合作，但是，我们对设计的理解是志同道合的，说得肉麻点，有心有灵犀的感觉。下图是整个工作坊的路径缩影：
<img class="center" src="/images/2014/visulaizationdesign.jpg"></p>

<p>我们的主线就是设计的可视化，整个过程我们通过草图、即时贴、画布等多种方式来触发团队成员之间的交流与讨论。至于方法工具箱，则几乎等同于一个大杂烩了。我们使用经典的用例图进行需求分析（我们会以商业画布为需求的起点，因为时间关系省去了此步骤），继而根据用例的边界获得DDD中所谓的Bounded Context。
<img class="center" src="/images/2014/contextmap.jpg"></p>

<p>通过运用DDD的Context Map，我们辨别出Context之间的上下游关系与各种集成方式，继而利用Cockburn的六边形架构以及传统的分层架构，驱动出系统的应用逻辑架构与物理架构。
<img class="center" src="/images/2014/haxagon_workshop.jpg"></p>

<p>然后，我们跳入Context的内部，开始领域建模。我们尝试了两种领域建模方式：健壮性分析与四色建模，以此为起点，我们可以得到粗略的CRC草图，之后就进入了我和姜志辉提出的设计画布。
<img class="center" src="/images/2014/designcanvas.jpg"></p>

<p>我们希望看到的是这样的交流场景，如此才可碰撞出好设计的火花。
<img class="center" src="/images/2014/workshop01.jpg">
<img class="center" src="/images/2014/workshop02.jpg"></p>

<p>可视化设计并非仅能针对一个新系统，或者仅用于设计阶段。</p>

<p>例如，我曾经在客户处通过运用我提出的依赖沉淀图，让团队成员以交流协作的方式完成对遗留系统模块依赖关系的梳理。这种依赖关系梳理虽然可以利用工具来生成，但采用可视化的方式却可以充分保障成员之间的知识共享。它追求的并非只是结果，而是整个协作的过程。又例如，我们也可以在Inception阶段，通过可视化设计来评估风险，或针对候选技术进行Spike，又或者运用六边形架构等方式来梳理系统与周边系统之间的关系，以便于团队理解整个软件产品的生态系统。</p>

<p>其实，这种可视化设计，我更倾向于称之为“体验式设计”，但它与ThoughtWorks提出的XD并非专注同一个层面的内容。当然，这种体验式的软件设计，我还处于试验的摸索阶段。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Struts 1.x一路走好]]></title>
    <link href="http://agiledon.github.com/blog/2013/05/08/farewell-struts-1-dot-x/"/>
    <updated>2013-05-08T22:38:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/05/08/farewell-struts-1-dot-x</id>
    <content type="html"><![CDATA[<p>因为Struts 1.x宣布退出了历史舞台，于是InfoQ组织了一次虚拟访谈。恰好在我现在的项目中，仍然能够看到Struts 1.x的身影，以我这浅薄的Web开发经验，也能有幸被丁雪丰邀请参加了这次虚拟访谈，和李锟、张龙就这一事件畅谈了各自的感受和想法。这篇<a href="http://www.infoq.com/cn/articles/virtual-panel-struts1?utm_source=infoq&amp;utm_medium=popular_links_homepage">虚拟访谈</a>发表在了InfoQ上。这里发布的则是我自己就主持人提出的问题给出的回答。</p>

<p><strong>1. Struts是最早的MVC框架之一，影响了很多人，你是否还记得最早接触到它时，给你留下的印象是什么？</strong></p>

<p><strong>张逸：</strong>从业15年来，我主要参与的开发工作除了早期的Windows Form应用开发外，主要还是集中在后端。用分层的角度来说，即工作在数据层、领域层以及服务层。虽然早已知道Struts的大名，甚至了解到所谓Struts+Spring+Hibernate几乎成为了Java企业开发的标配，却一直没有机会使用Struts。我当时工作的项目主要还是在微软的.NET平台上，经历了从ASP到ASP.NET，再到ASP.NET MVC的过程。在使用ASP时，我很质疑那种业务代码与表现代码混杂在一起的开发方式；而在最初拥抱ASP.NET时，我认为这种Code-Behind会是一种良好的职责分离。然而，ASP.NET在灵活性或扩展性方面带来的约束，使得它越来越不适合富客户端的开发了。于是，才有了借鉴Ruby On Rails思想的ASP.NET MVC出现。或许我的回答偏题了，但我想借ASP的这种发展来看待此次Struts 1.x退出历史舞台的事件，那就是任何产品都会步入晚年的衰落期，跟不上技术的发展，必然会被淘汰，没有什么好奇怪的。</p>

<!--more-->


<p><strong>2. Struts 1.x即将走完最后的历程，对于那些仍在使用它的系统，你有什么建议？如果要升级，有几个备选方案，例如Struts 2.x、Spring MVC等等，你会如何选择？</strong></p>

<p><strong>张逸：</strong>奇怪的是，虽然在早期我不曾有机会使用Struts 1.x，然而我现在正在工作的一个大型项目，因为其漫长的历史，一部分Web前端使用的正好是Struts 1.x。对于这种正在使用它的系统，若要说有何建议，简言之，还是需要在决策时视情况而定。在我们当前项目的一个子系统中，Struts 1.x是与Spring MVC 2.0共存的；而在另一个子系统中，又存在Struts 2.x与Spring MVC 3.x共存的情况。从架构的一致性来看，这是很不合理的；然而就项目的真实情况，我又认为这种现象未尝不可。迁移的成本往往是昂贵的，尤其对于遗留系统而言，若没有覆盖率极高的验收测试，盲目地为了追求架构一致性进行迁移，反而会引入新的问题。这就需要权衡迁移的成本和迁移得到的好处。在Java平台下，可供选择的成熟Web框架并不多，Struts 2.x以及Spring MVC相较于Struts 1.x而言，主要还是体现在模式上的区别，属于侵入性更小、架构更为简单的框架。相对于升级，我更倾向于保留原有框架，对于新增的功能则可以引入更新的框架。若因为种种原因硬要升级，我更倾向于选择Spring MVC，一方面它与Spring框架的集成度更好，学习曲线低；同时它对于Struts 1.x实现方式的固有支持，会使得迁移的成本会降低。最重要的一点是Spring MVC目前还保有一定程度的活力，它的版本还在演化中；相对而言，Struts似乎已经失去活力了。</p>

<p>若抛开这些成熟的Web框架不谈，我的建议是不妨试试Java平台下的其他框架，例如jRails，Spring Roo、Apach Wicket或者Play。若想继续工作在Spring的技术栈下，Spring Roo会是一个有趣的选择。事实上，你可以认为它是Spring所要力推的下一代Web框架，如果你不想重蹈Struts 1.x的覆辙，可以在决策时冒着风险给予提前尝鲜的机会。Play框架是基于Java和Scala开发的Web框架，它似乎更偏重于建造可伸缩性的Web框架。此外，它的安全模块、持久化支持(包括对NoSQL与Big Data的支持)、RESTful以及Mobile的支持，使得它更适合开发当今的Web应用程序。</p>

<p><strong>3. 经常会有框架或软件结束生命周期，不再进行维护，这对使用它的用户多多少少带来了一些困扰，能否聊聊您在项目最初进行选择时的一些经验之谈。</strong></p>

<p><strong>张逸：</strong>对于框架的选择，我比较偏重于框架的简单性和无侵入性这两个特点。简单性可以保证我们快速地理解框架的架构，并能够正确地使用它；无侵入性则使得我们可以避免所谓“供应商锁定”的反模式，在需要迁移框架时，可以尽快摆脱原有框架的约束。当然，这种选择总要结合项目需求，根据风险对各种质量属性进行综合权衡，方能做出合理的设计决策。因此，我会将这两个特点看做是重要的衡量指标，但并非绝对。在一定程度上，我们还可以通过更好的架构设计来规避对框架的依赖，例如通过好的分层设计，或者引入防腐层隔离对框架的依赖。以Struts 1.x而言，只要我们避免在Action中引入业务逻辑，选用新Web框架的成本就会更低一些。同时，保证足够的测试覆盖率是必要的，尤其是足够覆盖率的单元测试与集成测试，它常常可以放缓系统衰老的脚步。对于旧系统的维护或重构而言，测试覆盖率是进行改造的良好基石。</p>

<p><strong>4. 随着像Backbone.js这样的前端MVC框架的流行，Struts这样的服务器端MVC的作用似乎有所减弱，您觉得MVC逻辑“前移”会是今后的发展趋势么？</strong></p>

<p><strong>张逸：</strong>我完全赞同这一点。在我参与的上一个项目中，对于服务端的Web层而言，几乎就成为了一个Controller+JSON+REST的组合，MVC中的M被JSON或资源所替代，V则干脆消失了，由Controller来负责必要的服务端验证，并完成HTTP请求的路由功能，其余的前端逻辑都交由我们当初选择的ExtJS了。</p>

<p>这种设计是完全合理的。但我仍然要说明一点的是，这种设计由于加大了前端的复杂度，因而需要我们更加关注前端的代码质量。传统开发要求的关注点分离、松耦合与高内聚原则同样适用于这样的前端代码。虽然不一定要提倡前端代码的测试驱动开发，但至少要保证这些代码具有足够的测试覆盖率。例如，我们可以为Javascript（或者jQuery)引入Jasmine，QUnit等测试框架。在我的同事曾经参与的一个项目中，由最初只支持一个品牌，增强到支持多个品牌的需求变化，这其中需要涉及到对大量前端代码的复用。由于之前的设计并未考虑到多品牌的支持，因而需要重构前端代码，以达成复用的目的。如果没有足够的测试覆盖率，以及良好的职责分离，要做到这一点的难度不言而喻。</p>

<p>我还提到，前端的许多模式事实上都是从MVC模式衍生而来，例如MVP，MVVM等。此时，MVC可以作为核心模式的一个名词。应该为那些变种的模式命名，并给出最佳实践，从而表达特定的含义。对于这种服务端与客户端结合起来共同协作的模式，可以命名为MC2MVC，或者RC2MVC。有个“2”，就表示从服务端到客户端的意思。至于RC2MVC，则是为了强调服务端提供的“资源”，而非传统意义上的模型。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从Go语言的设计学习设计决策]]></title>
    <link href="http://agiledon.github.com/blog/2013/05/04/design-decision-learning-from-go/"/>
    <updated>2013-05-04T21:12:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/05/04/design-decision-learning-from-go</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/05/decision.jpg">
阅读了Rob Pike撰写的《<a href="http://www.oschina.net/translate/go-at-google-language-design-in-the-service-of-software-engineering">Go在谷歌：以软件工程为目的的语言设计</a>》，颇多感触。这些感触并不在于语言层面，或者Go这门语言的语法以及底层实现；而是因为语言设计者们在设计Go这门语言时，做出设计决策的合理性以及基于的事实与根据。正如此文标题所言，显然，Go的创造者们从一开始就树立了准确的愿景与目标，并且清晰地确定了该语言的适用场景，即它需要解决“由多核处理器、系统的网络化、大规模计算机集群和Web编程模型带来的编程问题”，这是理解这门语言，进而明确其设计意图的最根本所在。</p>

<p>刚刚参加了公司八叉大神组织的轮子大赛，我们写了一个轻量级的IoC容器<a href="https://github.com/agiledon/melt">Melt</a>。就这个容器或者说框架本身，和八叉讨论了框架设计的特点。他提到“framework开发和功能开发的一个最大分别就在于，你需要规定在这个framework里那些是支持的，哪些是不支持的。这条线要你自己来划，或者说你的framework要有态度。”这是我非常认同的观点。Framework要有态度，这意味着你在践行并且在引导一种最佳实践。或者我们可以理解为这是一种架构的约束。我们都知道，在软件设计中，如果没有任何约束，带来的问题反而会更大。约束是一种驱动力，例如我们需要可伸缩性的约束，就需要我们设计的服务不应该是有状态的。框架的态度大意如此。</p>

<p>回过头来看这篇文章介绍的Go设计理念，无时无刻不是在体现设计者施加在这门语言身上的态度。必须注意，这种态度或者说设计理念又绝对离不开这门语言的设计愿景。若是脱离这种具体场景来看Go语言，或许有众多不合理之处，但我们并不能依此妄加论断。正如话剧演员在舞台上的表演，总带着几分略带夸张的表情与语气，我们却不能指责这种表演不够生活化。当我们在思考一个设计决策是否合理时，是否参考了当时的场景做出判断呢？进一步讲，当我们自己在进行设计决策时，又是否充分地考虑了具体的场景呢？例如，Go语言之所以采用C语言风格的花括号，其考量并非简单地延续C语言风格那么简单，在前面提及的愿景的大前提下，设计者必须考虑如果使用Python或Haskell风格的空格缩进，对于大规模程序而言，可能会造成太多的问题。如文中所云：“我们的观点是，虽然空格缩进对于小规模的程序来说非常适用，但对大点的程序可不尽然，而且程序规模越大、代码库中的代码语言种类越多，空格缩进造成的问题就会越多。为了安全可靠，舍弃这点便利还是更好一点，因此Go采用了花括号表示的语句块。”</p>

<!--more-->


<p>再看Go语言的依赖处理，它施加了一个看似比较独裁的约束，即“不允许其依赖图中有循环性的包含关系，编译器和链接器都会对此进行检查以确保不存在循环依赖”。设计者并不否认循环依赖存在一定的价值，然而在大规模程序的前提下，它带来的问题远远超过了可能存在的价值。文中提到：
<blockquote><p>循环依赖要求编译器同时处理大量源文件，从而会减慢增量式build的速度。更重要的是，如果允许循环依赖，我们的经验告诉我们，这种依赖最后会形成大片互相纠缠不清的源代码树，从而让树中各部分也变得很大，难以进行独立管理，最后二进制文件会膨胀，使得软件开发中的初始化、测试、重构、发布以及其它一些任务变得过于复杂。</p></p><p><p>不支持循环import偶尔会让人感到苦恼，但却能让依赖树保持清晰明了，对package的清晰划分也提了个更高的要求。就象Go中其它许多设计决策一样，这会迫使程序员早早地就对一些大规模程序里的问题提前进行思考（在这种情况下，指的是package的边界），而这些问题一旦留给以后解决往往就会永远得不到满意的解决。</p></blockquote></p>

<p>显然，Go语言的设计者并不是要设计一门大而全，兼容并包的全能语言，它严格而合理地压制着设计时可能膨胀的欲望，不与设计愿景相悖，并时刻从工程学的角度看待设计。设计一门语言如此，开发一个产品或项目更应如此。例如对于产品而言，当下流行的Lean Startup对于产品的理念，正是这种实效的工程主义。MVP（最小可验证产品）的划分将精简与避免浪费做到了极致，严格避免功能盲目的扩大化。</p>

<p>Rob Pike还提到：“在依赖关系方面保持良好状况要比代码重用重要”，甚至支持“为了使用一个函数，把所需的那一小段代码拷贝过来要比拉进来一个比较大的库强”。虽然我们在设计与开发时，常常会严格遵循DRY原则，同时也尽可能地追求重用，因为我们知道重复其实是一种“恶”。若要最大限度地重用，就必须保证实体的细粒度。从类级别来讲，粒度越细，就意味着类的数量越多，这可能会加大系统的复杂度。Kent Beck提出的简单设计中，第四条即为保证类的数量尽可能少。整体结合来看，实质是指在没有看到重用以及变化的征兆前，应尽可能避免类的数量被无谓地扩大。熊节将其概述为“如无必要，勿增实体”，非常准确。显然，细粒度的类虽然可以在重用上带来好处，但却可能使得系统变得更复杂。细粒度的类还在可控制的范畴，因为我们可以采用一些方式例如Facade或Mediator模式来简化或隐藏多个细小类之间的协作。然而，对于模块（指物理模块）层面来讲，粒度过细的模块会导致对依赖的管理变得复杂。我曾经在一个.NET项目中看到过多达100多个程序集，若尝试在Visual Studio中为其生成依赖图，可能会耗尽内存。而且这些细粒度的程序集，也会导致本地构建时间的增长。关于.NET项目中依赖管理的问题，Patrick Smaccla的文章《<a href="http://www.infoq.com/cn/articles/NDepend">避免在.NET代码中出现不恰当依赖</a>》有详细论述。然而，若是不能保证模块的细粒度，根据Robert Martin提出的共同复用原则，则可能导致即使是对一个细小功能的重用，也需要引入对整个包的依赖。</p>

<p>看来，我们有必要正视依赖与重用之间存在的鱼与熊掌不可兼得的问题。我的意见是当出现此类问题时，我们可以考虑职责分配上是否出现问题。如果模块的分解遵循了“高内聚”原则，可能此类依赖就只会发生在模块的内部。另一种思路是考虑我提出的所谓“依赖的沉淀”，即随时绘制组件图或包图，清晰地标明依赖的关系和方向，并根据权值来判断该模块应该位于纵向的物理分布层级的哪一层。具体细节可参考我写的一篇文章《<a href="http://agiledon.github.io/blog/2013/03/03/assigning-responsibility-between-modules/">模块间的职责分配</a>》。</p>

<p>文中还提到了Go语言故意缺失的一个特性就是不支持缺省参数。设计者认为：
<blockquote><p>缺省参数太容易通过添加更多的参数来给API设计缺陷打补丁，进而导致太多使程序难以理清深圳费解的交互参数。默认参数的缺失要求更多的函数或方法被定义，因为一个函数不能控制整个接口，但这使得一个API更清晰易懂。哪些函数也都需要独立的名字， 使程序更清楚存在哪些组合，同时也鼓励更多地考虑命名--一个有关清晰性和可读性的关键因素。</p></blockquote></p>

<p>姑且不谈这一设计的驱动因素是否可取，这里显然教会了我们在软件设计时应该懂得如何去权衡。权衡的能力是架构师必备的技能，就好像老婆和老妈同时落水了，你该去救哪一个，这个命题总是让人不舒服，因而不肯回答。说来简单，在进行设计决策时，如果要权衡多个指标，一定要以最重要的哪个指标为主。问题是当我们不知道哪个指标更重要时，应该怎么办？我想，答案还是应该从愿景中去寻找。根据Go语言的愿景，对于大规模程序而言，清晰易懂的API会降低维护成本，并在一定程度上保障软件的质量，这显然比API的兼容性更为重要。</p>

<p>Go语言对于可见性的设计非常漂亮，“名字自己包含了可见性的信息，而不是使用常见的private,public等关键字来标识可见性：标识符首字母的大小写决定了可见性。如果首字母是大写字母，这个标识符是exported(public); 否则是私有的。”最初看来，这样的约定非常怪异，可是仔细琢磨，你不觉得通过这样一个简单的约定，让程序一下子变得精简了许多吗？其实只要明确了这一约定，代码的可见性仍然是清晰可知的。从某种程度讲，甚至比显式地声明public或private更加清晰。</p>

<p>Go语言对于继承的处理也显得特立独行，因为在Go语言中，没有类型层级（type hierarchy）的概念。它选择了组合而非继承，在于它对继承滥用表达了足够的忧虑和担心。作者认为：“类型层次结构这种模型会促成早期的过度设计，因为程序员要尽力对软件可能需要的各种可能的用法进行预测，不断地为了避免挂一漏万，不断的增加类型和抽象的层次。这种做法有点颠倒了，系统各个部分之间交互的方式本应该随着系统的发展而做出相应的改变，而不应该在一开始就固定下来。”我对此持保留意见，但在支持接口的前提下，这种规避继承的做法，仍有可取之处。因为接口可以支持OO中多态的特性，而组合又能保证逻辑的重用。这意味着，继承给我们带来的好处已经找到了合理的替代品。</p>

<p>Go抛弃了大多数传统语言所支持的异常机制，而转而使用error。这种机制建立在一个前提，即Go语言支持多个返回值。倘若像Java、C#等多数语言那样，仅支持一个返回值，则异常机制就变得完全有必要了。鉴于对多返回值的支持，且Go中的error又是抽象的接口类型，这样的设计就变得合乎情理了。</p>

<p>我们注意到Go语言中一些与众不同的特征，其实皆为设计者设计理念的体现，从中我们可以看到设计者做出设计决策的依据。显然，这些决策皆围绕着最高的设计愿景，并结合实际的工程场景，在通过合理权衡的前提下做出的。这种决策之道，值得软件架构师与设计师借鉴。</p>
]]></content>
  </entry>
  
</feed>
