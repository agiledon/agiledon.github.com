<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | 晴窗笔记]]></title>
  <link href="http://agiledon.github.com/blog/categories/design/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2013-02-03T18:38:29+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[设计模式的一些变化]]></title>
    <link href="http://agiledon.github.com/blog/2013/02/02/change-of-design-patterns/"/>
    <updated>2013-02-02T22:28:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/02/02/change-of-design-patterns</id>
    <content type="html"><![CDATA[<p>经历了几次过度设计，我对一些设计模式开始抱有谨慎的戒惧。我希望能够合理地运用设计模式，而非为模式而模式。事实上，现在的我较少会有意识地运用设计模式；更多地是通过职责来驱动，以期获得合理的职责分配。之后，再通过辨别代码的坏味道，运用重构来改善设计。大多数情况下，这种方式对于设计而言，已经足够。不过，有时我们仍有必要根据具体场景，做出合理判断和决策。</p>

<p>我曾经遭遇的一个Story，是要实现一个Web Service，提供update的服务接口。需求要求对服务的Request进行验证。这一验证功能并非Story的核心功能，但其逻辑却比核心逻辑复杂数倍。它需要针对不同情况，遵循多个规则验证Request。这些验证逻辑如此的复杂，以至于我们可以在第一时间做出判断，它必须是单独的职责，绝对不适合放到Service对象中。</p>

<p>这种职责分离还不够。因为每一条验证规则，都可以视为一个单独的验证职责。若将每种验证规则封装为一个验证对象，就能很好地满足SRP。每个验证对象只需要做好自己的事情即可，结果只有两个，要么错误，要么通过。若当验证逻辑为一个整体，则可以理解为：只要违背了一条验证规则，出现错误，则可以视为验证不通过；否则将继续验证下一条规则。</p>

<!--more-->


<p>乍一看来，这完全符合职责链模式的要求。我的Pair也完全同意了这一点。当我们按照这一思路进行编码时，我的疑惑随着步伐的前进，变得愈深，好像有什么东西在拽着自己，阻止我们前进。因为我们使用了Spring，故而需要将这个职责的链条通过依赖注入的方式拼接。为了迎合这种要求，标准的职责链模式需要微调。例如，我们写出这样的职责链超类：
``` java
public abstract class UpdateRequestValidator {</p>

<pre><code>private UpdateRequestValidator nextValidator;
public UpdateRequestValidator(UpdateRequestValidator nextValidaor) {
    this.nextValidator = nextValidator;
}

public ValidateResult validate(UpdateRequest request) {
    ValidateResult result = doValidate();
    if (result.isError()) {
        return result;
    }
    return nextValidator.validate();
}

protected abstract ValidateResult doValidate();
</code></pre>

<p>}
```</p>

<p>如果仔细分析这段代码，可以发现我们是在运用装饰器模式的手法来实现职责链。这就让人感到奇怪了。由于我们自定义了构造函数，要求传入一个UpdateRequestValidator，似乎可以避免对nextValidator非空的判断。可是，链条的末尾又该放入哪个对象呢？为此，我们还定义了一个NullValidator，它什么都不做，并被要求放到职责链构造的最末尾。</p>

<p>够奇怪吧。这里我们对Spring的配置做出了假设，一厢情愿地要求NullValidator必须作为职责链的最后一个。可是，我们却未对这种假设做出任何约束。</p>

<p>与其如此别扭，还不如对设计做出调整。只要验证逻辑的职责分离与封装是合理的，我们未必一定要运用职责链模式（或者这种不伦不类的装饰器模式）。抛开这种约束后，每个Validator就可以变得更单纯，无需假设这个链条的组成；而是将这个链式逻辑转交给包含了UpdateRequestValidator列表对象的Validator对象，它可以被看成是Validator的合成对象：
``` java
public interface UpdateRequestValidator {</p>

<pre><code>ValidateResult validate(UpdateRequest request);
</code></pre>

<p>}
public class CustomerNotFoundValidator implements UpdateRequestValidator {</p>

<pre><code>@Override
public ValidateResult validate(UpdateRequest request) {
    //do something;
}
</code></pre>

<p>}
public class CompositeUpdateRequestValidator implements UpdateRequestValidator {</p>

<pre><code>private List&lt;UpdateRequestValidator&gt; validators;
@Required
public void setValidators(List&lt;UpdateRequestValidator validators) {
    this.validators = validators;
}
@Override
public ValidateResult validate(UpdateRequest request) {
    ValidateResult result;
    for (UpdateRequestValidator validator : validators) {
        result = validator.validate(request);
        if (result.isError()) {
            return result;
        }
    }
    return result;
}
</code></pre>

<p>}
```</p>

<p>我觉得修改后的设计意图清晰许多了，并且，它对使用者没有了隐含的约束，在Spring的ApplicationContext配置文件中，也能够很好地将我们单独实现的Validator作为List的元素配置给CompositeUpdateRequestValidator。我喜欢这样的调整。</p>

<p>我对装饰器模式持同样态度。正如有人说道：装饰器模式的方式有些像洋葱。洋葱的味道虽好，不过在剥洋葱时，却要小心不要被呛出眼泪。在阅读<a href="http://www.axonframework.org">Axon Framework</a>的源代码时，我发现一种设计方式，可以避免装饰器模式的洋葱构造，却能达到同样的装饰效果。我将其成为Interceptor模式。</p>

<p>需求是希望对CommandHandler对象的命令请求进行包装（或装饰），例如为命令请求提供日志或事务功能。这些功能可以是组合的。传统的方式是运用装饰器模式，例如：
``` java
public interface CommandHandler {</p>

<pre><code>void handle();
</code></pre>

<p>}
public class LoggingCommand implements CommandHandler{</p>

<pre><code>private CommandHandler commandHandler;
public LoggingCommand(CommandHandler commandHandler) {
    this.commandHandler = commandHandler;
}

@Override
public void handle() {
    logInfo("begin execute command");

    commandHandler.handle();

    logInfo("end execute command");
}
</code></pre>

<p>}
public class TransactionCommand implements CommandHandler {</p>

<pre><code>private CommandHandler commandHandler;
public TransactionCommand(CommandHandler commandHandler) {
    this.commandHandler = commandHandler;
}

@Override
public void handle() {
    myTransaction.beginTransaction();
    try {
        commandHandler.handle();
        myTransaction.commitTransaction();
    } catch (Exception ex) {
        myTransaction.rollbackTransaction();
    }
}
</code></pre>

<p>}
```</p>

<p>假设有一个命令对象PlaceOrderCommandHandler，同时需要日志和事务功能，就需要如下构造方式：
<code>java
CommandHandler command = new TransactionCommand(new LoggingCommand(new PlaceOrderCommandHandler()));
</code></p>

<p>这种构造方式既复杂，也不容易使用Spring来注入。Axon的设计方式转变了设计视角，将这种对命令的包装，看做是对命令请求的一种拦截，这就好似AOP的pointcut一般。它定义了一个InterceptorChain，负责完成整个拦截器链条的组装，并将这些拦截职责通过Chain完成一层层的传递。设计如下：
``` java
public interface CommandHandlerInterceptor {</p>

<pre><code>void handle(InterceptorChain interceptorChain);
</code></pre>

<p>}
public class LoggingInterceptor implements CommandHandlerInterceptor {</p>

<pre><code>@Override
public void handle(InterceptorChain interceptorChain) {
    info("LOG: begin");
    interceptorChain.proceed();
    info("LOG: end");
}
</code></pre>

<p>}
public class TransactionInterceptor implements CommandHandlerInterceptor {</p>

<pre><code>@Override
public void handle(InterceptorChain interceptorChain) {
    transaction.beginTransaction();
    try {
        interceptorChain.proceed();
        transaction.commitTransaction();
    } catch (Exception ex) {
        transaction.rollbackTransaction();
    }


}
</code></pre>

<p>}
public class InterceptorChain {</p>

<pre><code>private Iterator&lt;? extends  CommandHandlerInterceptor&gt; interceptorChain;
private CommandHandler handler;

public void proceed() {
    if (interceptorChain.hasNext()) {
        interceptorChain.next().handle(this);
    }

    handler.handle();

}

@Required
public void setHandler(CommandHandler handler) {
    this.handler = handler;
}

@Required
public void setInterceptorChain(Iterator&lt;? extends CommandHandlerInterceptor&gt; interceptorChain) {
    this.interceptorChain = interceptorChain;
}
</code></pre>

<p>}
```</p>

<p>在InterceptorChain类中，handler对象就是我们要包装（或者说拦截）的命令对象。注意，Interceptor对象的handle()方法，是将InterceptorChain对象作为参数传入的。于是就形成了如下的方法调用时序：
<img class="center" src="/images/2013/02/interceptor.png"></p>

<p>只要理解了InterceptorChain起到的委派传递作用，就能很好地理解这个设计。这种方式将之前装饰器模式那种洋葱式的构造转移到列表中，并通过迭代器进行迭代。同时，它将对CommandHandler以及相关拦截器对象的依赖转移到了外面，很好地支持IoC容器对依赖的注入，从而使得代码可以变得更简单，更灵活。</p>

<p>总之，当我们在运用设计模式时，一定要结合当前上下文，对设计模式做出合理的判断，甚至可以大胆地对GOF总结的设计模式进行大刀阔斧地挑战或修改。关键还在于把握设计模式的核心原则，并在“简单设计”的前提下，做出设计的决策。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文学与软件]]></title>
    <link href="http://agiledon.github.com/blog/2012/12/21/literature-and-software/"/>
    <updated>2012-12-21T18:59:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2012/12/21/literature-and-software</id>
    <content type="html"><![CDATA[<p><img class="left" src="/images/2012/12/dafenqi.jpg" width="182" height="276"></p>

<p> 卡尔维诺在哈佛大学的文学讲座（即诺顿论坛，是为纪念美国著名学者诺顿开设的，每年邀请世界文化名人作讲座，艾略特、博尔赫斯也曾获邀参加诺顿讲座）被他的妻子编成了一本独立的书《美国讲稿》。这本书展现了卡尔维诺的文学精神，体现了他的文学态度和气质。不过，我在阅读该书时，却发现了一些与编程有关的内容。</p>

<p>1、文学中的重构</p>

<p> 达芬奇在《大西洋草图》中记述了他幻想中海怪的形象，进行了前后三次重构。最初的描述是：</p>

<p><strong>啊，人们多次在波浪翻滚的广阔海洋之中看到你，看到你那长满鬃毛的黑色背脊，你像一座大山，傲慢地徐徐前进！</strong></p>

<!--more-->


<p>然后，他试图使海怪的行动生动些，加了个动词“翻转”：</p>

<p><strong>啊，人们多次在波浪翻滚的广阔海洋之中看到你，看到你在海水中傲慢地徐徐翻转身躯，看见你那长满鬃毛的黑色背脊。你像一座大山屹立在海浪之上！</strong></p>

<p>然而，他觉得“翻转”这个词削弱了他想留给人们的那种雄伟与庄严的印象，于是选择了“分开”这个动词，并改变了句子结构，使句子变得更紧凑，更有节奏。</p>

<p><strong>啊，人们多次在波浪翻滚的广阔海洋中看到你！你像一座山屹立在海浪之上。你傲慢地徐徐前进，用那长满鬃毛的黑色背脊把海水分成两半!</strong></p>

<p>在文学创作中，重构其实会经常发生，这源于作家对文学作品高质量追求的精益求精，他们常常通过修改句式，修辞手法或改变词语来改善文字，使之体现恰如其分的美。编码艺术同样如此，即使是代码的结构，以及变量、方法和类的命名，排版样式，只要给予足够的重视，锤炼这方面的技能，坚持重构，就能改善编码质量。</p>

<p>2、封装与接口</p>

<p>卡尔维诺在“精确”一章中引述了哲学家们对语言和外部世界关系的思考：</p>

<p><strong>使用语言是对事物的不断追求，不是渐渐接近事物的本质而是接近事物那无休止的变化，接近事物那多种多样的、无穷无尽的表面。正如霍夫曼斯塔尔所说：“深层应该掩盖起来。掩盖在哪里？掩盖在表层下面。” 维特根斯坦走得更远，他说：“凡被掩盖的东西，我们都没有兴趣。”</strong></p>

<p>在软件开发中，我们常常运用封装来隐藏内部的实现细节。它带来的好处是使得调用变得简单，重用成为可能，很好地隔离了内部实现的变化。当然，文学更善于挖掘内部的玄奥，却常常使用抽象的语言描述出一种晦涩，试图掩盖这种玄奥，以此追求一种寻找“高山流水”知音般心灵激荡的玄妙与浃肌沦髓。</p>

<p>文学也尝试用变化去处理变化，这似乎矛盾，却恰好是文学艺术让人着迷的地方。软件又何尝不是如此。卡尔维诺看到了两种变与不变的模式：</p>

<p>最近我偶然读到生物形成过程的模式：“一边是晶体（象征表面结构稳定而规则），一边是火焰（虽然它的内部在不停地激荡，但外部形式不变）。”……火焰与晶体这两种形象代表了生物学上的两种选择。</p>

<p>皮亚杰观点的哲学蕴含是“从噪音到有序”，即火焰；乔姆斯基观点的哲学蕴含是“自我编制系统”，即晶体。</p>

<p><img class="right" src="/images/2012/12/america.jpg" width="189" height="266"></p>

<p>这仿佛让我洞悉了面向对象设计的玄机。火焰代表了接口，无论如何变化，其外部形式总是不变。接口的引入使得软件设计可以从混沌（即皮亚杰所说的“噪音”）走向有序。至于晶体，则是遵循了信息专家模式的对象，因为它封装了数据以及操作该数据的行为，使得它具有了自我判断的意识。它的表面结构仍然是稳定的，却有一套自我约束的规则。晶体看起来是宁静的，而火焰却如此的灵活。融合晶体与火焰的系统，是否代表了对变化的封装，以及对不变概念的抽象呢？</p>

<p>3、纠缠的细节</p>

<p>薄伽丘在一篇故事中（《十日谈》第六天第一个故事）谈到讲故事的艺术，正好回顾了这种感觉。</p>

<p>**“奥丽达太太，要是你不讨厌的话，我想讲一个世界上最大的故事给你听，叫你听得津津有味，就像骑了一匹马一样，往了路途的遥远。”</p>

<p>“啊，再好没有了，先生，”那位太太说，“请你快给我讲一个故事吧。”</p>

<p>于是绅士开始讲故事给她听。故事倒很精彩，可惜他讲故事的本领，只抵得上他使用他身边那把佩剑的工夫，实在太不高明，时常把一句话颠来倒去的说了又说，甚至说上六七遍，过了一会，忽然又倒过头来说道：“哎呀，我说错啦！”对于故事中的人名地名常常纠缠不清，张冠李戴，弄得别人莫名奇妙。他那说话的声气又跟故事里的人物、情景一点都配不上，真是听得奥丽达太太头晕目眩，冷汗一身，只觉得大祸临头，连命都快要保不住了。到最后，她忍无可忍，又看见那位绅士正愈说愈糊涂，已经迷了路，失了方向，只是在那儿团团打转，再也跑不出来了，就和悦地对他说：“先生，你那匹马跑得太野，请你还是让我下了马吧。”**</p>

<p>在软件设计过程中，最要紧的是思路要清晰，既不能迷失在需求分析中，也不能迷失在复杂的实现细节中。最好能够结合实际的场景，列出我们要达到的目标，需要完成的任务，有序地进行分析和设计。编写代码时，切忌功能之间互相纠缠，虽然体现了对象的协作，但由于职责分配混乱，使得对象之间的协作变得无规律可循，颠三倒四，最后让人忍无可忍，也只能翻身下马了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GAE的设计]]></title>
    <link href="http://agiledon.github.com/blog/2012/02/11/the-design-of-gae/"/>
    <updated>2012-02-11T10:55:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2012/02/11/the-design-of-gae</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2012/02/Google-App-Engine.jpg" width="537" height="251"></p>

<p>说明：以下获得的设计思考，是阅读《GAE编程指南》时的一些简单体会。主要针对的是一些设计细节（非架构）的考量。</p>

<p>简单与灵活。在对API进行设计决策时，需充分考虑API的简单性和全面性。此二者都是站在调用者的角度来思考，即需要提供一种默认的简单调用形式，也可以根据实际情况提供可选的方式。这是简单性和灵活性的共同体现。在Google App Engine中，对数据存储区的实体存储，可以在创建实体对象时指定主键；如果不指定主键，就会生成唯一的ID。</p>

<!-- more -->


<p>如下Python代码：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">obj</span> <span class="o">=</span> <span class="n">Book</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="s">&#39;The Grapes of Wrath&#39;</span><span class="p">,</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>       <span class="n">author</span><span class="o">=</span><span class="s">&#39;John Steinbeck&#39;</span><span class="p">,</span>
</span><span class='line'>       <span class="n">copyright_year</span><span class="o">=</span><span class="mi">1939</span><span class="p">,</span>
</span><span class='line'>       <span class="n">author_birthdate</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1902</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">27</span><span class="p">))</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>如果需要生成键名，在调用构造函数时，应加上key_name参数：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">obj</span> <span class="o">=</span> <span class="n">Book</span><span class="p">(</span><span class="n">key_name</span><span class="o">=</span><span class="s">&#39;0143039431&#39;</span><span class="p">,</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>       <span class="n">title</span><span class="o">=</span><span class="s">&#39;The Grapes of Wrath&#39;</span><span class="p">,</span>
</span><span class='line'>       <span class="n">author</span><span class="o">=</span><span class="s">&#39;John Steinbeck&#39;</span><span class="p">,</span>
</span><span class='line'>       <span class="n">copyright_year</span><span class="o">=</span><span class="mi">1939</span><span class="p">,</span>
</span><span class='line'>       <span class="n">author_birthdate</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">(</span><span class="mi">1902</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">27</span><span class="p">))</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>我想，之所以需要考虑这种简单性和灵活性的结合，在于API的特征，这种开放平台会面临不同消费者，在不同场景下做出不同的选择。二者的平衡保证了API的调用能够得到最大程度的需求满足。</p>

<p>封装。在设计时，我们应尽量避免使用基本类型。Martin Fowler在《重构》一书中将其称为“基本类型偏执”。例如在GAE中，就对key进行了合理的封装，包含了实体的类型和值。如果希望批量获取多个实体，可以将key放到列表中，作为get()方法的参数，返回实体对象列表。这种批量获取实体的性能比多次执行单次获取要好，或许是因为它能够减少对数据库IO操作的次数。根据key获得实体对象的python代码如下所示：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="kn">from</span> <span class="nn">google.appengine.ext</span> <span class="kn">import</span> <span class="n">db</span>
</span><span class='line'><span class="n">k</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">key</span><span class="p">(</span><span class="s">&#39;Entity&#39;</span><span class="p">,</span> <span class="s">&#39;alphabeta&#39;</span><span class="p">)</span>
</span><span class='line'><span class="n">e</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>在上面的代码中，db.key()方法相当于key的工厂方法，负责创建key。如果需要根据多个key值获得多个实体对象，则代码为：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='python'><span class='line'><span class="n">entities</span> <span class="o">=</span> <span class="n">db</span><span class="o">.</span><span class="n">get</span><span class="p">([</span><span class="n">k1</span><span class="p">,</span><span class="n">k2</span><span class="p">,</span><span class="n">k3</span><span class="p">])</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>比较python而言，Java代码略显复杂：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">DatastoreService</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">DatastoreServiceFactory</span><span class="o">.</span><span class="na">getDatastoreService</span><span class="o">();</span>
</span><span class='line'><span class="n">Map</span><span class="o">&amp;</span><span class="n">lt</span><span class="o">;</span><span class="n">Key</span><span class="o">,</span> <span class="n">Entity</span><span class="o">&gt;</span> <span class="n">entities</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="k">new</span> <span class="n">ArrayList</span><span class="o">(</span><span class="n">Arrays</span><span class="o">.</span><span class="na">asList</span><span class="o">(</span><span class="n">k1</span><span class="o">,</span><span class="n">k2</span><span class="o">,</span><span class="n">k3</span><span class="o">)));</span>
</span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>对于Java的GAE API而言，似乎还可以提供一个类似KeyCollection的对象，用于封装key列表，并为DatastoreService的get()提供接收KeyCollection对象的重载方法。KeyCollection可以封装一些key列表的行为。但这要根据具体的API设计而定。</p>

<p>GAE为查询还提供了get_by_id()与get_by_key_name()方法。为何提供这两个方法呢？我想，首先因为它们满足最常见的查询要求；同时，这是一种高层次的抽象，无论实体属于什么类型，无论业务有何差异，数据结构有何区别，都需要这两种查询方式。此时，还能够充分体会到封装key的好处，因为这种封装能够在一定程度上消除不同实体（尤其是遗留代码实体）在key之间的差异。</p>

<p>一致性。在GAE中，创建实体的API与更新实体的API完全一致。数据存储区不会区分创建和更新操作。若保存实体时用到完整的键（例如带有类别kind和键名），而数据存储区恰好有这个实体，就会替换原有的实体。为避免更新有效的数据，可以事先测试该实体是否存在，但这种方式在GAE中，需要使用事务API。</p>

<p>Fluence Interface。GAE提供的查询API在Java和Python两种语言下，有一些细微的差别。比较而言，Python采用了Fluence Interface模式，使得它的调用显得更为流畅和简洁。以下是Python代码：
Liquid error: invalid byte sequence in US-ASCII</p>

<p>Java的代码就略显冗长而不够流畅，可读性较低。这一方面与语言自身的特色有关，但倘若运用了fluence interface模式，相信能够比较好地提高代码的可读性：
<div class='bogus-wrapper'><notextile><figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="n">DatastoreService</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">DatastoreServiceFactory</span><span class="o">.</span><span class="na">getDatastoreService</span><span class="o">();</span>
</span><span class='line'><span class="n">Query</span> <span class="n">q</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Query</span><span class="o">(</span><span class="s">&quot;Book&quot;</span><span class="o">);</span>
</span><span class='line'><span class="n">q</span><span class="o">.</span><span class="na">addFilter</span><span class="o">(</span><span class="s">&quot;copyright year&quot;</span><span class="o">,</span> <span class="n">Query</span><span class="o">.</span><span class="na">FilterOperator</span><span class="o">.</span><span class="na">LESS_THAN_OR_EQUAL</span><span class="o">,</span> <span class="mi">1950</span><span class="o">);</span>
</span><span class='line'><span class="n">q</span><span class="o">.</span><span class="na">addSort</span><span class="o">(</span><span class="s">&quot;title&quot;</span><span class="o">);&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">PreparedQuery</span> <span class="n">pq</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="na">prepare</span><span class="o">(</span><span class="n">q</span><span class="o">);</span>
</span><span class='line'><span class="k">for</span> <span class="o">(</span><span class="n">Entity</span> <span class="n">result</span> <span class="o">:</span> <span class="n">pq</span><span class="o">.</span><span class="na">asIterable</span><span class="o">()){&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">String</span> <span class="n">title</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="na">getProperty</span><span class="o">(</span><span class="s">&quot;title&quot;</span><span class="o">);</span>
</span><span class='line'><span class="c1">//...</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>
在使用PreparedQuery对象访问结果之前，查询其实是没有执行的。</p>

<p>根据我对上面这一段python代码的直观感觉，认为fetch()方法似乎是一种命令模式，之前的Query对象作为命令对象，由内部的Builder对象构建起内部的组成部分，这里是由filter()与order()方法来体现。因为没有阅读源代码，所以只能停留在猜测。我认为在Query类的内部，可能会定义一个Builder方法（或者定义一个内部的Builder类，如果要考虑扩展，甚至是一个Builder接口）。它可能会持有一个QueryStatement对象，作为Collection Parameter传递给Builder。这些Builder会修改QueryStatement对象，使其生成符合命令要求的SQL语句。如果Query是针对数据库的查询，则QueryStatement就可以是一个SqlStatement对象。若有时间，希望能阅读一下源代码，以此印证我的揣测是否正确。或许，有更好的解决方案？</p>
]]></content>
  </entry>
  
</feed>
