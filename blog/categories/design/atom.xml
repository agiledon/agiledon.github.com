<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | 简单文本]]></title>
  <link href="http://agiledon.github.com/blog/categories/design/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2013-03-03T15:25:37+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[阅读的设计体悟]]></title>
    <link href="http://agiledon.github.com/blog/2013/03/02/harvest-from-reading/"/>
    <updated>2013-03-02T21:46:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/03/02/harvest-from-reading</id>
    <content type="html"><![CDATA[<p>{% img center /images/2013/03/jsbookcover.jpg %}
不管语言的变化有多大，关于程序设计的基本编程思想和设计本质，应是殊途同归。两年前阅读了Jonathan Snook的著作《Javascript捷径教程Accelerated DOM Scripting with Ajax, APIs, and Libraries》。在书中，他带领读者构建了一个简单的动画对象。简单的例子，轻描淡写的描述，却似乎展现了朴素的基本设计思想。</p>

<!--more-->


<p>下面记录了一些阅读感悟。例如，书中这样写道：
{% blockquote %}
页面里要用到的动画对象一般都不止一个，所以应该把它定义成一个类。定义一个有5个参数的函数：要加上动画的元素、要改变的属性、属性的起始值、属性的结束值、动画的持续时间。
{% codeblock lang:js %}
function Animation(element, property, from, to, duration){}
{% endcodeblock %}</p>

<p>不管编写什么代码，都应该先把实现想透彻。每个决定都有正反两方面的后果，你应该想清楚每个决定的原因。
{% endblockquote %}</p>

<p>这代表一个朴素的思想，那就是从实现原理来进行设计决定。注意这里的实现原理，并不是要关注实现的细节，而是要考虑影响实现的因素，并从调用者的角度思考接口或函数的输入与输出值。以本例而言，如果事先不明确动画效果的营造方式，是根据时间的变化动态变更element属性的方式来完成，就无法确定Animation函数。设计不是空中楼阁，抽象固然是重要的，但功能实现的基本原理仍然需要事先思考通透，否则，设计就可能走弯路。拿到一个功能，先要弄清楚它的目标是什么，有没有质量属性的要求，未来的变化如何，还有这一功能的实现原理。例如，我们要提供服务定制的功能，就需要实现明确“服务”的定义，如何完成服务的注册，服务的发布，服务的订阅，谁会订阅这些服务，服务的安全如何保障，如何解决服务与实现的脱耦。只有把这些问题想清楚了，设计才会靠谱。
{% blockquote %}
看看前面的代码，元素ID是作为一个字符串传递进来的，那么在动画对象中获取该元素就有两种方法：一是通过DOM方法document.getElementById()；二是采用Javascript库的调用，如${}。……既然我们想让这个动画对象能适合各种情况，那还是用DOM方法比较好，保证它不依赖于任何库。
{% codeblock lang:js %}
function Animation(element, property, from, to, duration)
{</p>

<pre><code>var el = ducument.getElementById(element);
if (!el) return false;
</code></pre>

<p>}
{% endcodeblock %}
{% endblockquote %}</p>

<p>这段话仍然体现了一种设计决策。它的实现目标是不与任何JS库耦合。这就需要保证实现的通用性。
{% blockquote %}
要是你打算执行动画的元素没有ID怎么办呢？为了让这个类更灵活，让我们把它改成既可以传入元素引用，又可以传入ID字符串。如果传入的是ID字符串而不是对象引用，程序就会通过DOM方法去获取元素。两全其美！
{% codeblock lang:js %}
function Animation(element, property, from, to, duration)
{</p>

<pre><code>var el = element;
if (typeof el == 'string') el = document.getElementById(element);
if (!el) return false;
</code></pre>

<p>}
{% endcodeblock %}
{% endblockquote %}</p>

<p>这又是一种编码修炼了。除了要在设计上保证灵活性之外，我们在编码时也需养成保证代码完整性与健壮性的习惯，并体贴地为调用者着想。有这么一条设计原理，就是伯斯塔尔法则(Postel's Law)：“发送时要保守；接收时要开放。”这里的实现无疑遵循了这样一个法则。我们在编码时，考虑到这些因素了吗？</p>

<p>Ok，继续我们的阅读。
{% blockquote %}
实例化一个对象要用到5个参数，但一眼看上去很难看出参数里的那些数字都代表什么含义。……为此你可以把参数改成字面量对象，键的名称看起来更直观一些。而且如此改动能使API更加灵活，因为即使今后增加了更多的参数，实例化对象的代码也不会变得更复杂。
{% codeblock lang:js %}
function Animation(options)
{</p>

<pre><code>var el = options.element;
</code></pre>

<p>}
var options = {</p>

<pre><code>element:document.getElementById('elementId'),
property: 'left',
from:0,
to:200,
duration:1000
</code></pre>

<p>};
{% endcodeblock %}
{% endblockquote %}</p>

<p>无疑，这体现了面向对象的“封装”思想。通过封装既保证了代码的清洁与可读性，同时还有利于未来的扩展。这与OCP（开放-封闭原则）是一脉相承的。代码是有结构的，或者体现为函数，或者体现为对象，事实上都是一种按照属性与职责进行的分类。分类是保持清洁、避免重复的唯一法门。从简朴的角度来说，所有的设计其实都是在做着分类的游戏。分类体现了定义的抽象，职责的分配，结构的划分；如果再加上类别之间的协作，就是设计的全部了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[职责与封装]]></title>
    <link href="http://agiledon.github.com/blog/2013/02/20/responsibility-and-encapsulation/"/>
    <updated>2013-02-20T21:49:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/02/20/responsibility-and-encapsulation</id>
    <content type="html"><![CDATA[<p>面向对象设计的关键，我认为是识别职责，封装合理的对象。缺乏合理的封装，就会缺少正确的领域对象，使得属于共同职责的领域信息散乱分布到系统的各个方法中，导致概念不够清晰，职责混乱，以及代码的重复。然而，如果没有正确地识别职责，又可能导致封装无从谈起，因为我们获得的需求可能是散乱的，既难以抽象概念，又缺乏层次。故而，职责与封装是相辅相成的概念。如下图所示：
{% img center /images/2013/02/responsibility01.png %}</p>

<p>我们不能简单地将封装当做是“信息隐藏”。所谓隐藏信息以及具体行为的细节，确实是封装的本质所在，但面向对象思想中的封装，其目的还在于对领域概念以及设计概念的识别。前者是对业务模型的抽象，如电子商务系统中的Product、Order、OrderItem等概念；后者是对设计模型的改进，如在设计模式中引入策略对象、命令对象，DDD中提倡的Repository、Factory对象。这也是为何许多设计者很容易理解封装的概念，但却始终无法做到合理封装的根本原因。</p>

<!--more-->


<p>此时，我们需要运用职责驱动设计，通过对职责的识别来提炼这些概念。概念可以起到分类的作用，根据职责对行为与数据进行分类，找到其应该归属的对象，散乱的逻辑就会变得清晰起来。就好似我们对彩球按照颜色进行分类，并放置到不同的位置：
{% img center /images/2013/02/responsibility02.png %}</p>

<p>不同的颜色有分明不同的特征，只要不是色盲，分类自然水到渠成。现实中的系统需求自然不如颜色这般泾渭分明，要从纷繁复杂的混沌需求中超脱出来，最好的办法就是按照不同的角度或层次去寻找职责，并用最简单的语言一句话描述这些职责。根据职责的特征，我大致将职责分为三个层次，由外自内分别为：业务价值、业务功能与业务实现，如下图所示：
{% img center /images/2013/02/responsibility03.png %}</p>

<p>业务价值基本上体现了这个需求用例（或用户故事）存在的目的，即解释了需求的Why。简言之，只有提供了该职责，则此需求对于客户才是有价值的。这也符合用户故事INVEST原则中的V（Valuable）。没有价值的需求，自然是应该放弃的。故而在识别业务价值时，常常从用户的视角来分析，辨别。</p>

<p>业务价值是职责驱动的入口，因为在寻找到了业务价值之后，我们就可以剖析该价值需要哪些支撑功能（它可以解释需求的What），再由功能继续深入分析，找到实现功能的职责（它可以解释需求的How）。因此，这个模型是一个层层推进的过程。</p>

<p>职责驱动不仅仅可以从文字需求入手，同样可以针对已经实现的代码。甚至我们可以将这种职责驱动看做是一种阅读代码的技巧，通过寻找业务价值，进而分析业务功能和业务实现，对代码形成一个整体的感观，进而通过合理地分配职责改善原有代码。如下代码是《修改代码的艺术》一书中给出的例子：
{% codeblock %}
import javax.mail.<em>;
import javax.mail.internet.</em>;</p>

<p>public class MailingListServer {</p>

<pre><code>public static final String SUBJECT_MARKER = "[list]";
public static final String LOOP_HEADER = "X-LOOP";

public static void main(String[] args) {
    if (args.length != 8) {
        System.err.println("Usage: java MailingList &lt;popHost&gt; " + 
        "&lt;smtpHost&gt; &lt;pop3user&gt; &lt;pop3password&gt; &lt;smtpuser&gt; &lt;smtppassword&gt; &lt;listname&gt; " +
        "&lt;relayinterval");
    }
    return;

    HostInformation host = new HostInformation(arg[0]);
    String listAddress = args[6];
    int interval = new Integer(args[7]).intValue();
    Roster roster = null;
    try {
        roster = new FileRoster("roster.txt");
    }catch(Exception e) {

    }

    try {
        do {
            try {
                Properties properties = System.getProperties();
                Session session = Session.getDefaultInstance(properties, null);
                Store store = session.getStore("pop3");
                store.connect(host.pop3Host, -1, host.pop3User, host.pop3Password);
                Folder defaultFolder = store.getDefaultFolder();
                if (defaultFolder == null) {
                    return;
                }
                Folder folder = defaultFolder.getFolder("INBOX");
                if (folder == null) {
                    return;
                }
                folder.open(FOLDER.READ_WRITE);
                process(host, listAddress, roster, session, store, folder);
            }catch () {

            }
            try {
                Thread.sleep(interval * 1000);
            } catch() {

            }

        } while (true)
    }catch () {

    }
}

private static void process(
    HostInformation host, String listAddress, Roster roster,
    Session session, Store store, Folder folder) throws MessagingException {
    try {
        if (folder.getMessageCount() != 0) {
            Message[] messages = folder.getMessages();
            doMessage(host, listAddress, roster, session, folder, messages);
        }
    }catch () {

    }finally {
        folder.close(true);
        store.close();
    }
}

private static void doMessage(
    HostInformation host,
    String listAddress,
    Roster roster,
    Session session,
    Folder folder,
    Message[] messages) throws MessageingException {
    FetchProfile fp = new FetchProfile();
    fp.add(FetchProfile.Item.ENVELOPE);
    fp.add(FetchProfile.Item.FLAGS);
    fp.add("X-Mailer");
    folder.fetch(messages, fp);
    for (int i = 0; i &lt; messages.length; i++) {
        Message message = messages[i];
        if (message.getFlags().contains(Flags.Flag.DELETED)) continue;
        System.out.println("message received: " + message.getSubject());
        if (!roster.constainsOneOf(message.getFrom())) continue;
        MimeMessage forward = new MimeMessage(session);
        Address[] fromAddress = message.getFrom();
        InternetAddress from = null;
        if (fromAddress != null &amp;&amp; fromAdress.length &gt; 0) {
            from = new InternetAddress(fromAddress[0].toString());
        }
        forward.setFrom(from);
        forward.setReplyTo(new Address[] {
            new InternetAddress(listAddress)
        });

        forward.addRecipients(Message.RecipientType.BCC, roster.getAddresses());
        String subject = message.getSubject();
        if (-1 == message.getSubject().indexOf(SUBJECT_MARKER)) {
            subject = SUBJECT_MARKER + " " + message.getSubject();
        }
        forward.setSubject(subject);
        forward.setSentDate(message.getSentDate());
        forward.addHeader(LOOP_HEADER, listAddress);
        Object content = message.getContent();
        if (content instanceof Multipart) {
            forward.setContent((Multipart)content);
        } else {
            forward.setText((String)content);
        }

        Properties props = new Properties();
        props.put("mail.smtp.host", host.smtpHost);

        Session smtpSession = Session.getDefaultInstance(props, null);
        Transport transport = smtpSession.getTransport("smtp");
        transport.connect(host.smtpHost, host.smtpUser, host.smtpPassword);
        transport.sendMessage(forward, roster.getAddresses());
        message.setFlag(Flags.Flag.DELETED, true);
    }
}
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>这段代码集中了所有劣质代码的特性，如可读性差，可测试性差，可重用性差，可扩展性差，也很难体现设计者的意图。</p>

<p>是的，意图！意图就是体现业务价值的关键所在，最好能够通过类的名称直接传达这种业务价值。显然，上述代码完全没有做到这一点。通过仔细阅读这段代码，然后从职责的角度入手，就驱使我们思考它究竟做了什么？显然，这段代码的功能就是侦听邮件服务器，并根据实现给定的邮件名单，将收到的邮件转发给邮件名单的相关人士。所以，它的业务价值就是转发邮件。</p>

<p>要做到转发邮件，基本的功能是要能够侦听邮件服务器。我们可以将侦听看做是业务功能。通常，对于实际的需求而言，职责模型并非简单的三层结构，它可能是一种递归的方式，也即可以对业务价值、业务功能甚至业务实现进行不断深入的分解。例如，对于这里的侦听业务功能而言，还可以分解为下一个业务功能，即接收邮件。同时，要实现邮件的转发，还需要发送邮件的支撑。下面就是我们所能够识别出来的职责：</p>

<pre><code>* 转发邮件
    ** 侦听邮件
        *** 接收邮件
    ** 发送邮件
</code></pre>

<p>面对如此简短的职责描述，再要识别对象所要封装的概念就变得非常容易了。下图是根据识别出来的职责获得的类图结构：
{% img center /images/2013/02/responsibility04.png %}</p>

<p>比较这个设计模型与之前的代码，新的模型无疑在职责分配上占了胜场。并且，每个对象的名称都很好地传达了它所能完成的功能。由于封装将职责的实现细节有效地隐藏，并为它们各自划分了空间，形成各自的职责单元，然后再以弱耦合的形式进行协作。因而，我们可以很容易地对它们进行单元测试，或者对参与协作的行为进行Mock。接口的引入则是为了未来的功能扩展，例如我们不再使用javax.mail库来实现邮件收发，就可以提供不同的实现类。可独立封装的MessageReceiver与MessageSender还可以为系统的其他模块所重用。职责与封装相得益彰，有效地改善了整个设计模型。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[对象的角色]]></title>
    <link href="http://agiledon.github.com/blog/2013/02/05/role-of-object/"/>
    <updated>2013-02-05T21:55:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/02/05/role-of-object</id>
    <content type="html"><![CDATA[<p>{% img center /images/2013/02/roleofobject.png %}</p>

<p>若要获得良好的对象设计，就必须对职责进行合理的分配。每个对象承担的职责不能太多，也不能太少，恰如其分即可。职责分配如乐谱中对音符的组织，高明的音乐家总是能让不同的音符放在合理的位置，奏成悦耳的心曲，表达音乐家的内心感情。然而，即使设计师明确职责分配的重要性，在面临纷乱复杂的需求时，常常被乱花迷了眼，或者无法识别正确的职责，又或者顾此失彼，将职责放错了位置，变成了对职责混乱的涂鸦。</p>

<p>要识别职责，进而合理分配职责，有许多秘诀，或云“技巧”。不过，将对象的角色作为职责分配的开始，不失为一个好的起点。角色是对象的身份，若以拟人化的方式思考对象世界，就可以设想：究竟是怎样的身份，需得承担怎样的职责，才会与其身份相当，不至于乱了规矩。红楼梦中，刘姥姥进了大观园，出尽了洋相，就是因为身份失当；又可以想想倘若林黛玉像尤三姐那般爱恨分明，也不至于见花落泪，惹人爱怜了。故而在分配职责时，我们能首先明确对象的角色，即可将思想带入到这一角色中，设身处地，推断这一角色可以或者必须承担哪些职责。</p>

<p>在<a href="http://product.china-pub.com/30653">Object Design:Roles, Responsibility, and Collaborations</a>一书中，将对象的角色分为了五种，分别为信息持有者、构造者、服务提供者、协调者和控制者。这种分类差不多涵盖了对象在软件系统中扮演的角色。以此为基础，在进行软件设计时，可以思考你要设计的对象，究竟属于哪一种角色。</p>

<!--more-->


<h4>信息持有者角色</h4>

<p>首先来看信息持有者。顾名思义，这种角色的对象必然持有相关的信息。不过，俯瞰对象世界，除了某些特殊的行为对象而言，大多数对象都必然持有相关的信息。所以，这里的角色划定，其主要意图在于让设计者明确，与信息相关的行为，如处理信息的方式，信息变化造成的影响等，都应首先考虑是否由该信息的持有者来承担。这近似于Larman在<a href="http://book.360buy.com/10057823.html">Applying UML and Patterns</a>一书中提到的“信息专家模式”。</p>

<p>例如，我们需要设计一个Web服务器，它提供了一个对象HttpProcessor，能够接收由HttpConnector发送来的Socket请求，对Request进行处理，并在处理后将相关信息放入Response中。请求和响应被封装在对应的HttpRequest和HttpResponse对象中。在处理请求和响应信息时，需要对Socket消息进行处理，并为Request和Response对象设置相关属性。我们当然可以在HttpProcessor中处理对这些消息的解析工作，但涉及到Request和Response自身的信息，遵循信息持有者角色的要求，最好还是将这些处理逻辑封装到各自对象中。如下图所示：
{% img center /images/2013/02/infoholder.png %}</p>

<p>遵循信息持有者的特征，HttpProcessor、HttpRequest与HttpResponse之间的权责变得更加清晰。此外，这一设计方式还有利于改善性能。某些Http请求解析可能牵涉到系统开销较大的字符串操作，而解析的内容并不是在一开始就需要使用。将解析职责转移到HttpRequest中，就使得HttpProcessor的process()操作可以快速完成，并将相关请求数据流塞到HttpRequest对象中。只有真正需要相关请求信息时，才向HttpRequest对象发出解析的请求消息。这种方式颇像是对象的Lazy Load。</p>

<h4>构造者角色</h4>

<p>构造者角色主要承担对象的创建，以及对复合对象的组装。如果熟悉设计模式，可以发现构造者角色基本上囊括了构造型模式的意图。例如创建对象，组合对象，以及选择对象构造的方式。此外，还有一种特殊的构造者角色对象，即它可能具有双重角色，一方面作为构造者角色，另一方面也作为构造者所创建出来的产品。这种双重角色的构造者角色，常常会形成一条构造链。例如，在JMS中，若要获得Queue对象，就可能由ConnectionFactory对象创建出Connection对象，则通过该对象创建Session对象，最后由Session对象创建的Queue。如下图所示：
{% img center /images/2013/02/constructor.png %}</p>

<p>为何我们需要构造者角色？毕竟对象自身可以拥有构造函数，以提供给调用者完成对象的创建。通常情况下，之所以引入构造者角色，主要是为了：</p>

<p>（1）为了应对创建的变化；</p>

<p>（2）为了隐藏对象创建的复杂逻辑；</p>

<p>（3）为了控制对象创建的时机或数量。</p>

<h4>服务提供者角色</h4>

<p>关于服务提供者，一个重要认识是：它能提供具有“业务价值”的行为。所谓“业务价值”，即一定是实现业务逻辑中不可缺少的，且相对独立完整的功能。这就意味着，担任服务提供者角色的对象，常常是一个职责完备地，实现了某个业务关注点的可重用对象。此外，业务价值是有层次之分的。在最外层，可能意味着一个完整的业务流程，此时服务对象暴露给客户端的，是一个封装了服务实现细节的对象（可能是接口）；而为了实现该外层服务，又可能在整个实现中，需要更为细粒度的内层服务对象提供各个实现步骤的支撑。例如系统需要生成税务报表，假设它的业务流程是读取报表数据后，对数据流进行处理，并以HTML格式呈现，然后生成PDF文件。对外而言，税务报表的生成就应该是一个完整的服务，且对于客户端的调用者而言，其实根本不需要了解其实现细节。此时，我们可以定义一个TaxReportGenerator对象，它能够接收报表数据，并生成报表的PDF文件。显然，它具有非常重要的业务价值。</p>

<p>接下来考虑该对象的内部实现。由于报表生成需要执行多个业务步骤，如果将这些职责均交给TaxReportGenerator来处理，无疑会导致该对象承担过重的职责。此外，呈现HTML格式与PDF文件生成对于报表生成而言，不过是整个业务流程中的一环；但从单个职责而言，无疑它们也是独立的。可以设想，倘若系统还有其他业务功能需要生成PDF文件，又或者需要按照规定形式呈现为HTML页面，将这些职责封装到单独的职责中，就可能很好地支持重用。从“业务价值”的角度看，它们无疑具备了服务提供者的能力。整个TaxReportGenerator对象的内部协作如下图所示：
{% img center /images/2013/02/serviceprovider.png %}</p>

<h4>协调者角色</h4>

<p>协调者有些像设计模式的Mediator模式所要承担的职责，即用于协调对象职责的协作，又或者负责转发或委派请求。协调者是孜孜不倦助人为乐的居委会大妈，既善于也乐于协调邻里之间的纠纷。除了可以以中间人的身份协调对象，从而简化对象之间的协作，以降低复杂的依赖关系外，协调者还能很好地隐藏这些交互细节。这就使得调用者变得简单，还能让这种关系协调的实现集中在一处，即使将来协调关系发生了变化，也可以做到仅修改一处，即可应对变化。从这一点来看，似乎协调者又体现了Facade模式。</p>

<p>在一个大型复杂系统中，提供了许多Web Service。不同的Web Service可能需要支持不同的消费者，而这些服务的部署位置也可能并不相同。消费者需要准确定位到相关服务，然后通过一些相对复杂的实现逻辑，完成对服务的调用。这类逻辑就牵涉到消费者、服务以及服务调用与服务位置之间的协作。如果没有合适的对象去封装，既可能导致细节暴露，增加复杂度，也无法做到有效重用。一旦协作的逻辑发生变化，可能还会导致这种变化蔓延到系统的各个地方。这时，就是体现协调者角色价值所在了。在这个场景下，我们可以引入ServiceLocator对象来负责整个协调逻辑，它能够根据消费者请求的服务类型，定位服务，然后找到服务端口，发送服务请求。下图展示了这种协调逻辑的具体做法，注意不同的服务消费者都经由相同的ServiceLocator角色完成了不同的服务调用：
{% img center /images/2013/02/colaborator.png %}</p>

<h4>控制者角色</h4>

<p>看到控制者，或许我们会想到MVC模式的Controller。确乎它们具有相似的特性，即用于控制多个对象之间的交互，甚至是驱动对象。或者，我们可以将这里所谓的控制者角色，看做是Controller的外延，即它具有更加宽泛的职责意义。凡是需要控制角色交互，并具有一定控制逻辑的对象，均可看做为控制者角色。注意，控制者角色与协调者角色的区别，最为明显的区别在于前者多少具有一定的管理特征，被控制的对象似乎在级别上低于控制者角色；而后者则体现一种平等的层级关系。前者是政府官员，后者是居委会大妈。</p>

<p>当然，在设计时，有时似乎也很难泾渭分明地界定这二者。这就好似用例中的使用与扩展关系，许多设计者还在孜孜以求，绞尽脑汁地要分辨出二者的不同，以保证正确地运用用例关系，求得完美的设计，孰知早有用例专家给出忠言，不必一定区分使用与扩展，它对用例的编写不会产生直接的重大影响。参考此例，我也希望设计师不必去钻牛角尖，只需明白此两种角色，其本质还在于隐藏对象的协作或交互细节，降低复杂度，保证重用以及对变化的应对。</p>

<p>在软件设计中，我们经常遇到控制者角色。一个常见的例子是由控制者角色承担判断逻辑，根据不同的请求，经由不同的分支，调用不同的对象来应对此请求。例如在一个系统中，我们需要对页面的内容合法性进行验证。不同的内容对验证的要求不尽相同。一个简单的判断是看内容是否只需要对页面头进行验证。我们在设计时，引入了ValidationProcessor来控制这种验证逻辑。站在调用者的角度，验证的事情交给ValidationProcessor去处理就好。管它是否仅是一个控制枢纽，真正的验证却是它要委派的对象呢？
{% img center /images/2013/02/controller.png %}</p>

<p>当然，在这里的ContentController同样属于控制者角色，它事实上就是MVC模式中的Controller，用于控制Content与ContentView之间的交互。ValidatorProcessor与MVC风马牛不相及，但它仍可以看做是控制者角色。</p>

<p>如果我们能识辨出系统模型中各种对象的角色，就可以根据角色的特征来分配角色。又或者，我们可以根据角色来判别现有的职责分配是否合理，是否均衡，甚至能够帮助我们找到缺失的对象。除了信息持有者角色，其余四种角色通常不会出现在领域模型中，它们事实上都属于设计对象。但它们在软件设计中的地位却举足轻重，没有它们，设计就可能走向混乱，无法保证重用性与扩展性，并导致系统对象之间的协作变得复杂。每当我们在分配职责时，若有顾此失彼的感觉存在，就可能说明缺乏了承担不同角色作用的这一类设计对象。找到它，并给它以承担职责的权利，设计一定会大为改观。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计模式的一些变化]]></title>
    <link href="http://agiledon.github.com/blog/2013/02/02/change-of-design-patterns/"/>
    <updated>2013-02-02T22:28:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/02/02/change-of-design-patterns</id>
    <content type="html"><![CDATA[<p>经历了几次过度设计，我对一些设计模式开始抱有谨慎的戒惧。我希望能够合理地运用设计模式，而非为模式而模式。事实上，现在的我较少会有意识地运用设计模式；更多地是通过职责来驱动，以期获得合理的职责分配。之后，再通过辨别代码的坏味道，运用重构来改善设计。大多数情况下，这种方式对于设计而言，已经足够。不过，有时我们仍有必要根据具体场景，做出合理判断和决策。</p>

<p>我曾经遭遇的一个Story，是要实现一个Web Service，提供update的服务接口。需求要求对服务的Request进行验证。这一验证功能并非Story的核心功能，但其逻辑却比核心逻辑复杂数倍。它需要针对不同情况，遵循多个规则验证Request。这些验证逻辑如此的复杂，以至于我们可以在第一时间做出判断，它必须是单独的职责，绝对不适合放到Service对象中。</p>

<p>这种职责分离还不够。因为每一条验证规则，都可以视为一个单独的验证职责。若将每种验证规则封装为一个验证对象，就能很好地满足SRP。每个验证对象只需要做好自己的事情即可，结果只有两个，要么错误，要么通过。若当验证逻辑为一个整体，则可以理解为：只要违背了一条验证规则，出现错误，则可以视为验证不通过；否则将继续验证下一条规则。</p>

<!--more-->


<p>乍一看来，这完全符合职责链模式的要求。我的Pair也完全同意了这一点。当我们按照这一思路进行编码时，我的疑惑随着步伐的前进，变得愈深，好像有什么东西在拽着自己，阻止我们前进。因为我们使用了Spring，故而需要将这个职责的链条通过依赖注入的方式拼接。为了迎合这种要求，标准的职责链模式需要微调。例如，我们写出这样的职责链超类：
``` java
public abstract class UpdateRequestValidator {</p>

<pre><code>private UpdateRequestValidator nextValidator;
public UpdateRequestValidator(UpdateRequestValidator nextValidaor) {
    this.nextValidator = nextValidator;
}

public ValidateResult validate(UpdateRequest request) {
    ValidateResult result = doValidate();
    if (result.isError()) {
        return result;
    }
    return nextValidator.validate();
}

protected abstract ValidateResult doValidate();
</code></pre>

<p>}
```</p>

<p>如果仔细分析这段代码，可以发现我们是在运用装饰器模式的手法来实现职责链。这就让人感到奇怪了。由于我们自定义了构造函数，要求传入一个UpdateRequestValidator，似乎可以避免对nextValidator非空的判断。可是，链条的末尾又该放入哪个对象呢？为此，我们还定义了一个NullValidator，它什么都不做，并被要求放到职责链构造的最末尾。</p>

<p>够奇怪吧。这里我们对Spring的配置做出了假设，一厢情愿地要求NullValidator必须作为职责链的最后一个。可是，我们却未对这种假设做出任何约束。</p>

<p>与其如此别扭，还不如对设计做出调整。只要验证逻辑的职责分离与封装是合理的，我们未必一定要运用职责链模式（或者这种不伦不类的装饰器模式）。抛开这种约束后，每个Validator就可以变得更单纯，无需假设这个链条的组成；而是将这个链式逻辑转交给包含了UpdateRequestValidator列表对象的Validator对象，它可以被看成是Validator的合成对象：
``` java
public interface UpdateRequestValidator {</p>

<pre><code>ValidateResult validate(UpdateRequest request);
</code></pre>

<p>}
public class CustomerNotFoundValidator implements UpdateRequestValidator {</p>

<pre><code>@Override
public ValidateResult validate(UpdateRequest request) {
    //do something;
}
</code></pre>

<p>}
public class CompositeUpdateRequestValidator implements UpdateRequestValidator {</p>

<pre><code>private List&lt;UpdateRequestValidator&gt; validators;
@Required
public void setValidators(List&lt;UpdateRequestValidator validators) {
    this.validators = validators;
}
@Override
public ValidateResult validate(UpdateRequest request) {
    ValidateResult result;
    for (UpdateRequestValidator validator : validators) {
        result = validator.validate(request);
        if (result.isError()) {
            return result;
        }
    }
    return result;
}
</code></pre>

<p>}
```</p>

<p>我觉得修改后的设计意图清晰许多了，并且，它对使用者没有了隐含的约束，在Spring的ApplicationContext配置文件中，也能够很好地将我们单独实现的Validator作为List的元素配置给CompositeUpdateRequestValidator。我喜欢这样的调整。</p>

<p>我对装饰器模式持同样态度。正如有人说道：装饰器模式的方式有些像洋葱。洋葱的味道虽好，不过在剥洋葱时，却要小心不要被呛出眼泪。在阅读<a href="http://www.axonframework.org">Axon Framework</a>的源代码时，我发现一种设计方式，可以避免装饰器模式的洋葱构造，却能达到同样的装饰效果。我将其成为Interceptor模式。</p>

<p>需求是希望对CommandHandler对象的命令请求进行包装（或装饰），例如为命令请求提供日志或事务功能。这些功能可以是组合的。传统的方式是运用装饰器模式，例如：
``` java
public interface CommandHandler {</p>

<pre><code>void handle();
</code></pre>

<p>}
public class LoggingCommand implements CommandHandler{</p>

<pre><code>private CommandHandler commandHandler;
public LoggingCommand(CommandHandler commandHandler) {
    this.commandHandler = commandHandler;
}

@Override
public void handle() {
    logInfo("begin execute command");

    commandHandler.handle();

    logInfo("end execute command");
}
</code></pre>

<p>}
public class TransactionCommand implements CommandHandler {</p>

<pre><code>private CommandHandler commandHandler;
public TransactionCommand(CommandHandler commandHandler) {
    this.commandHandler = commandHandler;
}

@Override
public void handle() {
    myTransaction.beginTransaction();
    try {
        commandHandler.handle();
        myTransaction.commitTransaction();
    } catch (Exception ex) {
        myTransaction.rollbackTransaction();
    }
}
</code></pre>

<p>}
```</p>

<p>假设有一个命令对象PlaceOrderCommandHandler，同时需要日志和事务功能，就需要如下构造方式：
<code>java
CommandHandler command = new TransactionCommand(new LoggingCommand(new PlaceOrderCommandHandler()));
</code></p>

<p>这种构造方式既复杂，也不容易使用Spring来注入。Axon的设计方式转变了设计视角，将这种对命令的包装，看做是对命令请求的一种拦截，这就好似AOP的pointcut一般。它定义了一个InterceptorChain，负责完成整个拦截器链条的组装，并将这些拦截职责通过Chain完成一层层的传递。设计如下：
``` java
public interface CommandHandlerInterceptor {</p>

<pre><code>void handle(InterceptorChain interceptorChain);
</code></pre>

<p>}
public class LoggingInterceptor implements CommandHandlerInterceptor {</p>

<pre><code>@Override
public void handle(InterceptorChain interceptorChain) {
    info("LOG: begin");
    interceptorChain.proceed();
    info("LOG: end");
}
</code></pre>

<p>}
public class TransactionInterceptor implements CommandHandlerInterceptor {</p>

<pre><code>@Override
public void handle(InterceptorChain interceptorChain) {
    transaction.beginTransaction();
    try {
        interceptorChain.proceed();
        transaction.commitTransaction();
    } catch (Exception ex) {
        transaction.rollbackTransaction();
    }


}
</code></pre>

<p>}
public class InterceptorChain {</p>

<pre><code>private Iterator&lt;? extends  CommandHandlerInterceptor&gt; interceptorChain;
private CommandHandler handler;

public void proceed() {
    if (interceptorChain.hasNext()) {
        interceptorChain.next().handle(this);
    }

    handler.handle();

}

@Required
public void setHandler(CommandHandler handler) {
    this.handler = handler;
}

@Required
public void setInterceptorChain(Iterator&lt;? extends CommandHandlerInterceptor&gt; interceptorChain) {
    this.interceptorChain = interceptorChain;
}
</code></pre>

<p>}
```</p>

<p>在InterceptorChain类中，handler对象就是我们要包装（或者说拦截）的命令对象。注意，Interceptor对象的handle()方法，是将InterceptorChain对象作为参数传入的。于是就形成了如下的方法调用时序：
{% img center /images/2013/02/interceptor.png %}</p>

<p>只要理解了InterceptorChain起到的委派传递作用，就能很好地理解这个设计。这种方式将之前装饰器模式那种洋葱式的构造转移到列表中，并通过迭代器进行迭代。同时，它将对CommandHandler以及相关拦截器对象的依赖转移到了外面，很好地支持IoC容器对依赖的注入，从而使得代码可以变得更简单，更灵活。</p>

<p>总之，当我们在运用设计模式时，一定要结合当前上下文，对设计模式做出合理的判断，甚至可以大胆地对GOF总结的设计模式进行大刀阔斧地挑战或修改。关键还在于把握设计模式的核心原则，并在“简单设计”的前提下，做出设计的决策。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文学与软件]]></title>
    <link href="http://agiledon.github.com/blog/2012/12/21/literature-and-software/"/>
    <updated>2012-12-21T18:59:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2012/12/21/literature-and-software</id>
    <content type="html"><![CDATA[<p>{% img left /images/2012/12/dafenqi.jpg 182 276 %}</p>

<p> 卡尔维诺在哈佛大学的文学讲座（即诺顿论坛，是为纪念美国著名学者诺顿开设的，每年邀请世界文化名人作讲座，艾略特、博尔赫斯也曾获邀参加诺顿讲座）被他的妻子编成了一本独立的书《美国讲稿》。这本书展现了卡尔维诺的文学精神，体现了他的文学态度和气质。不过，我在阅读该书时，却发现了一些与编程有关的内容。</p>

<p>1、文学中的重构</p>

<p> 达芬奇在《大西洋草图》中记述了他幻想中海怪的形象，进行了前后三次重构。最初的描述是：</p>

<p><strong>啊，人们多次在波浪翻滚的广阔海洋之中看到你，看到你那长满鬃毛的黑色背脊，你像一座大山，傲慢地徐徐前进！</strong></p>

<!--more-->


<p>然后，他试图使海怪的行动生动些，加了个动词“翻转”：</p>

<p><strong>啊，人们多次在波浪翻滚的广阔海洋之中看到你，看到你在海水中傲慢地徐徐翻转身躯，看见你那长满鬃毛的黑色背脊。你像一座大山屹立在海浪之上！</strong></p>

<p>然而，他觉得“翻转”这个词削弱了他想留给人们的那种雄伟与庄严的印象，于是选择了“分开”这个动词，并改变了句子结构，使句子变得更紧凑，更有节奏。</p>

<p><strong>啊，人们多次在波浪翻滚的广阔海洋中看到你！你像一座山屹立在海浪之上。你傲慢地徐徐前进，用那长满鬃毛的黑色背脊把海水分成两半!</strong></p>

<p>在文学创作中，重构其实会经常发生，这源于作家对文学作品高质量追求的精益求精，他们常常通过修改句式，修辞手法或改变词语来改善文字，使之体现恰如其分的美。编码艺术同样如此，即使是代码的结构，以及变量、方法和类的命名，排版样式，只要给予足够的重视，锤炼这方面的技能，坚持重构，就能改善编码质量。</p>

<p>2、封装与接口</p>

<p>卡尔维诺在“精确”一章中引述了哲学家们对语言和外部世界关系的思考：</p>

<p><strong>使用语言是对事物的不断追求，不是渐渐接近事物的本质而是接近事物那无休止的变化，接近事物那多种多样的、无穷无尽的表面。正如霍夫曼斯塔尔所说：“深层应该掩盖起来。掩盖在哪里？掩盖在表层下面。” 维特根斯坦走得更远，他说：“凡被掩盖的东西，我们都没有兴趣。”</strong></p>

<p>在软件开发中，我们常常运用封装来隐藏内部的实现细节。它带来的好处是使得调用变得简单，重用成为可能，很好地隔离了内部实现的变化。当然，文学更善于挖掘内部的玄奥，却常常使用抽象的语言描述出一种晦涩，试图掩盖这种玄奥，以此追求一种寻找“高山流水”知音般心灵激荡的玄妙与浃肌沦髓。</p>

<p>文学也尝试用变化去处理变化，这似乎矛盾，却恰好是文学艺术让人着迷的地方。软件又何尝不是如此。卡尔维诺看到了两种变与不变的模式：</p>

<p>最近我偶然读到生物形成过程的模式：“一边是晶体（象征表面结构稳定而规则），一边是火焰（虽然它的内部在不停地激荡，但外部形式不变）。”……火焰与晶体这两种形象代表了生物学上的两种选择。</p>

<p>皮亚杰观点的哲学蕴含是“从噪音到有序”，即火焰；乔姆斯基观点的哲学蕴含是“自我编制系统”，即晶体。</p>

<p>{% img right /images/2012/12/america.jpg 189 266 %}</p>

<p>这仿佛让我洞悉了面向对象设计的玄机。火焰代表了接口，无论如何变化，其外部形式总是不变。接口的引入使得软件设计可以从混沌（即皮亚杰所说的“噪音”）走向有序。至于晶体，则是遵循了信息专家模式的对象，因为它封装了数据以及操作该数据的行为，使得它具有了自我判断的意识。它的表面结构仍然是稳定的，却有一套自我约束的规则。晶体看起来是宁静的，而火焰却如此的灵活。融合晶体与火焰的系统，是否代表了对变化的封装，以及对不变概念的抽象呢？</p>

<p>3、纠缠的细节</p>

<p>薄伽丘在一篇故事中（《十日谈》第六天第一个故事）谈到讲故事的艺术，正好回顾了这种感觉。</p>

<p>**“奥丽达太太，要是你不讨厌的话，我想讲一个世界上最大的故事给你听，叫你听得津津有味，就像骑了一匹马一样，往了路途的遥远。”</p>

<p>“啊，再好没有了，先生，”那位太太说，“请你快给我讲一个故事吧。”</p>

<p>于是绅士开始讲故事给她听。故事倒很精彩，可惜他讲故事的本领，只抵得上他使用他身边那把佩剑的工夫，实在太不高明，时常把一句话颠来倒去的说了又说，甚至说上六七遍，过了一会，忽然又倒过头来说道：“哎呀，我说错啦！”对于故事中的人名地名常常纠缠不清，张冠李戴，弄得别人莫名奇妙。他那说话的声气又跟故事里的人物、情景一点都配不上，真是听得奥丽达太太头晕目眩，冷汗一身，只觉得大祸临头，连命都快要保不住了。到最后，她忍无可忍，又看见那位绅士正愈说愈糊涂，已经迷了路，失了方向，只是在那儿团团打转，再也跑不出来了，就和悦地对他说：“先生，你那匹马跑得太野，请你还是让我下了马吧。”**</p>

<p>在软件设计过程中，最要紧的是思路要清晰，既不能迷失在需求分析中，也不能迷失在复杂的实现细节中。最好能够结合实际的场景，列出我们要达到的目标，需要完成的任务，有序地进行分析和设计。编写代码时，切忌功能之间互相纠缠，虽然体现了对象的协作，但由于职责分配混乱，使得对象之间的协作变得无规律可循，颠三倒四，最后让人忍无可忍，也只能翻身下马了。</p>
]]></content>
  </entry>
  
</feed>
