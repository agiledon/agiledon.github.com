<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[逸言]]></title>
  <link href="http://agiledon.github.com/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2015-01-05T11:25:23+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Efficient Tools We Recommended]]></title>
    <link href="http://agiledon.github.com/blog/2015/01/05/efficient-tools-we-recommended/"/>
    <updated>2015-01-05T11:17:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2015/01/05/efficient-tools-we-recommended</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2015/1/efficiency.jpg"></p>

<p>几天前，ThoughtWorks China咨询师团队召开了一次团结的大会，成功的大会。为期三天的会议，分享的内容并不亚于坊间举行的技术大会，包含了敏捷组织转型、C++重构、敏捷测试体系、持续交付整体解决方案、Spark执行模型、机器学习、Scala代码操练。课题五花八门，争辩激烈精彩。</p>

<p>临近尾声，洪敏提了一个好建议，让大家推荐自己平时用的高效率工具，于是就有了如下的一个清单。以下工具排名不分先后。</p>

<ol>
<li><p>Pocket：一款超极好用的内容收藏工具，正如其名，像口袋一般方便。Pocket提供了各种形式的应用，包括Mac下的App、各种移动设备包括iphone、ipad、android、windows phone的APP以及网页版。同时它为firefox、chrome、safari、Opera提供了插件。当我们在浏览网页时，若发现内容精彩需要收藏，只需点击插件上的按钮，即可收藏，并能将收藏的内容同步到不同平台下的pocket中。我通常使用Pocket来收藏内容，而用EverNote来记录笔记，各有分工。</p></li>
<li><p>Spectacle：这并非Google眼镜，而是一个超炫的Geek工具，因为它帮我们定义（或者自定义）了诸多快捷键，使得我们无需使用鼠标，即可非常方便地移动窗口，改变窗口大小。</p></li>
<li><p>Skitch：来自EverNote，正如宣传所言“一圈一点”。在电脑、平板和手机上随时使用Skitch，轻松表情达意。堪称制作幻灯片神器啊。制作的图片还可以同步到EverNote中。</p></li>
<li><p>AutoJump：自动补完不算什么，一键直达目录才是终极神器。autojump是一个命令行工具，通过执行autojump [target directory]，就可以直接到达你想要去的目录。</p></li>
<li><p>Any.Do：非常简单方便的todo list工具，可以帮助你快速地安排好今天、明天、将来想要做的事情。它的使用极为简单，只需手指轻轻一划，即可添加或删除待办项，非常符合我们操作手机的习惯。</p></li>
<li><p>Anki：要记住一些事情是需要方法的，同时还得善于利用时间。Anki通过创建flash card，然后自己编辑卡片的前后两面。前面为问题，后面为答案。一旦创建了卡片，随时就可以拿出来默记背诵。Anki支持Windows、Mac、Linux、iphone和Android等平台。利用Anki学习英语应该很不错，当然最重要的还在于持之以恒。</p></li>
<li><p>VisualGDB：一款用于开发和调试的IDE，集成了GCC和GDB，并可以将Remote Machine当做后端。可用于嵌入式和Android开发。</p></li>
<li><p>GoodReader：iPhone和iPad下的一款阅读软件，支持Office文档、PDF、TXT、HTML等文件浏览，支持视频、音频的播放(iPhone支持的媒体格式)，支持横屏，还可以通过WIFI与PC或MAC共享文件！GoodReader是收费软件，不过如果我们经常使用iPad阅读PDF文件，就非常值得购买该工具啦。</p></li>
<li><p>CLion：ThoughtWorks似乎一直比较钟爱JetBrains开发的IDE，例如针对JVM开发的IntelliJ Idea，Ruby的RubyMine，Python的PyCharm，JavaScript的WebStorm。针对C和C++，之前JetBrains有AppCode，但它是基于Mac开发的。现在，有了CLion这个更好地支持跨平台的C/C++开发工具。</p></li>
<li><p>FarBox：一个绝对轻量级的博客托管服务平台，因为它可以集成DropBox，操作博客如在本地创建文件一般简单。结合Markdown，可以更好地发挥威力。当然，如果是托管到GitHub上，则推荐使用Octorpress。</p></li>
<li><p>youtube-dl：还在为不能方便地下载youtube视频而烦恼吗？可以试试youtube-dl命令行工具，可以通过homebrew安装。安装后，可以直接输入youbube-dl <url>即可下载。你若是觉得命令太长，也可以设置别名，例如dl。当然，前提是你能够访问youtube。</p></li>
<li><p>Chrome vi：这是一款针对Chrome的插件，它使得你可以像操作vi那样操作Chrome。这样，在Chrome网页下就不需要操作鼠标去定位了，只需按下f键，chrome vi插件就会为网页上所有可定位的位置提供快捷键提示，然后通过敲击键盘对应的快捷键，就可快捷地将光标定位到对应位置进行操作。</p></li>
<li><p>clang-format：代码格式化工具。</p></li>
<li><p>cheat：linux命令小抄，比help和man命令更容易理解。cheat会告诉你一个命令如何使用，它没有提供其他额外多余的信息，只通过使用实例告诉你一个命令如何使用。</p></li>
<li><p>Alfred：这个不用讲了吧，用Mac的人如果不用Alfred，只能说out了。而且通过Alfred还可以定制workflow，这样可以更好地发挥Alfred的强大功能。</p></li>
</ol>


<p>嗯，还有很多可以提高工作效率的工具。合理地使用这些工具，就可以留出更多的时间去学习、思考。这或许正是高效人士的秘诀。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[代码的体格]]></title>
    <link href="http://agiledon.github.com/blog/2014/12/16/the-figure-of-code/"/>
    <updated>2014-12-16T17:05:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/12/16/the-figure-of-code</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2014/figure.jpg">
<strong>图片选自俄罗斯画家、美术理论家瓦西里·康定斯基作品。</strong></p>

<p>Steve Yegge在他特立独行的作品《程序员的呐喊》中写道：“我坚信代码最大的敌人就是体格”。不过他过于自大了，以为这只是像他那样牛逼的程序员才拥有的少数派观点；又或者说他过于悲观，以为程序员的世界还在拼代码的肌肉男臆想中。殊不知只要是曾经挣扎在庞大代码库泥潭中的程序员，就不会盲目崇拜代码的大块头。</p>

<p>可惜，“知行合一”非圣人不可以做到，梦想的光芒常常难以照进现实的阴影。要缩小代码的体格，似乎比减肥还要艰难。软件系统像一条贪吃蛇，吃掉一切功能，最后越变越长，在局限的空间里再也无法做到从容的转折腾挪，最后活活困死。偏偏还有人以能掌控千万级代码的软件系统为荣。——“兄弟不才，做过一系统，代码达到了两千万行，真是一场噩梦啊！”，程序君一边摇头作痛苦状，嘘声叹气，但察其眼角眉间，藏不住的却是得意和炫耀。</p>

<p>因而，我们一边在愤慨代码日益膨胀的体格，一边又在做着堆代码的增肥工作。软件从来都不是一个人写完的，需求也从来不会稳定不变，于是乎出现了超过数个屏幕的分支语句，出现了大量注释过的代码残骸，于是乎有了拷贝粘贴，程序员渐渐开始降低坏代码的容忍度，开始得过且过。</p>

<p>面对日益膨胀的代码体格，Steve的呐喊是换语言，因为他是Ruby粉和Python粉的缘故，恨不得把所有系统都换成Ruby或者Python，要么就是Lisp。作为Scala粉的我，当然也恨不得所有Java项目都换成Scala。让我再写啰嗦的Java代码，真是痛不欲生，生不如死啊。支持了lambda的Java 8也许还能挽救我，但我还是钟情Scala。</p>

<p>太天真了！首先是换不了，其次是换了也没用。你真以为换语言如换刀，宝刀在手，就能割去那些臃肿的代码，还代码一个苗条身材？——你以为是抽脂啊！Ruby也可以写出烂代码，Java也能写出漂亮的程序，关键不在于语言。正如武林高手比武并不在于刀剑的利钝，要分出武功高低，根本还是功力和招式。只有同等高手之间的厮杀，手握一柄利器才能成为制胜法宝。</p>

<p>代码的臃肿关键还在于分解与去重。Unix大吗？大，而且必须大。但它又很小，因为它以内核形式确立了系统的边界，同时遵循KISS原则，将大功能分解为小程序，每个小程序只能完成一个功能，任何复杂的操作都必须分解成一些基本步骤，由这些小程序逐一完成，再组合起来得到最终结果。分解的一个难题是如何定边界，换言之就是如何做到“高内聚、松耦合”。另一个难题在于组合，即该如何把这些分解的细小功能再糅合起来，形成一个整体。这也是为何Micro Service被鼓吹了多少遍，仍然有人保持观望态度的原因。</p>

<p>若说掌握分解这门技艺的高手中高手，还得数庖丁这哥们，“彼节者有闲，而刀刃者无厚，以无厚入有闲，恢恢乎其于游刃必有余地矣，是以十九年而刀刃若新发于硎。”眼睛都修炼成了X光，能够透过牛皮看清骨肉经络，以至于能够无厚入有闲，像舞蹈一般变屠牛为行为艺术，举手投足间，潇潇洒洒地把牛给宰了，还挥挥衣袖，不带走一点血。对软件系统的分解，我们能做到像庖丁那般识破依赖，判断“有闲”之节者，进而做到合理解耦吗？</p>

<p>去重的根本其实还是分解，粒度可以是函数、类、模块、子系统。程序员需要有洁癖，重复就是最大的dirty，可惜打扫卫生需要付出。写代码是件劳心劳力的事儿，总会有人偷懒的。Deadline又是一把悬在程序员头上的达摩克利斯之剑，在急迫的催促声中，程序员寻找到了心里安慰，因为时间是允许降低质量的最完美借口。——当然，时间也是最残忍的。程序员干的是刀口舔血的生活，出来混，迟早是要还的。程序世界，就是佛家所谓的“因果世界”啊。</p>

<p>去重的关键并不在于技巧（程序员都不是傻子，只要愿意学，什么技巧不能学会？），而在于勇气和决心。重复是敌人，而且是大块头的敌人，它就这般随意地站着，勾起小指头，傲慢地挑衅着你。而你，却未必有战风车的勇气。是明知必败吗？还是不可战胜？未战先怯，这场战争你已经败了。我见到的诸多遗留系统，重复代码都是这样开始蔓延的。——时间，见鬼的时间，其实大多数时候它都是你举白旗时找来贴脸的遮羞布。</p>

<p>我常常说程序员要懒，例如要把重复的过程变成自动化，例如不要重复制造轮子，例如竭力少写代码完成更多的事。可惜，我们多数时候把这种懒，用错了地方。懒于打扫，懒于行动，却又不计后果的吃，代码的体格怎么能够减得下来？就看着代码的体格一天天膨胀下去，然后呜呼哀哉吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spark的现状与未来发展]]></title>
    <link href="http://agiledon.github.com/blog/2014/11/18/present-and-future-of-spark/"/>
    <updated>2014-11-18T13:03:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/11/18/present-and-future-of-spark</id>
    <content type="html"><![CDATA[<h2>Spark的发展</h2>

<p>对于一个具有相当技术门槛与复杂度的平台，Spark从诞生到正式版本的成熟，经历的时间如此之短，让人感到惊诧。2009年，Spark诞生于伯克利大学AMPLab，最开初属于伯克利大学的研究性项目。它于2010年正式开源，并于2013年成为了Apache基金项目，并于2014年成为Apache基金的顶级项目，整个过程不到五年时间。</p>

<p>由于Spark出自伯克利大学，使其在整个发展过程中都烙上了学术研究的标记，对于一个在数据科学领域的平台而言，这也是题中应有之义，它甚至决定了Spark的发展动力。Spark的核心RDD（resilient distributed datasets），以及流处理，SQL智能分析，机器学习等功能，都脱胎于学术研究论文，如下所示：</p>

<blockquote><p>Discretized Streams: Fault-Tolerant Streaming Computation at Scale. Matei Zaharia, Tathagata Das, Haoyuan Li, Timothy Hunter, Scott Shenker, Ion Stoica. SOSP 2013. November 2013.</p>

<p>Shark: SQL and Rich Analytics at Scale. Reynold Xin, Joshua Rosen, Matei Zaharia, Michael J. Franklin, Scott Shenker, Ion Stoica. SIGMOD 2013. June 2013.</p>

<p>Discretized Streams: An Efficient and Fault-Tolerant Model for Stream Processing on Large Clusters. Matei Zaharia, Tathagata Das, Haoyuan Li, Scott Shenker, Ion Stoica. HotCloud 2012. June 2012.</p>

<p>Shark: Fast Data Analysis Using Coarse-grained Distributed Memory (demo). Cliff Engle, Antonio Lupher, Reynold Xin, Matei Zaharia, Haoyuan Li, Scott Shenker, Ion Stoica. SIGMOD 2012. May 2012. Best Demo Award.</p>

<p>Resilient Distributed Datasets: A Fault-Tolerant Abstraction for In-Memory Cluster Computing. Matei Zaharia, Mosharaf Chowdhury, Tathagata Das, Ankur Dave, Justin Ma, Murphy McCauley, Michael J. Franklin, Scott Shenker, Ion Stoica. NSDI 2012. April 2012. Best Paper Award and Honorable Mention for Community Award.</p>

<p>Spark: Cluster Computing with Working Sets. Matei Zaharia, Mosharaf Chowdhury, Michael J. Franklin, Scott Shenker, Ion Stoica. HotCloud 2010. June 2010.</p></blockquote>

<p>在大数据领域，只有深挖数据科学领域，走在学术前沿，才能在底层算法和模型方面走在前面，从而占据领先地位。Spark的这种学术基因，使得它从一开始就在大数据领域建立了一定优势。无论是性能，还是方案的统一性，对比传统的Hadoop，优势都非常明显。Spark提供的基于RDD的一体化解决方案，将MapReduce、Streaming、SQL、Machine Learning、Graph Processing等模型统一到一个平台下，并以一致的API公开，并提供相同的部署方案，使得Spark的工程应用领域变得更加广泛。</p>

<!-- more -->


<h2>Spark的代码活跃度</h2>

<p>从Spark的版本演化看，足以说明这个平台旺盛的生命力以及社区的活跃度。尤其在2013年来，Spark进入了一个高速发展期，代码库提交与社区活跃度都有显著增长。以活跃度论，Spark在所有Apache基金会开源项目中，位列前三。相较于其他大数据平台或框架而言，Spark的代码库最为活跃，如下图所示：
<img class="center" src="http://agiledon.github.com/images/2014/11/spark_commit.png"></p>

<p>从2013年6月到2014年6月，参与贡献的开发人员从原来的68位增长到255位，参与贡献的公司也从17家上升到50家。在这50家公司中，有来自中国的阿里、百度、网易、腾讯、搜狐等公司。当然，代码库的代码行也从原来的63,000行增加到175,000行。下图为截止2014年Spark代码贡献者每个月的增长曲线：
<img class="center" src="http://agiledon.github.com/images/2014/11/contributors.png"></p>

<p>下图则显示了自从Spark将其代码部署到Github之后的提交数据，一共有8471次提交，11个分支，25次发布，326位代码贡献者。
<img class="center" src="http://agiledon.github.com/images/2014/11/commit_history.png"></p>

<p>目前的Spark版本为1.1.0。在该版本的代码贡献者列表中，出现了数十位国内程序员的身影。这些贡献者的多数工作主要集中在Bug Fix上，甚至包括Example的Bug Fix。由于1.1.0版本极大地增强了Spark SQL和MLib的功能，因此有部分贡献都集中在SQL和MLib的特性实现上。下图是Spark Master分支上最近发生的仍然处于Open状态的Pull Request：
<img class="center" src="http://agiledon.github.com/images/2014/11/pull_request.png"></p>

<p>可以看出，由于Spark仍然比较年轻，当运用到生产上时，可能发现一些小缺陷。而在代码整洁度方面，也随时在对代码进行着重构。例如，淘宝技术部在2013年就开始尝试将Spark on Yarn应用到生产环境上。他们在执行数据分析作业过程中，先后发现了DAGSchedular的内存泄露，不匹配的作业结束状态等缺陷，从而为Spark库贡献了几个比较重要的Pull Request。具体内容可以查看淘宝技术部的博客文章：《<a href="http://rdc.taobao.org/?p=525">Spark on Yarn：几个关键Pull Request</a>》。</p>

<h2>Spark的社区活动</h2>

<p>Spark非常重视社区活动，组织也极为规范，定期或不定期地举行与Spark相关的会议。会议分为两种，一种为Spark Summit，影响力巨大，可谓全球Spark顶尖技术人员的峰会。目前，已经于2013年和2014年在San Francisco连续召开了两届Summit大会。2015年，Spark Summit将分别在New York与San Francisco召开，其官方网站为：<a href="http://spark-summit.org/">http://spark-summit.org/</a>。</p>

<p>在2014年的Spark Summit大会上，我们看到除了伯克利大学以及Databricks公司自身外，演讲者都来自最早开始运用和尝试Spark进行大数据分析的公司，包括最近非常火的音乐网站Spotify，全球最大专注金融交易的Sharethrough，专业大数据平台MapR、Cloudera，云计算的领先者Amazon，以及全球超大型企业IBM、Intel、SAP等。</p>

<p>除了影响力巨大的Spark Summit之外，Spark社区还不定期地在全球各地召开小型的Meetup活动。Spark Meetup Group已经遍布北美、欧洲、亚洲和大洋洲。在中国，北京Spark Meetup已经召开了两次，并将于今年10月26日召开第三次Meetup。届时将有来自Intel中国研究院、淘宝、TalkingData、微软亚洲研究院、Databricks的工程师进行分享。下图为Spark Meetup Groups在全球的分布图：
<img class="center" src="http://agiledon.github.com/images/2014/11/meetup_groups.png"></p>

<h2>Spark的现在和未来</h2>

<p>Spark的特色在于它首先为大数据应用提供了一个统一的平台。从数据处理层面看，模型可以分为批处理、交互式、流处理等多种方式；而从大数据平台而言，已有成熟的Hadoop、Cassandra、Mesos以及其他云的供应商。Spark整合了主要的数据处理模型，并能够很好地与现在主流的大数据平台集成。下图展现了Spark的这一特色：
<img class="center" src="http://agiledon.github.com/images/2014/11/spark_arch01.png"></p>

<p>这样的一种统一平台带来的优势非常明显。对于开发者而言，只需要学习一个平台，降低了学习曲线。对于用户而言，可以很方便地将Spark应用运行在Hadoop、Mesos等平台上面，满足了良好的可迁移性。统一的数据处理方式，也可以简化开发模型，降低平台的维护难度。</p>

<p>Spark为大数据提供了通用算法的标准库，这些算法包括MapReduce、SQL、Streaming、Machine Learning与Graph Processing。同时，它还提供了对Scala、Python、Java（支持Java 8）和R语言的支持：
<img class="center" src="http://agiledon.github.com/images/2014/11/spark_arch02.png"></p>

<p>在最新发布的1.1.0版本中，对Spark SQL和Machine Learning库提供了增强。Spark SQL能够更加有效地在Spark中加载和查询结构型数据，同时还支持对JSON数据的操作，并提供了更加友好的Spark API。在Machine Learning方面，已经包含了超过15种算法，包括决策树、SVD、PCA，L-BFGS等。下图展现了Spark当前的技术栈：
<img class="center" src="http://agiledon.github.com/images/2014/11/spark_arch03.png"></p>

<p>在2014年的Spark Summit上，来自Databricks公司的Patrick Wendell展望了Spark的未来。他在演讲中提到了Spark的目标，包括：</p>

<ul>
<li>Empower data scientists and engineers</li>
<li>Expressive, clean APIs</li>
<li>Unified runtime across many environments</li>
<li>Powerful standard libraries</li>
</ul>


<p>在演讲中，他提到在Spark最近的版本中，最重要的核心组件为Spark SQL。接下来的几次发布，除了在性能上更加优化（包括代码生成和快速的Join操作）外，还要提供对SQL语句的扩展和更好的集成（利用SchemaRDD与Hadoop、NoSQL以及RDBMS的集成）。在将来的版本中，要为MLLib增加更多的算法，这些算法除了传统的统计算法外，还包括学习算法，并提供与R语言更好的集成，从而能够为数据科学家提供更好的选择，根据场景来选择Spark和R。</p>

<p>Spark的发展会结合硬件的发展趋势。首先，内存会变得越来越便宜，256GB内存以上的机器会变得越来越常见，而对于硬盘，则SSD硬盘也将慢慢成为服务器的标配。由于Spark是基于内存的大数据处理平台，因而在处理过程中，会因为数据存储在硬盘中，而导致性能瓶颈。随着机器内存容量的逐步增加，类似HDFS这种存储在磁盘中的分布式文件系统将慢慢被共享内存的分布式存储系统所替代，诸如同样来自伯克利大学的AMPLab实验室的Tachyon就提供了远超HDFS的性能表现。因此，未来的Spark会在内部的存储接口上发生较大的变化，能够更好地支持SSD、以及诸如Tachyon之类的共享内存系统。事实上，在Spark的最近版本里，已经开始支持Tachyon了。</p>

<p>根据Spark的路线图，Databricks会在近三个月陆续发布1.2.0和1.3.0版本。其中，1.2.0版本会对存储方面的API进行重构，在1.3.0之上的版本，则会推出结合Spark和R的SparkR。除了前面提到的SQL与MLLib之外，未来的Spark对于Streaming、GraphX都有不同程度的增强，并能够更好地支持YARN。</p>

<h2>Spark的应用</h2>

<p>目前，Spark的正式版本得到了部分Hadoop主流厂商的支持，如下企业或平台发布的Hadoop版本中，都包含了Spark：
<img class="center" src="http://agiledon.github.com/images/2014/11/vendor.png"></p>

<p>这说明业界已经认可了Spark，Spark也被许多企业尤其是互联网企业广泛应用到商业项目中。根据Spark的官方统计，目前参与Spark的贡献以及将Spark运用在商业项目的公司大约有80余家（https://cwiki.apache.org/confluence/display/SPARK/Powered+By+Spark）。在国内，投身Spark阵营的公司包括阿里、百度、腾讯、网易、搜狐等。在San Francisco召开的Spark Summit 2014大会上，参会的演讲嘉宾分享了在音乐推荐（Spotify）、实时审计的数据分析（Sharethrough）、流在高速率分析中的运用（Cassandra）、文本分析（IBM）、客户智能实时推荐（Graphflow）等诸多在应用层面的话题，这足以说明Spark的应用程度。</p>

<p>但是，整体而言，目前开始应用Spark的企业主要集中在互联网领域。制约传统企业采用Spark的因素主要包括三个方面。首先，取决于平台的成熟度。传统企业在技术选型上相对稳健，当然也可以说是保守。如果一门技术尤其是牵涉到主要平台的选择，会变得格外慎重。如果没有经过多方面的验证，并从业界获得成功经验，不会轻易选定。其次是对SQL的支持。传统企业的数据处理主要集中在关系型数据库，而且有大量的遗留系统存在。在这些遗留系统中，多数数据处理都是通过SQL甚至存储过程来完成。如果一个大数据平台不能很好地支持关系型数据库的SQL，就会导致迁移数据分析业务逻辑的成本太大。其三则是团队与技术的学习曲线。如果没有熟悉该平台以及该平台相关技术的团队成员，企业就会担心开发进度、成本以及可能的风险。</p>

<p>Spark在努力解决这三个问题。随着1.0.2版本的发布，Spark得到了更多商用案例的验证。Spark虽然依旧保持年轻的活力，但已经具备堪称成熟的平台功能。至于SQL支持，Spark非常。在1.0.2版本发布之前，就认识到基于HIVE的Shark存在的不足，从而痛下决心，决定在新版本中抛弃Shark，而决定引入新的SQL模块。如今，在Spark 1.1.0版本中，Spark SQL的支持已经相对完善，足以支持企业应用中对SQL迁移的需求。关于Spark的学习曲线，主要的学习内容还是在于对RDD的理解。由于Spark为多种算法提供了统一的编程模型、部署模式，搭建了一个大数据的一体化方案，倘若企业的大数据分析需要应对多种场景，那么，Spark这样的架构反而使得它的学习曲线更低，同时还能降低部署成本。Spark可以很好地与Hadoop、Cassandra等平台集成，同时也能部署到YARN上。如果企业已经具备大数据分析的能力，原有掌握的经验仍旧可以用到Spark上。虽然Spark是用Scala编写，官方也更建议用户调用Scala的API，但它同时也提供了Java和Python的接口，非常体贴地满足了Java企业用户或非JVM用户。如果抱怨Java的冗赘，则Spark新版本对Java 8的支持让Java API变得与Scala API同样的简洁（因为缺少类型推断略显冗余）而强大。</p>

<p>显然，随着Spark的逐渐成熟，并在活跃社区的推动下，它所提供的强大功能一定能得到更多技术团队和企业的青睐。相信在不远的将来会有更多传统企业开始尝试使用Spark。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[今天你写了自动化测试吗]]></title>
    <link href="http://agiledon.github.com/blog/2014/10/28/are-you-writing-auto-test-today/"/>
    <updated>2014-10-28T16:08:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/10/28/are-you-writing-auto-test-today</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2014/ship.jpg"></p>

<p>一艘货轮满载着货物从港口启航，向浩瀚的大海深处破水而去。海面平静，微微皱起波浪，从容而显得宽容。然而，货轮的步履却有些蹒跚，发动机“轰轰轰”地嘶吼着，不堪重负，却无法让船只游得更快，倒像是海水咬住了船底往下在拖曳。</p>

<p>“嘟——嘟——嘟”，突然警报声响起，甲板上变得喧闹起来，一个水手模样的年轻人声嘶力竭地呐喊：“船超重了，快快快……快卸货！”声音急迫，甚至能听到哭音。然后，又是一阵喧嚷，似乎是在争吵甚么，就看到一个胖胖的中年人冲了出来。看他那肥胖的体型，真难想到他的身手竟然如此敏捷，如海豹一般破开人群，两手挥舞，大声喊道：“怎么了？怎么了？”，他停下来，吼道：“我看哪个不长眼的家伙敢卸我的货！谁敢！”</p>

<p>船长走了过来，略带恭敬地对那中年人说道：“老板，你看，这船超载了，船身吃紧，已经发出超重警报了。倘若不减轻船的重量，这船开不了多久就得沉了啊！”</p>

<p>“他奶奶的，这船可真秀气啊！”中年人一边骂骂咧咧，却也知道形势紧迫，容不得自己不下决断。可是心里总存着侥幸心理，突然灵机一动，一把拉过船长，指着这艘货轮问道：“既然这船超重，那我问你，除了货物，这船上还有哪些东西占了船身的重量？”</p>

<p>船长一听，立刻明白老板心里的小九九，没好气地回道：“除了货物，占了这船重量的就还有人、淡水、食品，还有救生圈、救生衣、救生艇。老板你看那样不顺心，你就扔哪样吧！”</p>

<p>嘿，回到现实中来吧。回答问题：倘若你是老板，你会扔哪样呢？稍有理智的人，都不难做出正确的选择。——然而，为何在软件开发过程中，我却常常看到有人选择丢弃救生圈、救生衣、救生艇呢？哪怕它们的重量对于整艘船而言如同九牛一毛，却总有人存着侥幸，认为船就超了那么一点点，或许扔出几个救生圈，就能恢复重量到安全线；于是，货物得以幸存，可以避免不必要的损失了。</p>

<p>或许，我们没这么傻吧。那么，让我们想想。</p>

<p>假设将这航行比作是软件开发的过程，那么载货到达目的地，就是实现软件需求。只有交付了货物，才算是实现了价值。至于淡水、食品以及船只，就是开发的工具与环境，而救生圈、救生衣、救生艇，就是我们在开发过程中需要编写的自动化测试（单元测试、集成测试、验收测试等）。我们需要这些测试来随时检测开发功能是否有误，及时反馈，就像在航行过程中，若是有人溺水，可以用救生衣、救生圈挽回一条生命一般。</p>

<p>可一旦开发时间紧促，人手严重不足，进度压力山大时，我们想到了什么呢？对于我见过的多数软件团队而言，每当面临如此窘境时，首先想到的就是减少甚至不做自动化测试。有人认为自动化测试没有价值，浪费成本；有人认为自动化测试可以以后再补，先把功能完成再说；有人认为有了手动测试，就足以保障项目的质量……如此这般，自动化测试就这般被忽略了，沦落到随时可以抛弃的地位。</p>

<p>倘若软件开发就只有这一个阶段，没有需求变更，没有后续开发，没有软件维护。项目的代码库如树苗一般在阳光雨露下茁壮成长，没有大风狂吹，没有烈日暴晒，没有大雨倾盆，亦没有虫蚁啃啮，那自然由得它去。然而，现实世界哪有如此美好！</p>

<p>Michael Feather将没有自动化测试的代码称为“遗留代码”，温伯格在《咨询的奥秘》中则认为应该将“维护”工作视为“设计”工作。自动化测试是修改的基础，重构的保障，设计的规约，演化的文档。它的重要性怎么强调都不过分，然而很可惜，在很多软件项目开发中，它甚至不如“鸡肋”的地位，说放弃就放弃了，在决定当时，毫不觉得可惜。至于以后的以后，不远的未来，谁还顾得上！！？债欠下了，什么时候偿还呢？——不知道！到了催债的那天，再想办法还债吧。</p>

<p>鸵鸟心态害死人啊！</p>

<p>扪心自问，我们经历过维护的苦楚吗？体验过修改代码的烦恼吗？修复过不胜其扰的缺陷吗？答案若是肯定，那么，如果老天再给你一次机会，把选择自动化测试的权利放在你面前，作为“曾经沧海难为水”的你，你会怎么选？——所以，我想问问程序员们：今天，你写自动化测试了吗？</p>

<p>后记：其实我很想写：程序员要是写代码不写测试，就是耍流氓，就是做爱不带套。可我纯洁啊，没好意思写出来。可总觉得这么经典的语录藏在我心里，小心憋不住。把心一横，他奶奶的，毕竟话糙理不糙啊！这不，一激动，还是吐露真言了。终归脸皮薄，没好意思写进正文，就这般猥琐地躲在文章后面，算是偷窥，觑觑究竟有谁真有耐心读到文章末尾，听听我的真心大实话。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计中的变与不变]]></title>
    <link href="http://agiledon.github.com/blog/2014/10/08/change-and-stable-of-design/"/>
    <updated>2014-10-08T20:51:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/10/08/change-and-stable-of-design</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2014/thinking.jpg"></p>

<p>古希腊哲学家巴门尼德认为：“人的思想和言语都有一个载体，如果你在这一时间和另外一个时间想到或者谈到同样一件东西，那就说明这件东西在这段时间内没有变化，如有变化的话，你说的就不是同一件东西。”</p>

<p>这让我想起对象的实例。在面向对象设计中，默认情况下并没有约束类的实例是否为可变，这意味着我们可以通过某种方式改变实例的状态。这体现了实例的可变特征。然而，若是站在内存的角度观察实例，则又不然。无论它在内存中存储的状态如何变化，该实例的对象标识依旧是保持不变的。显然，变与不变是相对的。</p>

<p>切换到DDD的命题中，所谓“实体”就是那种具有唯一的可识别可跟踪ID的对象。这个ID并非程序语言在内存中为它分配的对象标识，而是从领域角度来看，由设计者为其识别，由创建者为其分配，因而具有领域语义。实体的状态当然是可变的，然而实体ID在这个实体的生命周期中却是不可变的。</p>

<p>与之相对的是值对象。在DDD中，强调将领域对象严格区分为实体和值对象。一个指导原则是，当你无法分辨某个领域对象究竟是实体还是值对象时，应优先将其建模为值对象。这有助于我们更好地利用值对象的不可变性。</p>

<p>不可变的对象能够更好地维护，因为你不用操心它的值变化，也无需追踪变化的轨迹。不变性天生支持并发。这就衍生出面向对象设计中的Immutable模式。例如Java和C#中的String类型，皆为Immutable模式的实现。</p>

<p>可若放在函数式编程中，这种模式就显得有些可笑了。尤其在纯函数式编程的世界里，任何东西都应该是不变的。</p>

<p>这种不变意味着只要它存在，就不可修改，而且恒古不变。这种追究变化背后的不变性，一直是古希腊哲学乃至科学的基本原则。物质是否永恒不变，在哲学中一直是引人深思的命题或假设；但在函数式编程中，它几乎被证明了。例如，在Haskell中，对List的任何操作，即使调用++对List进行合并，返回的都是全新的List对象，原有对象不会有任何变化。</p>

<p>罗素在《西方哲学简史》中写道：
有的神秘主义者认为永恒并不是指时间上的永久，它是独立于时间之外的，无前无后、无因无果，也没有逻辑可循。</p>

<p>我觉得函数式编程追求的不变性，可以划入这个范畴。</p>

<p>赫拉克利特说：“人不能两次踏进同一条河流”。这是赫拉克利特终极的哲学观，即万物随时在变。软件系统就是这样一条河流，它无时无刻不在变化，正如水不断的流动，需求也总是在变化。但若抛开原子裂变、放射衰变的科学原理，我们似乎也可以将组成整条河流的每一滴水，看做是不变的基本组成要素。这个要素就是Monad中的Identity（幺元或单位元）。这个Identity表达了单一、恒等的概念，例如Int类型中加减法运算半群（SemiGroup）中的Zero，就是一个Identity，因为半群中的任何元素a与Zero结合，依然是元素a本身。</p>

<p>水是如何组成一条河流的呢？这取决于组合子（Combinator）的设计与组合。只要我们找到万物的基本要素，继而设计出各种组合子，就可以演绎出世间不同的物。例如水滴虽可以组合为河流，却也可以组合为橙汁，只要我们加入橙子的另一个组合子即可。这就是面向组合子（Combinator Oriented）的设计思想。显然，它与面向对象的设计哲学背道而驰。</p>

<p>以哲学史观之，函数式思想更符合古典的朴素哲学观。在古希腊哲学家中，泰勒斯认为世界的元素为水，阿那克西美尼认为世界的元素是气，赫拉克利特认为世界的元素是火，而恩培多克勒则糅合了这些思想，认为世界的元素有土、气、火、水四种。而观中国古代哲学，则有五行学说认为宇宙万物都由金木水火土五种基本特性的运行和变化所构成。</p>

<p>不论构成万物的基本元素为何，这种哲学观不正是函数式编程的设计观吗？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[领域驱动设计中的事件建模]]></title>
    <link href="http://agiledon.github.com/blog/2014/09/25/event-modeling-in-ddd/"/>
    <updated>2014-09-25T12:58:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/09/25/event-modeling-in-ddd</id>
    <content type="html"><![CDATA[<p>这两日，我参加了Implementing Domain Driven Disign一书作者Vaughn Vernon组织的IDDD Workshop。培训中，Vernon带领我们针对Domain Event进行了一次建模工作坊。
<img class="center" src="http://agiledon.github.com/images/2014/vernonandme.jpg"></p>

<p>在领域驱动设计中，Domain Event变得越来越重要。在Implementing Domain Driven Disign这本书中，Vaughn Vernon甚至将Domain Event上升到了一等公民的地位。</p>

<p>那么，Domain Event到底是什么？Domain Event即领域事件，是指领域中发生的事实（facts）。当满足某个条件时，某个发起者就会触发事件产生。因而在对事件建模时，我们可以关注统一语言中如下的关键词汇：
<strong>“当…”
“如果发生…”
“当…的时候，请通知我”
“发生…时”</strong></p>

<p>“事件为事实（fact）”这一描述让我对“事件”本身有了更准确的认识。它让我想起两篇发表在InfoQ上的文章。一篇文章为《<a href="http://www.infoq.com/cn/articles/Architecture-Datomic">Datomic的架构</a>》。文中提到：“信息是一组事实（facts），事实是指一些已经发生的事情。鉴于任何人都无法改变过去，这也意味着数据库将累积这些事实，而非原地进行更新。虽然过去可以遗忘，但却是不能改变的。”同理推之，若事件即事实，那么它也是不可改变的。对于这些历史发生的“事实”，我们需要“立此存照”——于是，这就引出了Event Store或者Event Sourcing。我会在后续的文章深入分析Event Store与Event Sourcing。</p>

<p>另一篇文章是徐昊的《<a href="http://www.infoq.com/cn/articles/xh-four-color-modeling">运用四色建模法进行领域分析</a>》。文中表达了类似的思想：“任何的业务事件都会以某种数据的形式留下足迹。我们对于事件的追溯可以通过对数据的追溯来完成。……你无法回到从前去看看到底发生了什么，但是却可以在单据的基础上，一定程度的还原当时事情发生的场景。当我们把这些数据的足迹按照时间顺序排列起来，我们几乎可以清晰的推测出这个在过往的一段时间内到底发生了那些事情。”</p>

<p>在四色建模分析法中，徐昊认为应该将“时标性对象（moment-interval）”作为建模的起点。我在这里并不是要介绍四色建模法，这个话题留待以后再讲。我试图阐释的观点在于，如果事件与时间相关，那么在对事件进行建模时，就可以针对业务场景确定一条时间线，并通过分析业务状态的各种变迁，得到我们希望获得的事件模型。这正是这个工作坊的切入点。</p>

<p>整个事件建模的活动可以分为四个步骤：
1. 选定某个自己熟悉的领域，然后针对时间线去寻找那些用过去时态表现的事件；找到这些事件后，用黄色即时贴写出事件名称，形式如：OrderFilled。
2. 针对每个事件，对触发事件的Command对象进行建模，并用绿色即时贴写出Command的名称。对Command对象进行建模并非单纯地为了寻找Command对象，而是为了更深一步地验证之前建模的事件模型。在思考触发事件的对象时，我们可能会发现一些遗漏又或者多余的事件。
3. 判断这些事件应该属于哪个聚合对象，找到它们，然后写在紫色即时贴上。
4. 对这些识别出来的Event、Command、Aggregate进行分类，判断它们到底属于哪个Bounded Context，并用红色即时贴标出。
<img class="center" src="http://agiledon.github.com/images/2014/eventmodeling.jpg"></p>

<p>这种Workshop不仅只针对培训，它更应该运用到团队进行领域驱动设计的过程中。这也正是我一直在提倡的所谓“可视化设计”。可视化设计并非一个噱头，更不是为了美观好看，而是希望以直观简单的形式展现设计思路，尤其需要让整个团队成员都能以协作互动的形式参与到这个设计过程中。群策群力，头脑风暴，如此方能获得更好的设计方案，并以这种团队行为的方式完成知识的共享与传递。其实，“架构”究竟是什么，不就是一种软件设计的知识吗？设计架构，重要在于交流，在于知识传递，而不仅仅是严谨完整的解决方案文档。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速了解Scala技术栈]]></title>
    <link href="http://agiledon.github.com/blog/2014/09/22/understanding-scala-stack/"/>
    <updated>2014-09-22T15:31:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/09/22/understanding-scala-stack</id>
    <content type="html"><![CDATA[<p>我无可救药地成为了Scala的超级粉丝。在我使用Scala开发项目以及编写框架后，它就仿佛凝聚成为一个巨大的黑洞，吸引力使我不得不飞向它，以至于开始背离Java。固然Java 8为Java阵营增添了一丝亮色，却是望眼欲穿，千呼万唤始出来。而Scala程序员，却早就在享受lambda、高阶函数、trait、隐式转换等带来的福利了。</p>

<p>Java像是一头史前巨兽，它在OO的方向上几乎走到了极致，硬将它拉入FP阵营，确乎有些强人所难了。而Scala则不，因为它的诞生就是OO与FP的混血儿——完美的基因融合。</p>

<p>“Object-Oriented Meets Functional”，这是Scala语言官方网站上飘扬的旗帜。这也是Scala的野心，当然，也是Martin Odersky的雄心。</p>

<h2>Scala社区的发展</h2>

<p>然而，一门语言并不能孤立地存在，必须提供依附的平台，以及围绕它建立的生态圈。不如此，语言则不足以壮大。Ruby很优秀，但如果没有Ruby On Rails的推动，也很难发展到今天这个地步。Scala同样如此。反过来，当我们在使用一门语言时，也要选择符合这门语言的技术栈，在整个生态圈中找到适合具体场景的框架或工具。</p>

<p>当然，我们在使用Scala进行软件开发时，亦可以寻求庞大的Java社区支持；可是，如果选择调用Java开发的库，就会牺牲掉Scala给我们带来的福利。幸运的是，在如今，多数情况你已不必如此。伴随着Scala语言逐渐形成的Scala社区，已经开始慢慢形成相对完整的Scala技术栈。无论是企业开发、自动化测试或者大数据领域，这些框架或工具已经非常完整地呈现了Scala开发的生态系统。</p>

<!-- more -->


<h2>快速了解Scala技术栈</h2>

<p>若要了解Scala技术栈，并快速学习这些框架，一个好的方法是下载typesafe推出的Activator。它提供了相对富足的基于Scala以及Scala主流框架的开发模板，这其中实则还隐含了typesafe为Scala开发提供的最佳实践与指导。下图是Activator模板的截图：
<img class="center" src="http://agiledon.github.com/images/2014/activatortemplate.png"></p>

<p>那么，是否有渠道可以整体地获知Scala技术栈到底包括哪些框架或工具，以及它们的特性与使用场景呢？感谢Lauris Dzilums以及其他在Github的Contributors。在Lauris Dzilums的Github上，他建立了名为awesome-scala的<a href="https://github.com/lauris/awesome-scala">Repository</a>，搜罗了当下主要的基于Scala开发的框架与工具，涉及到的领域包括：
Database
Web Frameworks
i18n
Authentication
Testing
JSON Manipulation
Serialization
Science and Data Analysis
Big Data
Functional Reactive Programming
Modularization and Dependency Injection
Distributed Systems
Extensions
Android
HTTP
Semantic Web
Metrics and Monitoring
Sbt plugins</p>

<p>是否有“乱花渐欲迷人眼”的感觉？不是太少，而是太多！那就让我删繁就简，就我的经验介绍一些框架或工具，从持久化、分布式系统、HTTP、Web框架、大数据、测试这六方面入手，作一次蜻蜓点水般的俯瞰。</p>

<h3>持久化</h3>

<p>归根结底，对数据的持久化主要还是通过JDBC访问数据库。但是，我们需要更好的API接口，能更好地与Scala契合，又或者更自然的ORM。如果希望执行SQL语句来操作数据库，那么运用相对广泛的是框架ScalikeJDBC，它提供了非常简单的API接口，甚至提供了SQL的DSL语法。例如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">val</span> <span class="n">alice</span><span class="k">:</span> <span class="kt">Option</span><span class="o">[</span><span class="kt">Member</span><span class="o">]</span> <span class="k">=</span> <span class="n">withSQL</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">select</span><span class="o">.</span><span class="n">from</span><span class="o">(</span><span class="nc">Member</span> <span class="n">as</span> <span class="n">m</span><span class="o">).</span><span class="n">where</span><span class="o">.</span><span class="n">eq</span><span class="o">(</span><span class="n">m</span><span class="o">.</span><span class="n">name</span><span class="o">,</span> <span class="n">name</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}.</span><span class="n">map</span><span class="o">(</span><span class="n">rs</span> <span class="k">=&gt;</span> <span class="nc">Member</span><span class="o">(</span><span class="n">rs</span><span class="o">)).</span><span class="n">single</span><span class="o">.</span><span class="n">apply</span><span class="o">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果希望使用ORM框架，Squeryl应该是很好的选择。我的同事杨云在项目中使用过该框架，体验不错。该框架目前的版本为0.9.5，已经比较成熟了。Squeryl支持按惯例映射对象与关系表，相当于定义一个POSO（Plain Old Scala Object），从而减少框架的侵入。若映射违背了惯例，则可以利用框架定义的annotation如@Column定义映射。框架提供了org.squeryl.Table[T]来完成这种映射关系。</p>

<p>因为可以运用Scala的高阶函数、偏函数等特性，使得Squeryl的语法非常自然，例如根据条件对表进行更新：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">update</span><span class="o">(</span><span class="n">songs</span><span class="o">)(</span><span class="n">s</span> <span class="k">=&gt;</span>
</span><span class='line'>  <span class="n">where</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">title</span> <span class="o">===</span> <span class="s">&quot;Watermelon Man&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="n">set</span><span class="o">(</span><span class="n">s</span><span class="o">.</span><span class="n">title</span> <span class="o">:=</span> <span class="s">&quot;The Watermelon Man&quot;</span><span class="o">,</span>
</span><span class='line'>      <span class="n">s</span><span class="o">.</span><span class="n">year</span>  <span class="o">:=</span> <span class="n">s</span><span class="o">.</span><span class="n">year</span><span class="o">.~</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>分布式系统</h3>

<p>我放弃介绍诸如模块化管理以及依赖注入，是因为它们在Scala社区的价值不如Java社区大。例如，我们可以灵活地运用trait结合cake pattern就可以实现依赖注入的特性。因此，我直接跳过这些内容，来介绍影响更大的支持分布式系统的框架。</p>

<p>Finagle的血统高贵，来自过去的寒门，现在的高门大族Twitter。Twitter是较早使用Scala作为服务端开发的互联网公司，因而积累了非常多的Scala经验，并基于这些经验推出了一些颇有影响力的框架。由于Twitter对可伸缩性、性能、并发的高要求，这些框架也极为关注这些质量属性。Finagle就是其中之一。它是一个扩展的RPC系统，以支持高并发服务器的搭建。我并没有真正在项目中使用过Finagle，大家可以到它的官方网站获得更多消息。</p>

<p>对于分布式的支持，绝对绕不开的框架还是AKKA。它产生的影响力如此之大，甚至使得Scala语言从2.10开始，就放弃了自己的Actor模型，转而将AKKA Actor收编为2.10版本的语言特性。许多框架在分布式处理方面也选择了使用AKKA，例如Spark、Spray。AKKA的Actor模型参考了Erlang语言，为每个Actor提供了一个专有的Mailbox，并将消息处理的实现细节做了良好的封装，使得并发编程变得更加容易。AKKA很好地统一了本地Actor与远程Actor，提供了几乎一致的API接口。AKKA也能够很好地支持消息的容错，除了提供一套完整的Monitoring机制外，还提供了对Dead Letter的处理。</p>

<p>AKKA天生支持EDA（Event-Driven Architecture）。当我们针对领域建模时，可以考虑针对事件进行建模。在AKKA中，这些事件模型可以被定义为Scala的case class，并作为消息传递给Actor。借用Vaughn Vernon在《实现领域驱动设计》中的例子，针对如下的事件流：
<img class="center" src="http://agiledon.github.com/images/2014/pipe-filter.jpg"></p>

<p>我们可以利用Akka简单地实现：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">AllPhoneNumberListed</span><span class="o">(</span><span class="n">phoneNumbers</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">PhoneNumberMatched</span><span class="o">(</span><span class="n">phoneNumbers</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">AllPhoneNumberRead</span><span class="o">(</span><span class="n">fileName</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">PhoneNumbersPublisher</span><span class="o">(</span><span class="n">actor</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ActorRef</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="nc">ReadPhoneNumbers</span> <span class="k">=&gt;</span>
</span><span class='line'>      <span class="c1">//list phone numbers</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">actor</span> <span class="o">!</span> <span class="nc">AllPhoneNumberListed</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">1110</span><span class="o">,</span> <span class="o">))</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">PhoneNumberFinder</span><span class="o">(</span><span class="n">actor</span><span class="k">:</span> <span class="kt">ActorRef</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">ActorRef</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="nc">AllPhoneNumberListed</span><span class="o">(</span><span class="n">numbers</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>          <span class="c1">//match</span>
</span><span class='line'>
</span><span class='line'>          <span class="n">actor</span> <span class="o">!</span> <span class="nc">PhoneNumberMatched</span><span class="o">()</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="n">finder</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Prop</span><span class="o">(</span><span class="k">new</span> <span class="nc">PhoneNumberFinder</span><span class="o">(...)))</span>
</span><span class='line'><span class="k">val</span> <span class="n">publisher</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Prop</span><span class="o">(</span><span class="k">new</span> <span class="nc">PhoneNumbersPublisher</span><span class="o">(</span><span class="n">finder</span><span class="o">)))</span>
</span><span class='line'>
</span><span class='line'><span class="n">publisher</span> <span class="o">!</span> <span class="nc">ReadPhoneNumbers</span><span class="o">(</span><span class="s">&quot;callinfo.txt&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>若需要处理的电话号码数据量大，我们可以很容易地将诸如PhoneNumbersPublisher、PhoneNumberFinder等Actors部署为Remote Actor。此时，仅仅需要更改客户端获得Actor的方式即可。</p>

<p>Twitter实现的Finagle是针对RPC通信，Akka则提供了内部的消息队列（MailBox），而由LinkedIn主持开发的Kafka则提供了支持高吞吐量的分布式消息队列中间件。这个顶着文学家帽子的消息队列，能够支持高效的Publisher-Subscriber模式进行消息处理，并以快速、稳定、可伸缩的特性很快引起了开发者的关注，并在一些框架中被列入候选的消息队列而提供支持，例如，Spark Streaming就支持Kafka作为流数据的Input Source。</p>

<h3>HTTP</h3>

<p>严格意义上讲，Spray并非单纯的HTTP框架，它还支持REST、JSON、Caching、Routing、IO等功能。Spray的模块及其之间的关系如下图所示：
<img class="center" src="http://agiledon.github.com/images/2014/spraydepencies.png"></p>

<p>我在项目中主要将Spray作为REST框架来使用，并结合AKKA来处理领域逻辑。Spray处理HTTP请求的架构如下图所示：
<img class="center" src="http://agiledon.github.com/images/2014/spray_arch.png"></p>

<p>Spray提供了一套DSL风格的path语法，能够非常容易地编写支持各种HTTP动词的请求，例如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">HttpServiceBase</span> <span class="k">extends</span> <span class="nc">Directives</span> <span class="k">with</span> <span class="nc">Json4sSupport</span> <span class="o">{</span>
</span><span class='line'>     <span class="k">implicit</span> <span class="k">val</span> <span class="n">system</span><span class="k">:</span> <span class="kt">ActorSystem</span>
</span><span class='line'>     <span class="k">implicit</span> <span class="k">def</span> <span class="n">json4sFormats</span><span class="k">:</span> <span class="kt">Formats</span> <span class="o">=</span> <span class="nc">DefaultFormats</span>
</span><span class='line'>     <span class="k">def</span> <span class="n">route</span><span class="k">:</span> <span class="kt">Route</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">CustomerService</span> <span class="k">extends</span> <span class="nc">HttpServiceBase</span> <span class="o">{</span>
</span><span class='line'>     <span class="k">val</span> <span class="n">route</span> <span class="k">=</span>
</span><span class='line'>          <span class="n">path</span><span class="o">(</span><span class="s">&quot;customer&quot;</span> <span class="o">/</span> <span class="s">&quot;groups&quot;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>               <span class="n">get</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">parameters</span><span class="o">(</span><span class="-Symbol">&#39;groupids</span><span class="o">.?)</span> <span class="o">{</span>
</span><span class='line'>                         <span class="o">(</span><span class="n">groupids</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>                              <span class="n">complete</span> <span class="o">{</span>
</span><span class='line'>                                   <span class="n">groupids</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>                                        <span class="k">case</span> <span class="nc">Some</span><span class="o">(</span><span class="n">groupIds</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>                    <span class="nc">ViewUserGroup</span><span class="o">.</span><span class="n">queryUserGroup</span><span class="o">(</span><span class="n">groupIds</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;,&quot;</span><span class="o">).</span><span class="n">toList</span><span class="o">)</span>
</span><span class='line'>                                        <span class="k">case</span> <span class="nc">None</span> <span class="k">=&gt;</span> <span class="nc">ViewUserGroup</span><span class="o">.</span><span class="n">queryUserGroup</span><span class="o">()</span>
</span><span class='line'>                                   <span class="o">}</span>
</span><span class='line'>                              <span class="o">}</span>
</span><span class='line'>                    <span class="o">}</span>
</span><span class='line'>               <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span> <span class="o">~</span>
</span><span class='line'>          <span class="n">path</span><span class="o">(</span><span class="s">&quot;customers&quot;</span> <span class="o">/</span> <span class="s">&quot;vip&quot;</span> <span class="o">/</span> <span class="s">&quot;failureinfo&quot;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>               <span class="n">post</span> <span class="o">{</span>
</span><span class='line'>                    <span class="n">entity</span><span class="o">(</span><span class="n">as</span><span class="o">[</span><span class="kt">FailureVipCustomerRequest</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>                         <span class="n">request</span> <span class="k">=&gt;</span>
</span><span class='line'>                              <span class="n">complete</span> <span class="o">{</span>
</span><span class='line'>                                   <span class="nc">VipCustomer</span><span class="o">.</span><span class="n">failureInfo</span><span class="o">(</span><span class="n">request</span><span class="o">)</span>
</span><span class='line'>                              <span class="o">}</span>
</span><span class='line'>                    <span class="o">}</span>
</span><span class='line'>               <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我个人认为，在进行Web开发时，完全可以放弃Web框架，直接选择AngularJS结合Spray和AKKA，同样能够很好地满足Web开发需要。</p>

<p>Spray支持REST，且Spray自身提供了服务容器spray-can，因而允许Standalone的部署（当然也支持部署到Jetty和tomcat等应用服务器）。Spray对HTTP请求的内部处理机制实则是基于Akka-IO，通过IO这个Actor发出对HTTP的bind消息。例如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'> <span class="nc">IO</span><span class="o">(</span><span class="nc">Http</span><span class="o">)</span> <span class="o">!</span> <span class="nc">Http</span><span class="o">.</span><span class="nc">Bind</span><span class="o">(</span><span class="n">service</span><span class="o">,</span> <span class="n">interface</span> <span class="k">=</span> <span class="s">&quot;0.0.0.0&quot;</span><span class="o">,</span> <span class="n">port</span> <span class="k">=</span> <span class="mi">8889</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们可以编写不同的Boot对象去绑定不同的主机Host以及端口。这些特性都使得Spray能够很好地支持当下较为流行的Micro Service架构风格。</p>

<h3>Web框架</h3>

<p>正如前面所说，当我们选择Spray作为REST框架时，完全可以选择诸如AngularJS或者Backbone之类的JavaScript框架开发Web客户端。客户端能够处理自己的逻辑，然后再以JSON格式发送请求给REST服务端。这时，我们将模型视为资源（Resource），视图完全在客户端。JS的控制器负责控制客户端的界面逻辑，服务端的控制器则负责处理业务逻辑，于是传统的MVC就变化为VC+R+C模式。这里的R指的是Resource，而服务端与客户端则通过JSON格式的Resource进行通信。</p>

<p>若硬要使用专有的Web框架，在Scala技术栈下，最为流行的就是Play Framework，这是一个标准的MVC框架。另外一个相对小众的Web框架是Lift。它与大多数Web框架如RoR、Struts、Django以及Spring MVC、Play不同，采用的并非MVC模式，而是使用了所谓的View First。它驱动开发者对内容生成与内容展现（Markup）形成“关注点分离”。</p>

<p>Lift将关注点重点放在View上，这是因为在一些Web应用中，可能存在多个页面对同一种Model的Action。倘若采用MVC中的Controller，会使得控制变得非常复杂。Lift提出了一种所谓view-snippet-model（简称为VSM）的模式。
<img class="center" src="http://agiledon.github.com/images/2014/lift_vsm.png"></p>

<p>View主要为响应页面请求的HTML内容，分为template views和generated views。Snippet的职责则用于生成动态内容，并在模型发生更改时，对Model和View进行协调。</p>

<h3>大数据</h3>

<p>大数据框架最耀眼的新星非Spark莫属。与许多专有的大数据处理平台不同，Spark建立在统一抽象的RDD之上，使得它可以以基本一致的方式应对不同的大数据处理场景，包括MapReduce，Streaming，SQL，Machine Learning以及Graph等。这即Matei Zaharia所谓的“设计一个通用的编程抽象（Unified Programming Abstraction）。
<img class="center" src="http://agiledon.github.com/images/2014/spark_architecture.jpg"></p>

<p>由于Spark具有先进的DAG执行引擎，支持cyclic data flow和内存计算。因此相比较Hadoop而言，性能更优。在内存中它的运行速度是Hadoop MapReduce的100倍，在磁盘中是10倍。</p>

<p>由于使用了Scala语言，通过高效利用Scala的语言特性，使得Spark的总代码量出奇地少，性能却在多数方面都具备一定的优势（只有在Streaming方面，逊色于Storm）。下图是针对Spark 0.9版本的BenchMark：
<img class="center" src="http://agiledon.github.com/images/2014/spark_metric.png"></p>

<p>由于使用了Scala，使得语言的函数式特性得到了最棒的利用。事实上，函数式语言的诸多特性包括不变性、无副作用、组合子等，天生与数据处理匹配。于是，针对WordCount，我们可以如此简易地实现：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">file</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="s">&quot;hdfs://...&quot;</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">file</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">line</span> <span class="k">=&gt;</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">))</span>
</span><span class='line'>    <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">word</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
</span><span class='line'>    <span class="o">.</span><span class="n">reduceByKey</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>要是使用Hadoop，就没有这么方便了。幸运的是，Twitter的一个开源框架scalding提供了对Hadoop MapReduce的抽象与包装。它使得我们可以按照Scala的方式执行MapReduce的Job：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">class</span> <span class="nc">WordCountJob</span><span class="o">(</span><span class="n">args</span> <span class="k">:</span> <span class="kt">Args</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">Job</span><span class="o">(</span><span class="n">args</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="nc">TextLine</span><span class="o">(</span> <span class="n">args</span><span class="o">(</span><span class="s">&quot;input&quot;</span><span class="o">)</span> <span class="o">)</span>
</span><span class='line'>    <span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="-Symbol">&#39;line</span> <span class="o">-&gt;</span> <span class="-Symbol">&#39;word</span><span class="o">)</span> <span class="o">{</span> <span class="n">line</span> <span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span> <span class="n">tokenize</span><span class="o">(</span><span class="n">line</span><span class="o">)</span> <span class="o">}</span>
</span><span class='line'>    <span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="-Symbol">&#39;word</span><span class="o">)</span> <span class="o">{</span> <span class="k">_</span><span class="o">.</span><span class="n">size</span> <span class="o">}</span>
</span><span class='line'>    <span class="o">.</span><span class="n">write</span><span class="o">(</span> <span class="nc">Tsv</span><span class="o">(</span> <span class="n">args</span><span class="o">(</span><span class="s">&quot;output&quot;</span><span class="o">)</span> <span class="o">)</span> <span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1">// Split a piece of text into individual words.</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">tokenize</span><span class="o">(</span><span class="n">text</span> <span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="c1">// Lowercase each word and remove punctuation.</span>
</span><span class='line'>    <span class="n">text</span><span class="o">.</span><span class="n">toLowerCase</span><span class="o">.</span><span class="n">replaceAll</span><span class="o">(</span><span class="s">&quot;[^a-zA-Z0-9\\s]&quot;</span><span class="o">,</span> <span class="s">&quot;&quot;</span><span class="o">).</span><span class="n">split</span><span class="o">(</span><span class="s">&quot;\\s+&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h3>测试</h3>

<p>虽然我们可以使用诸如JUnit、TestNG为Scala项目开发编写单元测试，使用Cocumber之类的BDD框架编写验收测试。但在多数情况下，我们更倾向于选择使用ScalaTest或者Specs2。在一些Java开发项目中，我们也开始尝试使用ScalaTest来编写验收测试，乃至于单元测试。</p>

<p>若要我选择ScalaTest或Specs2，我更倾向于ScalaTest，这是因为ScalaTest支持的风格更具备多样性，可以满足各种不同的需求，例如传统的JUnit风格、函数式风格以及Spec方式。我的一篇博客《ScalaTest的测试风格》详细介绍了各自的语法。</p>

<p>一个被广泛使用的测试工具是Gatling，它是基于Scala、AKKA以及Netty开发的性能测试与压力测试工具。我的同事刘冉在InfoQ发表的文章《新一代服务器性能测试工具Gatling》对Gatling进行了详细深入的介绍。</p>

<p>ScalaMeter也是一款很不错的性能测试工具。我们可以像编写ScalaTest测试那样的风格来编写ScalaMeter性能测试用例，并能够快捷地生成性能测试数据。这些功能都非常有助于我们针对代码或软件产品进行BenchMark测试。我们曾经用ScalaMeter来编写针对Scala集合的性能测试，例如比较Vector、ArrayBuffer、ListBuffer以及List等集合的相关操作，以便于我们更好地使用Scala集合。以下代码展示了如何使用ScalaMeter编写性能测试：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">org.scalameter.api._</span>
</span><span class='line'>
</span><span class='line'><span class="k">object</span> <span class="nc">RangeBenchmark</span>
</span><span class='line'><span class="k">extends</span> <span class="nc">PerformanceTest</span><span class="o">.</span><span class="nc">Microbenchmark</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">ranges</span> <span class="k">=</span> <span class="k">for</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">size</span> <span class="k">&lt;-</span> <span class="nc">Gen</span><span class="o">.</span><span class="n">range</span><span class="o">(</span><span class="s">&quot;size&quot;</span><span class="o">)(</span><span class="mi">300000</span><span class="o">,</span> <span class="mi">1500000</span><span class="o">,</span> <span class="mi">300000</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span> <span class="k">yield</span> <span class="mi">0</span> <span class="n">until</span> <span class="n">size</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">measure</span> <span class="n">method</span> <span class="s">&quot;map&quot;</span> <span class="n">in</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">using</span><span class="o">(</span><span class="n">ranges</span><span class="o">)</span> <span class="n">curve</span><span class="o">(</span><span class="s">&quot;Range&quot;</span><span class="o">)</span> <span class="n">in</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">_</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>根据场景选择框架或工具</h2>

<p>比起Java庞大的社区，以及它提供的浩如烟海般的技术栈，Scala技术栈差不多可以说是沧海一粟。然而，麻雀虽小却五脏俱全，何况Scala以及Scala技术栈仍然走在迈向成熟的道路上。对于Scala程序员而言，因为项目的不同，未必能涉猎所有技术栈，而且针对不同的方面，也有多个选择。在选择这些框架或工具时，应根据实际的场景做出判断。为稳妥起见，最好能运用技术矩阵地方式对多个方案进行设计权衡与决策。</p>

<p>我们也不能固步自封，视Java社区而不顾。毕竟那些Java框架已经经历了千锤百炼，并有许多成功的案例作为佐证。关注Scala技术栈，却又不局限自己的视野，量力而为，选择合适的技术方案，才是设计与开发的正道。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Spark的核心RDD]]></title>
    <link href="http://agiledon.github.com/blog/2014/09/10/understanding-rdd-of-spark/"/>
    <updated>2014-09-10T08:54:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/09/10/understanding-rdd-of-spark</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2014/spark_architecture.jpg">
与许多专有的大数据处理平台不同，Spark建立在统一抽象的RDD之上，使得它可以以基本一致的方式应对不同的大数据处理场景，包括MapReduce，Streaming，SQL，Machine Learning以及Graph等。这即Matei Zaharia所谓的“设计一个通用的编程抽象（Unified Programming Abstraction）。这正是Spark这朵小火花让人着迷的地方。</p>

<p>要理解Spark，就需得理解RDD。</p>

<p><strong>RDD是什么？</strong></p>

<p>RDD，全称为Resilient Distributed Datasets，是一个容错的、并行的数据结构，可以让用户显式地将数据存储到磁盘和内存中，并能控制数据的分区。同时，RDD还提供了一组丰富的操作来操作这些数据。在这些操作中，诸如map、flatMap、filter等转换操作实现了monad模式，很好地契合了Scala的集合操作。除此之外，RDD还提供了诸如join、groupBy、reduceByKey等更为方便的操作（注意，reduceByKey是action，而非transformation），以支持常见的数据运算。</p>

<!-- more -->


<p>通常来讲，针对数据处理有几种常见模型，包括：Iterative Algorithms，Relational Queries，MapReduce，Stream Processing。例如Hadoop MapReduce采用了MapReduces模型，Storm则采用了Stream Processing模型。RDD混合了这四种模型，使得Spark可以应用于各种大数据处理场景。</p>

<p>RDD作为数据结构，本质上是一个只读的分区记录集合。一个RDD可以包含多个分区，每个分区就是一个dataset片段。RDD可以相互依赖。如果RDD的每个分区最多只能被一个Child RDD的一个分区使用，则称之为narrow dependency；若多个Child RDD分区都可以依赖，则称之为wide dependency。不同的操作依据其特性，可能会产生不同的依赖。例如map操作会产生narrow dependency，而join操作则产生wide dependency。</p>

<p>Spark之所以将依赖分为narrow与wide，基于两点原因。</p>

<p>首先，narrow dependencies可以支持在同一个cluster node上以管道形式执行多条命令，例如在执行了map后，紧接着执行filter。相反，wide dependencies需要所有的父分区都是可用的，可能还需要调用类似MapReduce之类的操作进行跨节点传递。</p>

<p>其次，则是从失败恢复的角度考虑。narrow dependencies的失败恢复更有效，因为它只需要重新计算丢失的parent partition即可，而且可以并行地在不同节点进行重计算。而wide dependencies牵涉到RDD各级的多个Parent Partitions。下图说明了narrow dependencies与wide dependencies之间的区别：
<img class="center" src="http://agiledon.github.com/images/2014/rdd_dependency.png"></p>

<p>本图来自Matei Zaharia撰写的论文An Architecture for Fast and General Data Processing on Large Clusters。图中，一个box代表一个RDD，一个带阴影的矩形框代表一个partition。</p>

<p><strong>RDD如何保障数据处理效率？</strong></p>

<p>RDD提供了两方面的特性persistence和patitioning，用户可以通过persist与patitionBy函数来控制RDD的这两个方面。RDD的分区特性与并行计算能力(RDD定义了parallerize函数)，使得Spark可以更好地利用可伸缩的硬件资源。若将分区与持久化二者结合起来，就能更加高效地处理海量数据。例如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">input</span><span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">parseArticle</span> <span class="k">_</span><span class="o">).</span><span class="n">partitionBy</span><span class="o">(</span><span class="n">partitioner</span><span class="o">).</span><span class="n">cache</span><span class="o">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>partitionBy函数需要接受一个Partitioner对象，如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">partitioner</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">HashPartitioner</span><span class="o">(</span><span class="n">sc</span><span class="o">.</span><span class="n">defaultParallelism</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>RDD本质上是一个内存数据集，在访问RDD时，指针只会指向与操作相关的部分。例如存在一个面向列的数据结构，其中一个实现为Int的数组，另一个实现为Float的数组。如果只需要访问Int字段，RDD的指针可以只访问Int数组，避免了对整个数据结构的扫描。</p>

<p>RDD将操作分为两类：transformation与action。无论执行了多少次transformation操作，RDD都不会真正执行运算，只有当action操作被执行时，运算才会触发。而在RDD的内部实现机制中，底层接口则是基于迭代器的，从而使得数据访问变得更高效，也避免了大量中间结果对内存的消耗。</p>

<p>在实现时，RDD针对transformation操作，都提供了对应的继承自RDD的类型，例如map操作会返回MappedRDD，而flatMap则返回FlatMappedRDD。当我们执行map或flatMap操作时，不过是将当前RDD对象传递给对应的RDD对象而已。例如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">map</span><span class="o">[</span><span class="kt">U:</span> <span class="kt">ClassTag</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">U</span><span class="o">]</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">MappedRDD</span><span class="o">(</span><span class="k">this</span><span class="o">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">clean</span><span class="o">(</span><span class="n">f</span><span class="o">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>这些继承自RDD的类都定义了compute函数。该函数会在action操作被调用时触发，在函数内部是通过迭代器进行对应的转换操作：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">private</span><span class="o">[</span><span class="kt">spark</span><span class="o">]</span>
</span><span class='line'><span class="k">class</span> <span class="nc">MappedRDD</span><span class="o">[</span><span class="kt">U:</span> <span class="kt">ClassTag</span>, <span class="kt">T:</span> <span class="kt">ClassTag</span><span class="o">](</span><span class="n">prev</span><span class="k">:</span> <span class="kt">RDD</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">f</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="n">U</span><span class="o">)</span>
</span><span class='line'>  <span class="k">extends</span> <span class="nc">RDD</span><span class="o">[</span><span class="kt">U</span><span class="o">](</span><span class="n">prev</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">getPartitions</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Partition</span><span class="o">]</span> <span class="k">=</span> <span class="n">firstParent</span><span class="o">[</span><span class="kt">T</span><span class="o">].</span><span class="n">partitions</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">compute</span><span class="o">(</span><span class="n">split</span><span class="k">:</span> <span class="kt">Partition</span><span class="o">,</span> <span class="n">context</span><span class="k">:</span> <span class="kt">TaskContext</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">firstParent</span><span class="o">[</span><span class="kt">T</span><span class="o">].</span><span class="n">iterator</span><span class="o">(</span><span class="n">split</span><span class="o">,</span> <span class="n">context</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">f</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p><strong>RDD对容错的支持</strong></p>

<p>支持容错通常采用两种方式：数据复制或日志记录。对于以数据为中心的系统而言，这两种方式都非常昂贵，因为它需要跨集群网络拷贝大量数据，毕竟带宽的数据远远低于内存。</p>

<p>RDD天生是支持容错的。首先，它自身是一个不变的(immutable)数据集，其次，它能够记住构建它的操作图（Graph of Operation），因此当执行任务的Worker失败时，完全可以通过操作图获得之前执行的操作，进行重新计算。由于无需采用replication方式支持容错，很好地降低了跨网络的数据传输成本。</p>

<p>不过，在某些场景下，Spark也需要利用记录日志的方式来支持容错。例如，在Spark Streaming中，针对数据进行update操作，或者调用Streaming提供的window操作时，就需要恢复执行过程的中间状态。此时，需要通过Spark提供的checkpoint机制，以支持操作能够从checkpoint得到恢复。</p>

<p>针对RDD的wide dependency，最有效的容错方式同样还是采用checkpoint机制。不过，似乎Spark的最新版本仍然没有引入auto checkpointing机制。</p>

<p><strong>总结</strong></p>

<p>RDD是Spark的核心，也是整个Spark的架构基础。它的特性可以总结如下：
* 它是不变的数据结构存储
* 它是支持跨集群的分布式数据结构
* 可以根据数据记录的key对结构进行分区
* 提供了粗粒度的操作，且这些操作都支持分区
* 它将数据存储在内存中，从而提供了低延迟性</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[可视化设计工作坊]]></title>
    <link href="http://agiledon.github.com/blog/2014/08/09/visualize-design-workshop/"/>
    <updated>2014-08-09T12:55:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/08/09/visualize-design-workshop</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2014/workshop.jpg">
之所以选择可视化手段来进行软件设计——非UI或UX的设计——是基于我对设计的理解：<strong>设计并非文档，而是交流</strong>。那种依靠一位英雄来完成所有的设计，并编撰为详尽的文档，然后让程序员连蒙带猜按图索骥的设计方式，完全不可取。尤其在一个自组织的开发团队中，我们希望人人都是程序员，人人都是软件设计师，人人都是架构师。</p>

<p>那么，该如何做到充分的交流，就像风吹过树林，不分彼此的摇动每一片树叶？我想到最简单直截的方式：可视化。然而，此可视化非UML之所谓的“一图胜千言”。没错，我们当然需要绘制设计图，而且必须绘制设计图，但我们更希望是以草图的形式，并辅以视觉引导，来推着团队的每个成员，渐进地完善设计，直到抵达设计的真相。我们没有门派偏见，亦不愿邯郸学步，因而我们既信奉“拿来主义”，又会依据设计的本质原则与真谛，进行了细微的创新。创新未必一定是无中生有，“旧瓶装新酒”或是对经典的追随，“新瓶装旧酒”又何尝不能看作是创意的包装！</p>

<p>此次在TID会议上的可视化设计工作坊算是我与姜志辉针对此主题的一次彩排吧。我们从未就此话题有过深度合作，但是，我们对设计的理解是志同道合的，说得肉麻点，有心有灵犀的感觉。下图是整个工作坊的路径缩影：
<img class="center" src="http://agiledon.github.com/images/2014/visulaizationdesign.jpg"></p>

<p>我们的主线就是设计的可视化，整个过程我们通过草图、即时贴、画布等多种方式来触发团队成员之间的交流与讨论。至于方法工具箱，则几乎等同于一个大杂烩了。我们使用经典的用例图进行需求分析（我们会以商业画布为需求的起点，因为时间关系省去了此步骤），继而根据用例的边界获得DDD中所谓的Bounded Context。
<img class="center" src="http://agiledon.github.com/images/2014/contextmap.jpg"></p>

<p>通过运用DDD的Context Map，我们辨别出Context之间的上下游关系与各种集成方式，继而利用Cockburn的六边形架构以及传统的分层架构，驱动出系统的应用逻辑架构与物理架构。
<img class="center" src="http://agiledon.github.com/images/2014/haxagon_workshop.jpg"></p>

<p>然后，我们跳入Context的内部，开始领域建模。我们尝试了两种领域建模方式：健壮性分析与四色建模，以此为起点，我们可以得到粗略的CRC草图，之后就进入了我和姜志辉提出的设计画布。
<img class="center" src="http://agiledon.github.com/images/2014/designcanvas.jpg"></p>

<p>我们希望看到的是这样的交流场景，如此才可碰撞出好设计的火花。
<img class="center" src="http://agiledon.github.com/images/2014/workshop01.jpg">
<img class="center" src="http://agiledon.github.com/images/2014/workshop02.jpg"></p>

<p>可视化设计并非仅能针对一个新系统，或者仅用于设计阶段。</p>

<p>例如，我曾经在客户处通过运用我提出的依赖沉淀图，让团队成员以交流协作的方式完成对遗留系统模块依赖关系的梳理。这种依赖关系梳理虽然可以利用工具来生成，但采用可视化的方式却可以充分保障成员之间的知识共享。它追求的并非只是结果，而是整个协作的过程。又例如，我们也可以在Inception阶段，通过可视化设计来评估风险，或针对候选技术进行Spike，又或者运用六边形架构等方式来梳理系统与周边系统之间的关系，以便于团队理解整个软件产品的生态系统。</p>

<p>其实，这种可视化设计，我更倾向于称之为“体验式设计”，但它与ThoughtWorks提出的XD并非专注同一个层面的内容。当然，这种体验式的软件设计，我还处于试验的摸索阶段。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何实现领域驱动设计]]></title>
    <link href="http://agiledon.github.com/blog/2014/08/05/how-to-implement-ddd/"/>
    <updated>2014-08-05T19:34:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/08/05/how-to-implement-ddd</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2014/iddd.jpg">
从Eric Evans写下经典名著Domain-Driven Design: Tackling Complexity in the Heart of Software至今，DDD刚好发展了十年的时间。它几乎成了开发复杂软件系统主要的领域设计方法，既是面向对象（组件）设计的补充，又超越了面向对象（组件）设计。DDD中提出的诸多概念如实体、值对象、聚合等，已经成为了耳熟能详的设计术语。DDD社区的发展也如火如荼，似乎并没有被层出不穷的设计思想所取代，相反，它仍在强劲地发展，吸收了许多新的概念与方法，例如函数式编程思想、Event Source、CQRS等。然而，就我个人所观察到的情况来看，许多项目虽然号称应用了DDD设计，但主要都停留在Eric所谓的“战术设计”层面。即使是战术层面，依旧有许多程序员没有弄明白实体与值对象之间的区别，不知道该怎么定义聚合以及聚合根，更谈不上合理地划分上下文（Context）。</p>

<p>我不明白其中内含的真实原因，只能冒昧地揣测是否DDD显得高高在上？究其原因，会否还是Eric惹的祸，他的那本经典之作美则美矣，却显得有些不接地气？至少，我的阅读感受正是如此。虽然在之后，国内也引进了其他一些与DDD相关的著作，例如Jimmy Nilsson的著作《领域驱动设计与模式实战》。这些书好虽好，却并没有全面深入地阐述领域驱动设计，更谈不上完整地实践，直到Vaughn Vernon的《实现领域驱动设计（Implementing Domain-Driven Design）》的出现。</p>

<p>这本书首先吸引我的是书中的第2章至第4章。虽然书中内容几乎忠实地反映了Eric Evans的DDD理论，但作者却创造性地在一开始就着眼于DDD的战略性设计，包括领域（Domain）、子域（Subdomain）、受限上下文（Unbounded Context）、上下文映射（Context Map）以及架构。以第4章架构为例，书中对DDD经典的分层架构进行了深入探讨与分析，并颠覆性地提出将基础设施层（Infrastructure Layer）置于用户接口层（User Interface Layer）之上。最初读来，简直让我莫名惊诧，然而仔细思索，从依赖倒置原则的角度来分析，实在是合乎情理。坦白说，它彻底解决了之前一直纠缠在我心底的一个问题：若我们视实体为Repository以及数据访问的对象，应将实体置于哪一层？在DDD中，实体对象承担了领域业务行为，但同时又可能通过ORM与数据表产生映射。基础设施层的数据访问对象（即传统的DAO）需要调用这些实体对象。若它处于最底层，则会造成业务行为与基础设施的混合。若将实体与数据映射对象分离，既会造成对象之间的重复，又会导致不好的贫血对象。而将基础设施层放在分层架构的上端，非常巧妙地解决了这一问题。</p>

<!-- more -->


<p>我尤其喜欢本书引荐的由Corkburn提出的六边形（Hexagonal）架构。它完全突破了传统分层架构的窠臼，以独到的边界划分手法指导我们遵循关注点分离原则。该架构模式对端口（Port）与适配器（Adapter）的强调，使得我们可以在架构分析与设计时，更加关注系统之间的集成点，从而形成可视性极强的物理架构。这对于建立可伸缩的分布式架构尤有价值。我已在多个项目的架构设计中，运用了六边形架构模式，可谓收获颇丰。书中还提到了相对较新的RESTful架构，CQRS架构以及事件驱动的架构模式和网格分布式计算。该书的附录还进一步探讨了聚合对象与事件源的组合设计。这些内容有助于我们树立整体的DDD架构观，可以说弥补了Eric书中对这些内容的空白。</p>

<p>Vaughn Vernon是真正懂得写作的技术专家，他非常懂得如何“讨好”读者。翻开书，阅读第一章，你就会爱上它，爱上DDD。书中给出的例子实在太棒了。看看他对saveCustomer()方法的版本演进，你会幡然醒悟，原来代码应该这样写。领域对象是一位谨慎的保密者，他严格地谨守着自己的秘密，只把业务外部行为暴露给你，使得你可以读懂它，却不应该干扰它的内部实现。这正是DDD中通用语言的价值。身为一名技术人员，我们精通Java、C#、Scala、Ruby等等语言，却忘了在企业开发中，真正需要展现的其实是业务通用语言。写代码首先是与人交流，而不是机器。</p>

<p>本书的精彩章节有很多，几乎阅读每篇都会有感悟。但我个人认为，尤其彰显本书价值的是第8章与第10章。并非其他章节不够好，但相对于实体、值对象等容易理解的概念而言，聚合总是被人所误用，又或者让人茫然不知所措。第10章总结了非常实用的聚合设计原则。例如，在一致性边界之内对真正的不变量进行建模的原则；设计小聚合的原则；通过唯一标识引用其他聚合的原则。在边界之外使用最终一致性的原则。</p>

<p>至于第8章介绍的Domain Event，则是因为它不同于Eric的著作，将事件当做了与实体同等地位的头等公民。结合本书对事件驱动以及事件源的讲解，相信你在之后的领域建模时，会重视对领域事件的识别。若能正确地理解事件，则可以更好地掌握CQRS模式，并因地制宜地运用这一模式。</p>

<p>该书书名为Implementing（实现） Domain-Driven Design，就说明作者的意图是要让DDD真正落地。怎么做到？——上实例！书中给出的虽然是虚拟案例，却非常接近真实。作者甚至按照一种演进设计的方式深入浅出地介绍了这两个完整案例。最能够帮助人理解的是，他在讲授DDD时，还结合案例给出了之前欠佳的反面案例，并通过识别设计的坏味道，运用DDD方式对其进行改进。作者甚至创造了虚拟的场景，使得我们在阅读这些内容时，就好像真正参与了设计师的讨论，甚至能听到他们的唇枪舌剑，最后是DDD专家的总结陈词，真好比身临其境地加入了这个虚拟团队，一起学习，一起分享，共同成长。</p>

<p>坦白说，我在阅读本书时方才发觉自己在DDD上的浅薄无知。或许是自己的悟性不够，未能很好地理解Eric提出的DDD概念。阅读此书，让我有醍醐灌顶之感。现在，对于DDD，我已渐窥门径。若能多结合项目实践，定能登堂入室，甚至走得更远。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试数据准备框架]]></title>
    <link href="http://agiledon.github.com/blog/2014/08/03/test-data-prepare-framework/"/>
    <updated>2014-08-03T21:25:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/08/03/test-data-prepare-framework</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2014/sisyphus.jpg"></p>

<p>这是我去年写的一个小框架，专为自动化测试准备数据。以我个人的经验，进行自动化测试尤其是单元测试，除了技能的障碍外，最大的障碍有两点：1)难以解除依赖，因而无法为相关功能编写独立的测试；2)数据准备困难，导致编写测试的成本高。在我的一篇博客《<a href="http://agiledon.github.io/blog/2013/12/25/thought-about-applying-tdd/">推行TDD的思考</a>》中有相关总结。尤其在企业级软件系统中，面对的领域相对复杂，被测接口常常需要输入复杂的数据，然后再返回复杂的数据。在面向对象开发中，这些数据常常被建模为对象。我们该怎么实例化这些对象？在单元测试中，我们常常会引入Builder模式，通过Fluent Interface的方式建立类似DSL的构建接口，以便于自由、流畅而可任意组合的方式，帮助编写测试的人实例化他想要创建的对象。然而，一旦这个对象内嵌了多层，或具有极多的属性时，创建就变得极为艰难了。</p>

<p>在ThoughtWorks的一些项目中，尝试使用Yaml来准备数据。有一个极好的框架snakeyaml可以很好地支持我们处理yaml文件。正是基于此，启发我开发了这样一个小框架Sisyphus。它可以帮助更方便地以各种文件形式来准备数据，并提供了统一的接口。目前，支持的格式为我们最常使用的yaml与json。</p>

<p>框架的开发并没有什么技术含量，但框架提供的功能却是基于实际项目中面临的困难逐步演化出来的。例如框架提供的模板功能，数据分节功能，在一开始并没有想到。正是因为这两个功能，让我觉得这个框架还有一些用处。之所以将这个框架命名为Sisyphus，缘由在于我将测试数据视为西西弗推动的那一块大石头，无法承受的如命运一般的沉重，却又不得不用力去承受，如此往返以致时时刻刻。</p>

<!-- more -->


<p>要使用Sisyphus，可以在build.gradle的构建脚本中添加sonatype提供的Repository依赖：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='groovy'><span class='line'><span class="n">repositories</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">maven</span><span class="o">{</span>
</span><span class='line'>        <span class="n">url</span> <span class="s1">&#39;https://oss.sonatype.org/content/groups/public&#39;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">mavenCentral</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">dependencies</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">test</span> <span class="o">(</span>
</span><span class='line'>            <span class="s1">&#39;junit:junit:4.11&#39;</span><span class="o">,</span>
</span><span class='line'>            <span class="s1">&#39;com.github.agiledon:sisyphus:1.0-SNAPSHOT&#39;</span>
</span><span class='line'>        <span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>针对Yaml文件，我选择了snakeyaml框架。而对于Json数据，我尝试了两种框架Jackson和Gson。我发现这两个框架各有不足之处。倘若使用Jackson，它要求你要反序列化的类型必须定义默认的构造函数，如果没有定义，则必须声明Annotation：@JsonCreate和@JsonProperty。可是，有时候我们要准备的数据对象，或许是自动生成的，并不能修改该定义。何况，为了进行测试而改变产品代码，是邪恶的，不可取。Gson没有这样的约束，但当我尝试将一段字符串解析为byte[]类型时，发现Gson并不支持。为此，Sisyphus为Json数据提供了两种实现，为了区分，若是Gson实现，则要求测试数据文件的扩展名必须为“.gson”。</p>

<p>模板功能使用了ST4的StringTemplate。我没有使用该框架提供的默认变量标识，而是要求将变量用$符号包裹起来。如果不需要模板，则只需提供一个测试数据文件即可；否则还要定义模板文件，它的扩展名为“.template”。例如针对Json格式的数据，倘若定义了这样的User类：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">User</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">enum</span> <span class="n">Gender</span> <span class="o">{</span> <span class="n">MALE</span><span class="o">,</span> <span class="n">FEMALE</span> <span class="o">};</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Name</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">private</span> <span class="n">String</span> <span class="n">_first</span><span class="o">,</span> <span class="n">_last</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">public</span> <span class="n">String</span> <span class="nf">getFirst</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">_first</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>        <span class="kd">public</span> <span class="n">String</span> <span class="nf">getLast</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">_last</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setFirst</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span> <span class="n">_first</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setLast</span><span class="o">(</span><span class="n">String</span> <span class="n">s</span><span class="o">)</span> <span class="o">{</span> <span class="n">_last</span> <span class="o">=</span> <span class="n">s</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Gender</span> <span class="n">_gender</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Name</span> <span class="n">_name</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="n">_isVerified</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">byte</span><span class="o">[]</span> <span class="n">_userImage</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Name</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">_name</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">isVerified</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">_isVerified</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Gender</span> <span class="nf">getGender</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">_gender</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">byte</span><span class="o">[]</span> <span class="nf">getUserImage</span><span class="o">()</span> <span class="o">{</span> <span class="k">return</span> <span class="n">_userImage</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">Name</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span> <span class="n">_name</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setVerified</span><span class="o">(</span><span class="kt">boolean</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="n">_isVerified</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setGender</span><span class="o">(</span><span class="n">Gender</span> <span class="n">g</span><span class="o">)</span> <span class="o">{</span> <span class="n">_gender</span> <span class="o">=</span> <span class="n">g</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUserImage</span><span class="o">(</span><span class="kt">byte</span><span class="o">[]</span> <span class="n">b</span><span class="o">)</span> <span class="o">{</span> <span class="n">_userImage</span> <span class="o">=</span> <span class="n">b</span><span class="o">;</span> <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>则可以准备模板文件为：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>{
</span><span class='line'>  "name" : { "first" : $firstName$, "last" : $lastName$ },
</span><span class='line'>  "gender" : "MALE",
</span><span class='line'>  "verified" : false,
</span><span class='line'>  "userImage" : "Rm9vYmFyIQ=="
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>而数据文件则可以是：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'># This is multi section sample
</span><span class='line'>firstName = "Joe"
</span><span class='line'>lastName = "Sixpack"
</span><span class='line'>
</span><span class='line'>///
</span><span class='line'>
</span><span class='line'>firstName = "Bruce"
</span><span class='line'>lastName = "Zhang"
</span><span class='line'>
</span><span class='line'>///
</span><span class='line'>
</span><span class='line'>firstName = "Yi"
</span><span class='line'>lastName = "Zhang"</span></code></pre></td></tr></table></div></figure>


<p>符号///是分节的标识符，而符号#则为注释，读取数据时会忽略该符号后的所有字符。使用Sisyphus框架，就可以很方便地加载数据文件，从而获得三个User实例。如下测试：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_compose_multi_user_data_by_parsing_template_file</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">List</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span> <span class="n">users</span> <span class="o">=</span> <span class="n">Fixture</span><span class="o">.</span><span class="na">from</span><span class="o">(</span><span class="s">&quot;userWithMultiSections.json&quot;</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">withTemplate</span><span class="o">(</span><span class="s">&quot;template/user.template&quot;</span><span class="o">)</span>
</span><span class='line'>                <span class="o">.</span><span class="na">toList</span><span class="o">(</span><span class="n">User</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">users</span><span class="o">,</span> <span class="n">not</span><span class="o">(</span><span class="n">nullValue</span><span class="o">()));</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">users</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">getName</span><span class="o">().</span><span class="na">getFirst</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">));</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">users</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">getName</span><span class="o">().</span><span class="na">getLast</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="s">&quot;Sixpack&quot;</span><span class="o">));</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">users</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">getName</span><span class="o">().</span><span class="na">getFirst</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="s">&quot;Yi&quot;</span><span class="o">));</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">users</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">2</span><span class="o">).</span><span class="na">getName</span><span class="o">().</span><span class="na">getLast</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="s">&quot;Zhang&quot;</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Sisyphus框架还提供了将实例化好的对象输出为对应格式数据文件的功能。这个功能算是框架提供的一个辅助功能，可以避免手动去准备数据文件。例如我们可以先创建一个User实例，将其输出为yaml格式的数据文件，从而将该文件作为测试数据文件：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'>   <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_serialize_specific_object_to_string_with_yaml_format</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">createUser</span><span class="o">();</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">result</span> <span class="o">=</span> <span class="n">FixtureAssist</span><span class="o">.</span><span class="na">yaml</span><span class="o">().</span><span class="na">print</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="s">&quot;outputUser&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">is</span><span class="o">(</span><span class="s">&quot;!!com.github.agiledon.sisyphus.domain.json.User\n&quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;gender: MALE\n&quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;name: {first: Yi, last: Zhang}\n&quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;userImage: !!binary |-\n&quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;  MDAwMDExMTE=\n&quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;verified: true\n&quot;</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>框架在加载数据文件时，本身提供了缓存功能，如果重复加载同一个文件，则第二次加载时，并不需要真正去读取文件，从而在一定程度上提高了测试的效率。</p>

<p>框架的入口为Fixture类。若要使用Sisyphus准备数据，通常应调用Fixture的静态方法。框架也提供了对JUnit的支持，通过框架自定义的Rule来加载测试数据，使用方式为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DataProviderRuleTest</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Rule</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">DataProviderRule</span> <span class="n">dataProvider</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DataProviderRule</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="nd">@DataResource</span><span class="o">(</span><span class="n">resourceName</span> <span class="o">=</span> <span class="s">&quot;user.json&quot;</span><span class="o">,</span> <span class="n">targetClass</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_compose_User_data_with_json_format</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">dataProvider</span><span class="o">.</span><span class="na">provideData</span><span class="o">();</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">not</span><span class="o">(</span><span class="n">nullValue</span><span class="o">()));</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">getFirst</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="nd">@DataResource</span><span class="o">(</span><span class="n">resourceName</span> <span class="o">=</span> <span class="s">&quot;userWithTemplate.json&quot;</span><span class="o">,</span>
</span><span class='line'>            <span class="n">templateName</span> <span class="o">=</span> <span class="s">&quot;template/user.template&quot;</span><span class="o">,</span>
</span><span class='line'>            <span class="n">targetClass</span> <span class="o">=</span> <span class="n">User</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_compose_user_data_by_parsing_template_file</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">User</span> <span class="n">user</span> <span class="o">=</span> <span class="n">dataProvider</span><span class="o">.</span><span class="na">provideData</span><span class="o">();</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">not</span><span class="o">(</span><span class="n">nullValue</span><span class="o">()));</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">getFirst</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="s">&quot;Joe&quot;</span><span class="o">));</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">user</span><span class="o">.</span><span class="na">getName</span><span class="o">().</span><span class="na">getLast</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="s">&quot;Sixpack&quot;</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但我个人并不推荐这种方式。使用Fixture更直观，甚至更简单。Sisyphus的源代码可以从<a href="https://github.com/agiledon/sisyphus">我的Github</a>上获得，在其Repository主页，有更多实例介绍。你也可以clone代码后，通过测试代码学习框架的使用。clone代码到本地后，将当前目录转到sisyphus，然后运行gradle build，即可对代码进行编译。若需运行测试，可运行gradle test。由于我使用的IDE为IntelliJ Idea，因此，框架的构建脚本中仅支持IDEA。你可以通过运行gradle idea来生成IntelliJ的项目。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ThoughtWorks中国区文集出版]]></title>
    <link href="http://agiledon.github.com/blog/2014/08/01/thoughtworks-china-book/"/>
    <updated>2014-08-01T23:25:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/08/01/thoughtworks-china-book</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2014/tw_book.png"></p>

<p>这次参加TID会议，居然看到了这本耗时达3年的书《<a href="http://product.china-pub.com/4243605">软件开发践行录——ThoughtWorks中国区文集</a>》——终于出版了。很早以前，凯峰就提出这个想法，当时他作为InfoQ中文站原创社区的主编，着实策划了不少优秀的原创技术文章。凯峰作为ThoughtWorks的一份子，很好地搭建了ThoughtWorks实践与社区的分享桥梁。不少由TWer撰写的优秀文章陆续在InfoQ发表。然而，从想法到本书出版经历了如此漫长的时间，却也出乎我意料之外。大约一年前，在我提供了个人信息给负责此事的同事后，就没再关心此事，差不多就要淡忘了。如今看到这本漂亮的汇集了中国区TWer心得体会的小书，真是莫名的惊喜啊。就好似那些珍贵的东西你会忘记，却在再次遇见时，忽然发现这种珍贵一点都没有减少。</p>

<p>无论如何，我都为加入ThoughtWorks感到开心而自豪；我也为能有文章选入这本文集而感到荣幸。这是一本散文集，是我们书写在IT边上的日志，又或是一种对技术的诠释与注解，未必必然美丽，却是心灵的一种悸动，一声叹息，是因为技术的狂热而挑动的心弦。这份执着，更是一种美——必然是美！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scala学习资源]]></title>
    <link href="http://agiledon.github.com/blog/2014/07/20/scala-resource/"/>
    <updated>2014-07-20T22:17:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/07/20/scala-resource</id>
    <content type="html"><![CDATA[<h2>网站</h2>

<p>Twitter提供的<a href="http://twitter.github.io/scala_school/zh_cn/basics.html">Scala School</a>：讲解简洁，可以作为快速入门</p>

<p>Twitter编写的如何有效开发Scala的文档——<a href="http://twitter.github.io/effectivescala/index.html">Effective Scala</a></p>

<p>一个非常棒的<a href="http://zh.scala-tour.com">Scala网上教程</a>：可以直接在网页上修改程序和运行程序</p>

<p>很好的<a href="http://www.artima.com/index.jsp">Scala社区网站</a>：只是最近似乎很少更新</p>

<p>当然，不能忘记了Scala的<a href="http://www.scala-lang.org/documentation/">官方网站提供的文档</a>：这或许可以说是最权威的内容，同时，也会提供最新的内容</p>

<p>我自己整理的<a href="https://github.com/agiledon/scala_coding_convention">Scala编码规范与最佳实践</a>：是我结合项目情况并参考相关书籍和文章，以及个人的体会整理的。内容在不断更新中。若愿意贡献一份力量，可以和我联系，我可以加你为Contributor。</p>

<h2>博客</h2>

<p>Alvin Alexander的<a href="http://alvinalexander.com/scala">博客</a>：内有诸多Scala文章，Alvin是Scala Cookbook一书的作者</p>

<p>阿里巴巴Hongjiang的<a href="http://hongjiang.info/scala/">博客</a>：有很多成系列的Scala文章</p>

<h2>视频与教程</h2>

<p>Scala之父Martin Odersky在<a href="https://www.coursera.org/course/progfun">Scala教学视频</a>。你还可以在<a href="http://www.gtan.com/welfare05.html">国内的这个网站</a>上在线观看，在这个网站上，你还能阅读到Akka文档的中文版。</p>

<p>你还可以通过<a href="http://www.typesafe.com/activator">下载Activator</a>，然后通过运行activator，生成各式各样的Scala开发模板（包括Play、Akka、Spray、Spark）。生成的模板有代码和简明教程。</p>

<p>若想更扎实的掌握函数式编程，可以在学习Scala之前，先学习Heskell。
学习<a href="http://learnyouahaskell.com/chapters">Heskell的在线书</a>：写得简洁易懂，很生动。可以作为heskell的入门书籍</p>

<h2>书籍</h2>

<p>如果你希望快速地了解Scala的语法，可以阅读《<a href="http://book.douban.com/subject/19971952/">快学Scala</a>》，即Scala for the I&#8217;mpatient；但是，如果你希望了解真正的Scala精髓，那么奉劝大家不要阅读此书，而应该阅读Scala宝典，由Martin Odersky亲自撰写的著作<a href="http://book.douban.com/subject/3338669/">Programming in Scala</a>。不要阅读此书的中文版，翻译实在糟糕。</p>

<p>如果你想要深入理解Scala的内在机制，可以阅读<a href="http://book.douban.com/subject/6962379/">Scala in Depth</a>；我的同事<a href="http://kaopua.com/blog/">诺铁</a>翻译了此书，即日出版。</p>

<p>如果你想了解更多Scala的案例运用，可以阅读<a href="http://book.douban.com/subject/20876182/">Scala Cookbook</a>。书中提供了大量的案例。</p>

<p>如果你想了解Scala的函数式运用，请阅读Paul Chiusano撰写的<a href="http://book.douban.com/subject/20488750/">Functional Programming in Scala</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ListBuffer vs List in Scala]]></title>
    <link href="http://agiledon.github.com/blog/2014/07/07/using-listbuffer-vs-list/"/>
    <updated>2014-07-07T19:19:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/07/07/using-listbuffer-vs-list</id>
    <content type="html"><![CDATA[<p>我们有一个需求，需要在Scala中调用JDBC对数据库进行查询。然后将查询的结果ResultSet放到一个自定义结果类SqlResult中：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">SqlResult</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">value</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span>
</span></code></pre></td></tr></table></div></figure>


<p>SqlResult的第一个构造函数参数存储的是数据表的列名，第二个参数存储数据表的行记录。由于ResultSet是Java中的一个对象，并不支持Scala的常用集合操作，因此这种转换是有必要的。我引入了隐式类（放在一个package object中）来完成这个转换，在转换过程中，由于需要对ResultSet进行遍历，因而引入了一个结果集List。默认情况下，Scala的List是immutable的，因此将其声明为var：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">package</span> <span class="nn">object</span> <span class="n">db</span> <span class="o">{</span>
</span><span class='line'>     <span class="k">implicit</span> <span class="k">class</span> <span class="nc">ResultSetUtil</span><span class="o">(</span><span class="n">rs</span><span class="k">:</span> <span class="kt">ResultSet</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">private</span> <span class="k">val</span> <span class="n">columnCount</span> <span class="k">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">getMetaData</span><span class="o">.</span><span class="n">getColumnCount</span>
</span><span class='line'>
</span><span class='line'>          <span class="k">def</span> <span class="n">rows</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>               <span class="k">var</span> <span class="n">valueList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
</span><span class='line'>               <span class="k">while</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">next</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                    <span class="k">val</span> <span class="n">oneLine</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">columnCount</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">getString</span><span class="o">).</span><span class="n">toList</span>
</span><span class='line'>                    <span class="n">valueList</span> <span class="k">=</span> <span class="n">oneLine</span> <span class="o">::</span> <span class="n">valueList</span>
</span><span class='line'>               <span class="o">}</span>
</span><span class='line'>               <span class="n">valueList</span><span class="o">.</span><span class="n">reverse</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>          <span class="k">def</span> <span class="n">columns</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>               <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">columnCount</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">getMetaData</span><span class="o">.</span><span class="n">getColumnName</span><span class="o">).</span><span class="n">toList</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>     <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>有了这个隐式转换，操作ResultSet就变简单了：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">query</span><span class="o">(</span><span class="n">sql</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">SqlResult</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">stmt</span> <span class="k">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">createStatement</span><span class="o">()</span>
</span><span class='line'>    <span class="n">rs</span> <span class="k">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">executeQuery</span><span class="o">(</span><span class="n">sql</span><span class="o">)</span>
</span><span class='line'>    <span class="nc">SqlResult</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">columns</span><span class="o">,</span> <span class="n">rs</span><span class="o">.</span><span class="n">rows</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于在前面的实现中，我初始化了一个Immutable的List，因此只能使用::添加每行从ResultSet得到的记录，然后再赋值给valueList。::方法只能将后加入的元素放到List的头部。所以在遍历完毕后，还需要做一个reverse操作。</p>

<!-- more -->


<p>我的感觉告诉我，这种先添加再反转的做法有些怪异。既然这里是以var的方式来使用Immutable List，为何不直接使用Mutable的集合呢？于是，我将前面的rows方法修改为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">scala.collection.mutable.ListBuffer</span>
</span><span class='line'><span class="k">package</span> <span class="nn">object</span> <span class="n">db</span> <span class="o">{</span>
</span><span class='line'>     <span class="k">implicit</span> <span class="k">class</span> <span class="nc">ResultSetUtil</span><span class="o">(</span><span class="n">rs</span><span class="k">:</span> <span class="kt">ResultSet</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>          <span class="k">def</span> <span class="n">rows</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>               <span class="k">val</span> <span class="n">valueList</span><span class="k">:</span> <span class="kt">ListBuffer</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">ListBuffer</span><span class="o">()</span>
</span><span class='line'>               <span class="k">while</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">next</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                    <span class="k">val</span> <span class="n">oneLine</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">columnCount</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">getString</span><span class="o">).</span><span class="n">toList</span>
</span><span class='line'>                    <span class="n">valueList</span> <span class="o">+=</span> <span class="n">oneLine</span>
</span><span class='line'>               <span class="o">}</span>
</span><span class='line'>               <span class="n">valueList</span><span class="o">.</span><span class="n">toList</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为rows方法返回的是Immutable List，所以在后面需要调用一个转换方法，将ListBuffer转换为List；但这个实现减少了对reverse方法的调用。于是，我产生了一个疑惑：这两种实现，究竟谁的性能更好呢？</p>

<p>为了判断彼此的性能，我首先写了一段简单的小代码，并放到perf.scala文件中：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">java.util.Date</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scala.collection.mutable.ListBuffer</span>
</span><span class='line'>
</span><span class='line'><span class="k">object</span> <span class="nc">PerformanceTest</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">maxCount</span> <span class="k">=</span> <span class="n">args</span><span class="o">.</span><span class="n">head</span><span class="o">.</span><span class="n">toInt</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">args</span><span class="o">.</span><span class="n">tail</span><span class="o">.</span><span class="n">head</span> <span class="k">match</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="s">&quot;list&quot;</span> <span class="k">=&gt;</span>
</span><span class='line'>          <span class="n">println</span><span class="o">(</span><span class="s">&quot;using List:&quot;</span><span class="o">)</span>
</span><span class='line'>          <span class="k">var</span> <span class="n">time</span> <span class="k">=</span> <span class="n">elapsedTime</span><span class="o">{</span> <span class="n">max</span> <span class="k">=&gt;</span>
</span><span class='line'>             <span class="k">var</span> <span class="n">l</span> <span class="k">=</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span>
</span><span class='line'>              <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">max</span><span class="o">).</span><span class="n">foreach</span> <span class="o">{</span>
</span><span class='line'>                 <span class="n">i</span> <span class="k">=&gt;</span> <span class="n">i</span> <span class="o">::</span> <span class="n">l</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">l</span><span class="o">.</span><span class="n">reverse</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;it elapsed $time(ms)&quot;</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>       <span class="k">case</span> <span class="s">&quot;listbuffer&quot;</span> <span class="k">=&gt;</span>
</span><span class='line'>          <span class="n">println</span><span class="o">(</span><span class="s">&quot;using ListBuffer:&quot;</span><span class="o">)</span>
</span><span class='line'>           <span class="n">time</span> <span class="k">=</span> <span class="n">elapsedTime</span><span class="o">{</span> <span class="n">max</span> <span class="k">=&gt;</span>
</span><span class='line'>              <span class="k">var</span> <span class="n">l</span> <span class="k">=</span> <span class="nc">ListBuffer</span><span class="o">[</span><span class="kt">Int</span><span class="o">]()</span>
</span><span class='line'>              <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">max</span><span class="o">).</span><span class="n">foreach</span> <span class="o">{</span>
</span><span class='line'>                  <span class="n">i</span> <span class="k">=&gt;</span> <span class="n">l</span> <span class="o">+=</span> <span class="n">i</span>
</span><span class='line'>              <span class="o">}</span>
</span><span class='line'>              <span class="n">l</span><span class="o">.</span><span class="n">toList</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>          <span class="n">println</span><span class="o">(</span><span class="n">s</span><span class="s">&quot;it elapsed $time(ms)&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">elapsedTime</span><span class="o">(</span><span class="n">f</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span><span class="kt">Long</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">val</span> <span class="n">before</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">().</span><span class="n">getTime</span>
</span><span class='line'>      <span class="n">f</span><span class="o">(</span><span class="n">maxCount</span><span class="o">)</span>
</span><span class='line'>      <span class="k">val</span> <span class="n">after</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">().</span><span class="n">getTime</span>
</span><span class='line'>      <span class="n">after</span> <span class="o">-</span> <span class="n">before</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>为避免前后干扰，我选择以分支的方式通过传入参数分别执行。编译perf.scala文件。运行scala PerformanceTest 100000 list。此时运行结果为：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>using List:
</span><span class='line'>it elapsed 23(ms)</span></code></pre></td></tr></table></div></figure>


<p>运行scala PerformanceTest 100000 listbuffer。运行结果为：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>using ListBuffer:
</span><span class='line'>it elaspse 26(ms)</span></code></pre></td></tr></table></div></figure>


<p>增加到200,000，结果迥然不同：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>using List:
</span><span class='line'>it elaspse 23(ms)
</span><span class='line'>using ListBuffer:
</span><span class='line'>it elaspse 34(ms)</span></code></pre></td></tr></table></div></figure>


<p>增加到500,000，结果迥然不同：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>using List:
</span><span class='line'>it elaspse 34(ms)
</span><span class='line'>using ListBuffer:
</span><span class='line'>it elaspse 293(ms)</span></code></pre></td></tr></table></div></figure>


<p>增加到1,000,000，结果就更明显了：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>using List:
</span><span class='line'>it elaspse 45(ms)
</span><span class='line'>using ListBuffer:
</span><span class='line'>it elaspse 620(ms)</span></code></pre></td></tr></table></div></figure>


<p>我们假定List方式为A，ListBuffer方式为B。整体看来，方式A消耗的时间都要小于方式B。当数据量越来越大时，这种差距就更加明显。问题在哪里？让我们来看看List与ListBuffer的实现。</p>

<p>首先，考察List对::以及reverse的实现：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">def</span> <span class="o">::[</span><span class="kt">B</span> <span class="k">&gt;:</span> <span class="kt">A</span><span class="o">]</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">B</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">B</span><span class="o">]</span> <span class="k">=</span>
</span><span class='line'>    <span class="k">new</span> <span class="n">scala</span><span class="o">.</span><span class="n">collection</span><span class="o">.</span><span class="n">immutable</span><span class="o">.::(</span><span class="n">x</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">reverse</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">result</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="nc">Nil</span>
</span><span class='line'>    <span class="k">var</span> <span class="n">these</span> <span class="k">=</span> <span class="k">this</span>
</span><span class='line'>    <span class="k">while</span> <span class="o">(!</span><span class="n">these</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">result</span> <span class="k">=</span> <span class="n">these</span><span class="o">.</span><span class="n">head</span> <span class="o">::</span> <span class="n">result</span>
</span><span class='line'>      <span class="n">these</span> <span class="k">=</span> <span class="n">these</span><span class="o">.</span><span class="n">tail</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">result</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>::方法中的scala.collection.immutable.::实际上是一个继承自List的样例类。显然，这里的添加操作就相当于对List对象的创建。每次::操作的时间复杂度为O(C1)。此时的常量值C1基本等于1。由于每次遍历都要执行，因此总的时间为O(C1)*n。事实上，List数据结构增加一个头元素本身就非常简单，基本不耗时。但reverse操作要稍微复杂一些。它同样是复制了一个List，但对原List进行了遍历，然后将原有List的头元素与空List进行::操作，使其变成了last元素，如此遍历。因而时间复杂度为O(n)。</p>

<p>再来考察ListBuffer对+=以及toList的实现：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">override</span> <span class="k">def</span> <span class="n">toList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">A</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">exported</span> <span class="k">=</span> <span class="o">!</span><span class="n">start</span><span class="o">.</span><span class="n">isEmpty</span>
</span><span class='line'>    <span class="n">start</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="o">+=</span> <span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">A</span><span class="o">)</span><span class="k">:</span> <span class="kt">this.</span><span class="k">type</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">exported</span><span class="o">)</span> <span class="n">copy</span><span class="o">()</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">start</span><span class="o">.</span><span class="n">isEmpty</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">last0</span> <span class="k">=</span> <span class="k">new</span> <span class="o">::</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
</span><span class='line'>      <span class="n">start</span> <span class="k">=</span> <span class="n">last0</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">val</span> <span class="n">last1</span> <span class="k">=</span> <span class="n">last0</span>
</span><span class='line'>      <span class="n">last0</span> <span class="k">=</span> <span class="k">new</span> <span class="o">::</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span>
</span><span class='line'>      <span class="n">last1</span><span class="o">.</span><span class="n">tl</span> <span class="k">=</span> <span class="n">last0</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">len</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="k">this</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>toList方法非常简单，因为ListBuffer内部存储了一个List对象，即这里看到的start。start会在每次添加元素时发生变化。因此看起来是一个转换方法，实则就是返回一个字段。时间复杂度为O(1)。再来看+=操作。首先，该方法会判断exported的值。如果为true，则需要执行copy方法。但是，根据OderSky对+=方法的描述（原书513页），只有在将ListBuffer转换为List之后，如果还要对原ListBuffer执行+=操作，才会执行copy方法：</p>

<blockquote><p>However, the implementation of ListBuffer is such that copying is neces- sary only for list buffers that are further extended after they have been turned into lists. This case is quite rare in practice. Most use cases of list buffers add elements incrementally and then do one toList operation at the end. In such cases, no copying is necessary.</p></blockquote>


<p>根据前面列出的toList方法，也可以看到：只要ListBuffer不为空，exported在执行了toList方法后，才会被设置为true。因此，在我们这个例子里，copy方法是不会执行的。显然，+=方法的执行耗时还是体现在if分支上。注意，这里的start类型为List[A]类型，且被声明为var；last0类型为::，同样被声明为var。在上面的语句中，将last0赋值给start，以及将last0赋值给val对象last1，是关键。此时，只要对last1的tl（即tail，声明为var的scala包下可访问的构造函数参数）进行赋值，实则就是会为start增加尾部元素。所以增加一个新元素，其时间复杂度应该为O(C2)，并且这个C2一定大于1。针对我们的例子，每次遍历都要执行+=方法，因此总的时间复杂度为O(C2)*n。</p>

<p>这个推断是比较符合事实的。Odersky的著作Programming in Scala的第24章列出了各种集合的时间复杂度：
<img class="center" src="http://agiledon.github.com/images/2014/scalacollection.png"></p>

<p>比较方案A的O((C+1)n)，要判断谁更优，就是要看各自的C值是多大。分析实现，显然C2 > C1。此外，我们还不要忽略内存的消耗。仔细观察ListBuffer的实现，主要通过var变量start、last0以及一个临时的val变量last0，完成+=操作。相比较List而言，消耗的内存要大得多。事实上，在我将JVM的最大内存设置为512M的前提下，当数值为10,000,000时，执行方式A，消耗时间为119ms，而执行方式B时，就已经抛出OutOfMemoryError的异常了。</p>

<p>显然，当数据量比较大，且性能敏感时，在本文提到的场景下，应优先考虑使用List结合reverse的方式。当然，请注意，这里我虽然使用了Immutable的List，但我将其声明为了var变量。这可以避免在遍历过程中生成临时的List对象。如果采用纯函数无副作用的foldLeft进行转换，例如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">var</span> <span class="n">l</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">max</span><span class="o">).</span><span class="n">foldLeft</span><span class="o">(</span><span class="nc">List</span><span class="o">[</span><span class="kt">Int</span><span class="o">]())((</span><span class="n">a</span><span class="o">,</span> <span class="n">b</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">b</span> <span class="o">::</span> <span class="n">a</span> <span class="o">)</span>
</span><span class='line'><span class="n">l</span><span class="o">.</span><span class="n">reverse</span>
</span></code></pre></td></tr></table></div></figure>


<p>则其性能比较方式A有非常大的区别，数据量为1,000,000时，达到了845ms。而且在同等环境下，数据量达到5,000,000时，就已经抛出OutOfMemoryError的异常了。</p>

<p>看来，在Scala中操作集合并非易事。尤其是需要考虑性能和内存消耗时，更需要小心谨慎。事实上，我同时还比较了ArrayBuffer以及Vector在这种场景下的性能，都远不如这里列出的A方式。而采用foldLeft方式带来的问题更是我之前没有想到的。一定有优化的空间，也一定有更好的最佳实践。必须注意的是，本文主要比较的是添加元素的操作，且A方式的添加为preappend，B方式则为append。对于不同的集合，也有自身的适用场景。希望将来有时间整理一下这些集合操作在性能上的表现，从而选择合理的集合以及操作方式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Magic Scala(1): Call By Name]]></title>
    <link href="http://agiledon.github.com/blog/2014/06/18/magic-scala-1-call-by-name/"/>
    <updated>2014-06-18T23:57:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/06/18/magic-scala-1-call-by-name</id>
    <content type="html"><![CDATA[<p>在Scala中，调用函数有两种形式：Call by value（按值调用）和call by name（按名称调用）。若是call by value，会先计算参数的值，然后再传递给被调用的函数；若是call by name，参数会到实际使用的时候才计算。例如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">logEnable</span> <span class="k">=</span> <span class="kc">false</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">log</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">logEnable</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="nc">MSG</span> <span class="k">=</span> <span class="s">&quot;programing is running&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">log</span><span class="o">(</span><span class="nc">MSG</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>此时的log函数是call by value。因此在调用log函数时，会先计算传入的参数，此时会计算MSG + 1/0。由于表达式中有0作为被除数，因此会抛出异常：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>Exception in thread "main" java.lang.ArithmeticException: / by zero
</span><span class='line'>        at Main$.main(scala-script352098905369979205.scala:16)
</span><span class='line'>        at Main.main(scala-script352098905369979205.scala)
</span><span class='line'>exit value is 1
</span><span class='line'>Program exited.</span></code></pre></td></tr></table></div></figure>


<p>如果修改log的定义为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">log</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>     <span class="k">if</span> <span class="o">(</span><span class="n">logEnable</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>当调用log函数：log(MSG + 1/0)时，它首先并不会计算MSG + 1/0表达式，而是先执行log的函数体，即判断logEnable的值。此时logEnable值为false，此时就不会执行该分支println(msg)。既然不会执行println，就不会计算MSG + 1/0。因此就不会抛出异常。</p>

<p>再看另外一个例子。首先定义一个函数：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">getOneWhatever</span><span class="o">()</span><span class="k">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>     <span class="n">println</span><span class="o">(</span><span class="s">&quot;calling getOneWhatever&quot;</span><span class="o">)</span>
</span><span class='line'>     <span class="mi">1</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后，再定义两个函数，分别用call by value和call by name的方式：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">callByValue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>     <span class="n">println</span><span class="o">(</span><span class="s">&quot;x1=&quot;</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span>
</span><span class='line'>     <span class="n">println</span><span class="o">(</span><span class="s">&quot;x2=&quot;</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">callByName</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>     <span class="n">println</span><span class="o">(</span><span class="s">&quot;x1=&quot;</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span>
</span><span class='line'>     <span class="n">println</span><span class="o">(</span><span class="s">&quot;x2=&quot;</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果执行callByValue(getOneWhatever())，则结果为：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>calling getOneWhatever
</span><span class='line'>x1=1
</span><span class='line'>x2=1</span></code></pre></td></tr></table></div></figure>


<p>若执行callByName(getOneWhatever())，则结果为：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>calling getOneWhatever
</span><span class='line'>x1=1
</span><span class='line'>calling getOneWhatever
</span><span class='line'>x2=1</span></code></pre></td></tr></table></div></figure>


<p>注意看二者的区别，采用by name的方式，getOneWhatever函数被执行了两次，这是因为在callByName函数中，传入的参数被调用了两次。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spark的硬件配置]]></title>
    <link href="http://agiledon.github.com/blog/2014/05/08/hardware-on-spark/"/>
    <updated>2014-05-08T09:19:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/05/08/hardware-on-spark</id>
    <content type="html"><![CDATA[<p>从MapReduce的兴起，就带来一种思路，就是希望通过大量廉价的机器来处理以前需要耗费昂贵资源的海量数据。这种方式事实上是一种架构的水平伸缩模式——真正的以量取胜。毕竟，以现在的硬件发展来看，CPU的核数、内存的容量以及海量存储硬盘，都慢慢变得低廉而高效。然而，对于商业应用的海量数据挖掘或分析来看，硬件成本依旧是开发商非常关注的。当然最好的结果是：既要马儿跑得快，还要马儿少吃草。</p>

<p>Spark相对于Hadoop的MapReduce而言，确乎要跑得迅捷许多。然而，Spark这种In-Memory的计算模式，是否在硬件资源尤其是内存资源的消耗上，要求更高呢？我既找不到这么多机器，也无法租用多台虚拟instance，再没法测评的情况下，只要寻求Spark的官方网站，又或者通过Google搜索。从Spark官方网站，Databricks公司Patrick Wendell的演讲以及Matei Zaharia的Spark论文，找到了一些关于Spark硬件配置的支撑数据。</p>

<h3>Spark与存储系统</h3>

<p>如果Spark使用HDFS作为存储系统，则可以有效地运用Spark的standalone mode cluster，让Spark与HDFS部署在同一台机器上。这种模式的部署非常简单，且读取文件的性能更高。当然，Spark对内存的使用是有要求的，需要合理分配它与HDFS的资源。因此，需要配置Spark和HDFS的环境变量，为各自的任务分配内存和CPU资源，避免相互之间的资源争用。</p>

<p>若HDFS的机器足够好，这种部署可以优先考虑。若数据处理的执行效率要求非常高，那么还是需要采用分离的部署模式，例如部署在Hadoop YARN集群上。</p>

<h3>Spark对磁盘的要求</h3>

<p>Spark是in memory的迭代式运算平台，因此它对磁盘的要求不高。Spark官方推荐为每个节点配置4-8块磁盘，且并不需要配置为RAID（即将磁盘作为单独的mount point）。然后，通过配置spark.local.dir来指定磁盘列表。</p>

<h3>Spark对内存的要求</h3>

<p>Spark虽然是in memory的运算平台，但从官方资料看，似乎本身对内存的要求并不是特别苛刻。官方网站只是要求内存在8GB之上即可（Impala要求机器配置在128GB）。当然，真正要高效处理，仍然是内存越大越好。若内存超过200GB，则需要当心，因为JVM对超过200GB的内存管理存在问题，需要特别的配置。</p>

<p>内存容量足够大，还得真正分给了Spark才行。Spark建议需要提供至少75%的内存空间分配给Spark，至于其余的内存空间，则分配给操作系统与buffer cache。这就需要部署Spark的机器足够干净。</p>

<p>考虑内存消耗问题，倘若我们要处理的数据仅仅是进行一次处理，用完即丢弃，就应该避免使用cache或persist，从而降低对内存的损耗。若确实需要将数据加载到内存中，而内存又不足以加载，则可以设置Storage Level。Spark提供了三种Storage Level：MEMORY_ONLY（这是默认值），MEMORY_AND_DISK，以及DISK_ONLY。</p>

<p>关于数据的持久化，Spark默认是持久化到内存中。但它也提供了三种持久化RDD的存储方式：</p>

<ul>
<li><p>in-memory storage as deserialized Java objects</p></li>
<li><p>in-memory storage as serialised data</p></li>
<li><p>on-disk storage</p></li>
</ul>


<p>第一种存储方式性能最优，第二种方式则对RDD的展现方式（Representing）提供了扩展，第三种方式则用于内存不足时。</p>

<p>然而，在最新版（V1.0.2）的Spark中，提供了更多的Storage Level选择。一个值得注意的选项是OFF_HEAP，它能够将RDD以序列化格式存储到Tachyon中。相比MEMORY_ONLY_SER，这一选项能够减少执行垃圾回收，使Spark的执行器（executor）更小，并能共享内存池。<a href="http://tachyon-project.org/">Tachyon</a>是一个基于内存的分布式文件系统，性能远超HDFS。Tachyon与Spark同源同宗，都烙有伯克利AMPLab的印记。目前，Tachyon的版本为0.5.0，还处于实验阶段。</p>

<p>注意，RDDs是Lazy的，在执行Transformation操作如map、filter时，并不会提交Job，只有在执行Action操作如count、first时，才会执行Job，此时才会进行数据的加载。当然，对于一些shuffle操作，例如reduceByKey，虽然仅是Transformation操作，但它在执行时会将一些中间数据进行持久化，而无需显式调用persist()函数。这是为了应对当节点出现故障时，能够避免针对大量数据进行重计算。要计算Spark加载的Dataset大小，可以通过Spark提供的Web UI Monitoring工具来帮助分析与判断。</p>

<p>Spark的RDD是具有分区（partition）的，Spark并非是将整个RDD一次性加载到内存中。Spark针对partition提供了eviction policy，这一Policy采用了LRU（Least Recently Used）机制。当一个新的RDD分区需要计算时，如果没有合适的空间存储，就会根据LRU策略，将最少访问的RDD分区弹出，除非这个新分区与最少访问的分区属于同一个RDD。这也在一定程度上缓和了对内存的消耗。</p>

<p>Spark对内存的消耗主要分为三部分：1. 数据集中对象的大小；2. 访问这些对象的内存消耗；3. 垃圾回收GC的消耗。一个通常的内存消耗计算方法是：内存消耗大小= 对象字段中原生数据 * (2~5)。 这是因为Spark运行在JVM之上，操作的Java对象都有定义的“object header”，而数据结构（如Map，LinkedList）对象自身也需要占用内存空间。此外，对于存储在数据结构中的基本类型，还需要装箱（Boxing）。Spark也提供了一些内存调优机制，例如执行对象的序列化，可以释放一部分内存空间。还可以通过为JVM设置flag来标记存放的字节数（选择4个字节而非8个字节）。在JDK 7下，还可以做更多优化，例如对字符编码的设置。这些配置都可以在spark-env.sh中设置。</p>

<h3>Spark对网络的要求</h3>

<p>Spark属于网络绑定型系统，因而建议使用10G及以上的网络带宽。</p>

<h3>Spark对CPU的要求</h3>

<p>Spark可以支持一台机器扩展至数十个CPU core，它实现的是线程之间最小共享。若内存足够大，则制约运算性能的就是网络带宽与CPU数。</p>

<p>Spark官方利用Amazon EC2的环境对Spark进行了基准测评。例如，在交互方式下进行数据挖掘（Interative Data Mining），租用Amazon EC2的100个实例，配置为8核、68GB的内存。对1TB的维基百科页面查阅日志（维基百科两年的数据）进行数据挖掘。在查询时，针对整个输入数据进行全扫描，只需要耗费5-7秒的时间。如下图所示：
<img class="center" src="http://agiledon.github.com/images/2014/sparkbenchmark.png"></p>

<p>在Matei Zaharia的Spark论文中还给出了一些使用Spark的真实案例。视频处理公司Conviva，使用Spark将数据子集加载到RDD中。报道说明，对于200GB压缩过的数据进行查询和聚合操作，并运行在两台Spark机器上，占用内存为96GB，执行完全部操作需要耗费30分钟左右的时间。同比情况下，Hadoop需要耗费20小时。注意：之所以200GB的压缩数据只占用96GB内存，是因为RDD的处理方式，使得我们可以只加载匹配客户过滤的行和列，而非所有压缩数据。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[基于Akka的REST框架Spray]]></title>
    <link href="http://agiledon.github.com/blog/2014/04/17/rest-framework-spray-based-on-akka/"/>
    <updated>2014-04-17T21:37:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/04/17/rest-framework-spray-based-on-akka</id>
    <content type="html"><![CDATA[<p>基于Akka的REST框架Spray，由于采用Akka提供的Actor模型，写出来的代码与通常的REST有很大的区别。从Spray-Can接收Http请求，到处理具体的HTTP动词以实现业务逻辑，都是通过传递消息的方式。这些消息再交由Akka Actor接收处理。消息皆定义为Scala提供的样例类（Case Class），从而保证消息为immutable。既然如此，当我们在运用Spray时，就需要转换思想，从传统的面向对象中解放出来，充分理解Event、Command，及其传递的Message。这近似于事件驱动（Event Driven），因而在对领域建模时，也需要将Event看做是领域模型的一等公民，并将领域逻辑建模为一种状态机。</p>

<p>我们可以首先根据Http请求，确定需要哪些消息。这样的Request消息几乎与Http动词以及Resource对应，例如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">sealed</span> <span class="k">trait</span> <span class="nc">RequestMessage</span>
</span><span class='line'>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">GetCustomer</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">RequestMessage</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">DeleteCustomer</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">RequestMessage</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">UpdateCustomer</span><span class="o">(</span><span class="n">customer</span><span class="k">:</span> <span class="kt">Customer</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">RequestMessage</span>
</span><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">CreateCustomer</span><span class="o">(</span><span class="n">dueDate</span><span class="k">:</span> <span class="kt">Date</span><span class="o">,</span> <span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">RequestMessage</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在可以定义一个Actor来响应客户端请求。该Actor要求派生自Akka Actor，同时还要实现Spray提供的HttpService trait。若要支持Json格式，还需实现Spray-Json提供的Json4sSupport。例如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">class</span> <span class="nc">CustomerServiceActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">HttpService</span> <span class="k">with</span> <span class="nc">CustomerRequestCreator</span> <span class="k">with</span> <span class="nc">Json4sSupport</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">implicit</span> <span class="k">def</span> <span class="n">actorRefFactory</span> <span class="k">=</span> <span class="n">context</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">val</span> <span class="n">json4sFormats</span> <span class="k">=</span> <span class="nc">DefaultFormats</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="n">runRoute</span><span class="o">(</span><span class="n">customerRoute</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">val</span> <span class="n">customerRoute</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">path</span><span class="o">(</span><span class="s">&quot;customers&quot;</span> <span class="o">/</span> <span class="nc">LongNumber</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">id</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=&gt;</span>
</span><span class='line'>        <span class="n">get</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">rejectEmptyResponse</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">handleRequest</span> <span class="o">{</span>
</span><span class='line'>              <span class="nc">GetCustomer</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span> <span class="o">~</span> <span class="n">put</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">entity</span><span class="o">(</span><span class="n">as</span><span class="o">[</span><span class="kt">Customer</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">customer</span> <span class="k">=&gt;</span>
</span><span class='line'>              <span class="n">handleRequest</span> <span class="o">{</span>
</span><span class='line'>                <span class="nc">UpdateCustomer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Customer</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">customer</span><span class="o">.</span><span class="n">birthDate</span><span class="o">,</span> <span class="n">customer</span><span class="o">.</span><span class="n">name</span><span class="o">))</span>
</span><span class='line'>              <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span> <span class="o">~</span> <span class="n">delete</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">handleRequest</span> <span class="o">{</span>
</span><span class='line'>            <span class="nc">DeleteCustomer</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span> <span class="o">~</span> <span class="n">path</span><span class="o">(</span><span class="s">&quot;customers&quot;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">get</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">handleRequest</span> <span class="o">{</span>
</span><span class='line'>          <span class="nc">AllCustomers</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span> <span class="o">~</span> <span class="n">post</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">entity</span><span class="o">(</span><span class="n">as</span><span class="o">[</span><span class="kt">Customer</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">customer</span> <span class="k">=&gt;</span>
</span><span class='line'>          <span class="n">handleRequest</span> <span class="o">{</span>
</span><span class='line'>            <span class="nc">CreateCustomer</span><span class="o">(</span><span class="n">customer</span><span class="o">.</span><span class="n">birthDate</span><span class="o">,</span> <span class="n">customer</span><span class="o">.</span><span class="n">name</span><span class="o">)</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">handleRequest</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">RequestMessage</span><span class="o">)</span><span class="k">:</span> <span class="kt">Route</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">ctx</span> <span class="k">=&gt;</span> <span class="n">customerRequest</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="nc">Props</span><span class="o">[</span><span class="kt">CustomerActor</span><span class="o">],</span> <span class="n">message</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>该Actor与其他Akka Actor的不同之处在于它的receive方法调用了Spray提供的runRoute()方法。传入的参数customerRoute是Spray提供的DSL格式的Route。Route中对应支持Http动词。其中，get先调用了Spray提供的rejectEmptyResponse来过滤掉空的响应消息；而post方法则调用entity将url中的消息转换为Customer消息：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">Customer</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">,</span> <span class="n">birthDate</span><span class="k">:</span> <span class="kt">Date</span><span class="o">,</span> <span class="n">name</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>在Route中，可以定义多个Path，不同的Path支持不同的Http动词。在接受到请求后，通过handleRequest()方法来处理请求。这里的实现是将RequestMessage消息再转交到了另一个Actor。我会在后面介绍。</p>

<!-- more -->


<p>不过，这里的CustomerServiceActor事实上是将支持Route的CustomerService与Actor合并在了一起，职责显得不够单一。因此，更好地做法是为CustomerService单独定义trait，并使其派生自HttpService，从而将实现代码从Actor中分开。分开的这个CustomerService，更类似于一个Controller。例如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">class</span> <span class="nc">CustomerServiceActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">CustomerService</span> <span class="k">with</span> <span class="nc">CustomerRequestCreator</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">implicit</span> <span class="k">def</span> <span class="n">actorRefFactory</span> <span class="k">=</span> <span class="n">context</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="n">runRoute</span><span class="o">(</span><span class="n">customerRoute</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">handleRequest</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">RequestMessage</span><span class="o">)</span><span class="k">:</span> <span class="kt">Route</span> <span class="o">=</span>
</span><span class='line'>    <span class="n">ctx</span> <span class="k">=&gt;</span> <span class="n">customerRequest</span><span class="o">(</span><span class="n">ctx</span><span class="o">,</span> <span class="nc">Props</span><span class="o">[</span><span class="kt">CustomerActor</span><span class="o">],</span> <span class="n">message</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">trait</span> <span class="nc">CustomerService</span> <span class="k">extends</span> <span class="nc">HttpService</span> <span class="k">with</span> <span class="nc">Json4sSupport</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">json4sFormats</span> <span class="k">=</span> <span class="nc">DefaultFormats</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">val</span> <span class="n">customerRoute</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">path</span><span class="o">(</span><span class="s">&quot;customers&quot;</span> <span class="o">/</span> <span class="nc">LongNumber</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">id</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=&gt;</span>
</span><span class='line'>        <span class="n">get</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">rejectEmptyResponse</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">handleRequest</span> <span class="o">{</span>
</span><span class='line'>              <span class="nc">GetCustomer</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span> <span class="o">~</span> <span class="n">put</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">entity</span><span class="o">(</span><span class="n">as</span><span class="o">[</span><span class="kt">Customer</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">customer</span> <span class="k">=&gt;</span>
</span><span class='line'>              <span class="n">handleRequest</span> <span class="o">{</span>
</span><span class='line'>                <span class="nc">UpdateCustomer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Customer</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">customer</span><span class="o">.</span><span class="n">birthDate</span><span class="o">,</span> <span class="n">customer</span><span class="o">.</span><span class="n">name</span><span class="o">))</span>
</span><span class='line'>              <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span> <span class="o">~</span> <span class="n">delete</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">handleRequest</span> <span class="o">{</span>
</span><span class='line'>            <span class="nc">DeleteCustomer</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span> <span class="o">~</span> <span class="n">path</span><span class="o">(</span><span class="s">&quot;customers&quot;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">get</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">handleRequest</span> <span class="o">{</span>
</span><span class='line'>          <span class="nc">AllCustomers</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span> <span class="o">~</span> <span class="n">post</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">entity</span><span class="o">(</span><span class="n">as</span><span class="o">[</span><span class="kt">Customer</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">customer</span> <span class="k">=&gt;</span>
</span><span class='line'>          <span class="n">handleRequest</span> <span class="o">{</span>
</span><span class='line'>            <span class="nc">CreateCustomer</span><span class="o">(</span><span class="n">customer</span><span class="o">.</span><span class="n">birthDate</span><span class="o">,</span> <span class="n">customer</span><span class="o">.</span><span class="n">name</span><span class="o">)</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">handleRequest</span><span class="o">(</span><span class="n">message</span><span class="k">:</span> <span class="kt">RequestMessage</span><span class="o">)</span><span class="k">:</span> <span class="kt">Route</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这样分离的好处还在于可以定义多个包含不同Route的Controller，然后在Actor中用~ combinator操作符将它们合并起来。例如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="n">handleTimeouts</span> <span class="n">orElse</span> <span class="n">runRoute</span><span class="o">(</span>
</span><span class='line'>  <span class="k">new</span> <span class="nc">CustomerService1</span><span class="o">.</span><span class="n">customerService1</span> <span class="o">~</span>  <span class="k">new</span> <span class="nc">CustomerService2</span><span class="o">.</span><span class="n">customerService2</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Spray使用了Akka IO来支持Request、Reponse流的输入输出。IO实质上也是一个Akka Actor。所以在程序的主入口，既需要创建提供了REST服务的Actor，又需要通过Akka IO发出绑定Http的消息。与Akka一样，我们可以定义一个类派生自App：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">object</span> <span class="nc">Boot</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">implicit</span> <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;spray-demo&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">service</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">CustomerServiceActor</span><span class="o">],</span> <span class="s">&quot;customer-service&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="nc">IO</span><span class="o">(</span><span class="nc">Http</span><span class="o">)</span> <span class="o">!</span> <span class="nc">Http</span><span class="o">.</span><span class="nc">Bind</span><span class="o">(</span><span class="n">service</span><span class="o">,</span> <span class="n">interface</span> <span class="k">=</span> <span class="s">&quot;localhost&quot;</span><span class="o">,</span> <span class="n">port</span> <span class="k">=</span> <span class="mi">8080</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>要启动ActorSystem，需要配置Akka，而要绑定Spray服务容器，也需要配置Spray-Can。一个简单的配置文件application.conf为：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>akka {
</span><span class='line'>  loglevel = INFO
</span><span class='line'>}
</span><span class='line'>
</span><span class='line'>spray.can.server {
</span><span class='line'>  request-timeout = 1s
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>现在再来看CustomerService中的handlRequest()方法的实现。该方法负责将对应的RequestMessage，例如GetCustomer、UpdateCustomer等转交给其下的Actor，即CustomerActor。它相当于是从RequestMessage到Domain Event的一个协调器（或控制器，也可以看做是Command）。同样，还是将Actor与具体的业务分离，因此定义了CustomerActor与CustomerOperation。</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">CustomerOperations</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">getById</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="nc">OneCustomer</span><span class="o">(</span><span class="k">new</span> <span class="nc">Customer</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">(</span><span class="mi">1000</span><span class="o">),</span> <span class="s">&quot;item1&quot;</span><span class="o">))</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">all</span><span class="o">()</span> <span class="k">=</span>  <span class="o">{</span>
</span><span class='line'>    <span class="k">try</span><span class="o">{</span>
</span><span class='line'>      <span class="nc">ListCustomers</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="k">new</span> <span class="nc">Customer</span><span class="o">(</span><span class="mi">100</span><span class="o">,</span> <span class="k">new</span> <span class="nc">Date</span><span class="o">(</span><span class="mi">1000</span><span class="o">),</span> <span class="s">&quot;item1&quot;</span><span class="o">)))</span>
</span><span class='line'>    <span class="o">}</span> <span class="k">catch</span><span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="n">e</span><span class="k">:</span><span class="kt">Exception</span> <span class="o">=&gt;</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">println</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">getMessage</span><span class="o">())</span>
</span><span class='line'>        <span class="nc">List</span><span class="o">()</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">delete</span><span class="o">(</span><span class="n">id</span><span class="k">:</span> <span class="kt">Long</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="nc">Success</span><span class="o">(</span><span class="s">&quot;deleted successfully&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">create</span> <span class="o">(</span><span class="n">dueDate</span><span class="k">:</span> <span class="kt">Date</span><span class="o">,</span> <span class="n">text</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>  <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nc">Created</span><span class="o">(</span><span class="s">&quot;&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">update</span> <span class="o">(</span><span class="n">customer</span><span class="k">:</span> <span class="kt">Customer</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">getById</span><span class="o">(</span><span class="n">customer</span><span class="o">.</span><span class="n">id</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">CustomerActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">CustomerOperations</span><span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">log</span> <span class="k">=</span> <span class="nc">Logging</span><span class="o">(</span><span class="n">context</span><span class="o">.</span><span class="n">system</span><span class="o">,</span> <span class="k">this</span><span class="o">)</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">GetCustomer</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sender</span> <span class="o">!</span> <span class="n">getById</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">UpdateCustomer</span><span class="o">(</span><span class="n">item</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sender</span> <span class="o">!</span> <span class="n">update</span><span class="o">(</span><span class="n">item</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">DeleteCustomer</span><span class="o">(</span><span class="n">id</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sender</span> <span class="o">!</span> <span class="n">delete</span><span class="o">(</span><span class="n">id</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">CreateCustomer</span><span class="o">(</span><span class="n">dueDate</span><span class="o">,</span> <span class="n">text</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">sender</span> <span class="o">!</span> <span class="n">create</span><span class="o">(</span><span class="n">dueDate</span><span class="o">,</span> <span class="n">text</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">AllCustomers</span> <span class="k">=&gt;</span> <span class="n">sender</span> <span class="o">!</span> <span class="n">all</span><span class="o">()</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>CustomerActor会作为CustomerRequest（同样是一个Actor）内部的Actor，即CustomerRequest中的target。CustomerActor实例是在CustomerRequest伴生对象中创建的：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">CustomerRequest</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">Json4sSupport</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">requestContext</span><span class="k">:</span> <span class="kt">RequestContext</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">target</span><span class="k">:</span> <span class="kt">ActorRef</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">message</span><span class="k">:</span> <span class="kt">RequestMessage</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">import</span> <span class="nn">context._</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">target</span> <span class="o">!</span> <span class="n">message</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Created</span><span class="o">(</span><span class="n">location</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">complete</span><span class="o">(</span><span class="n">spray</span><span class="o">.</span><span class="n">http</span><span class="o">.</span><span class="nc">StatusCodes</span><span class="o">.</span><span class="nc">Created</span><span class="o">,</span> <span class="n">location</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">OneCustomer</span><span class="o">(</span><span class="n">customer</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">complete</span><span class="o">(</span><span class="nc">OK</span><span class="o">,</span> <span class="n">customer</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">ListCustomers</span><span class="o">(</span><span class="n">customers</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">complete</span><span class="o">(</span><span class="nc">OK</span><span class="o">,</span> <span class="n">customers</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Success</span><span class="o">(</span><span class="n">message</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">complete</span><span class="o">(</span><span class="nc">OK</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">Error</span><span class="o">(</span><span class="n">message</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">complete</span><span class="o">(</span><span class="nc">BadRequest</span><span class="o">,</span> <span class="n">message</span><span class="o">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="nc">ReceiveTimeout</span> <span class="k">=&gt;</span> <span class="n">complete</span><span class="o">(</span><span class="nc">GatewayTimeout</span><span class="o">,</span> <span class="s">&quot;Request Timeout&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">complete</span><span class="o">[</span><span class="kt">T</span> <span class="k">&lt;:</span> <span class="kt">AnyRef</span><span class="o">](</span><span class="n">status</span><span class="k">:</span> <span class="kt">StatusCode</span><span class="o">,</span> <span class="n">obj</span><span class="k">:</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">requestContext</span><span class="o">.</span><span class="n">complete</span><span class="o">(</span><span class="n">status</span><span class="o">,</span> <span class="n">obj</span><span class="o">)</span>
</span><span class='line'>    <span class="n">stop</span><span class="o">(</span><span class="n">self</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">override</span> <span class="k">val</span> <span class="n">supervisorStrategy</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">OneForOneStrategy</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">case</span> <span class="n">e</span> <span class="k">=&gt;</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">complete</span><span class="o">(</span><span class="nc">InternalServerError</span><span class="o">,</span> <span class="nc">Error</span><span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="n">getMessage</span><span class="o">))</span>
</span><span class='line'>        <span class="nc">Stop</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">object</span> <span class="nc">CustomerRequest</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">case</span> <span class="k">class</span> <span class="nc">WithProps</span><span class="o">(</span><span class="n">requestContext</span><span class="k">:</span> <span class="kt">RequestContext</span><span class="o">,</span> <span class="n">props</span><span class="k">:</span> <span class="kt">Props</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">RequestMessage</span><span class="o">)</span> <span class="k">extends</span> <span class="nc">CustomerRequest</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">lazy</span> <span class="k">val</span> <span class="n">target</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="n">props</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">implicit</span> <span class="k">def</span> <span class="n">json4sFormats</span> <span class="k">=</span> <span class="nc">DefaultFormats</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于target在CustomerRequest中为lazy变量，所以只有在需要的时候才会创建CustomerActor。CustomerRequest定义了工厂：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">trait</span> <span class="nc">CustomerRequestCreator</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">this:</span> <span class="kt">Actor</span> <span class="o">=&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">customerRequest</span><span class="o">(</span><span class="n">requestContext</span><span class="k">:</span> <span class="kt">RequestContext</span><span class="o">,</span> <span class="n">props</span><span class="k">:</span> <span class="kt">Props</span><span class="o">,</span> <span class="n">message</span><span class="k">:</span> <span class="kt">RequestMessage</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>    <span class="n">context</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">(</span><span class="k">new</span> <span class="nc">WithProps</span><span class="o">(</span><span class="n">requestContext</span><span class="o">,</span> <span class="n">props</span><span class="o">,</span> <span class="n">message</span><span class="o">)))</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>而在CustomerRequest的定义中，会首先通过target发送message，这个message即CustomerService的Route中传递过来的RequestMessage。此时的target是CustomerActor，所以CustomerActor会接收到这些RequestMessage，然后调用CustomerOperation的相关操作，并由CustomerActor的sender发送消息。之后CustomerRequest会收到这些消息。</p>

<p>这种Actor的模型不同于传统的编程模型，但遵循的设计原则是一脉相承的，同样需要遵循单一职责原则。在编写Spray的代码时，需要事先分析清楚消息的传递路径，并分辨出承担这些消息传递与消息处理的Actor。同时，还应该尽量保证Actor与REST服务及操作分离，以保证REST服务与Actor的单一性。</p>

<p>示例代码在github上可以<a href="https://github.com/agiledon/SprayExample">下载</a>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spark概览]]></title>
    <link href="http://agiledon.github.com/blog/2014/04/05/spark-overview/"/>
    <updated>2014-04-05T09:39:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/04/05/spark-overview</id>
    <content type="html"><![CDATA[<p>Spark具有先进的DAG执行引擎，支持cyclic data flow和内存计算。因此，它的运行速度，在内存中是Hadoop MapReduce的100倍，在磁盘中是10倍。如下是对比图：
<img class="center" src="http://agiledon.github.com/images/2014/spark-logistic-regression.png"></p>

<p>这样的性能指标，真的让人心动啊！</p>

<p>Spark的API更为简单，提供了80个High Level的操作，可以很好地支持并行应用。它的API支持Scala、Java和Python，并且可以支持交互式的运行Scala与Python。来看看Spark统计Word字数的程序：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">file</span> <span class="k">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">textFile</span><span class="o">(</span><span class="s">&quot;hdfs://...&quot;</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="n">file</span><span class="o">.</span><span class="n">flatMap</span><span class="o">(</span><span class="n">line</span> <span class="k">=&gt;</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="o">(</span><span class="s">&quot; &quot;</span><span class="o">))</span>
</span><span class='line'>    <span class="o">.</span><span class="n">map</span><span class="o">(</span><span class="n">word</span> <span class="k">=&gt;</span> <span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="mi">1</span><span class="o">))</span>
</span><span class='line'>    <span class="o">.</span><span class="n">reduceByKey</span><span class="o">(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>看看Hadoop的Word Count例子，简直弱爆了，爆表的节奏啊：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WordCount</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">TokenizerMapper</span>
</span><span class='line'>       <span class="kd">extends</span> <span class="n">Mapper</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">&gt;{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">IntWritable</span> <span class="n">one</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IntWritable</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Text</span> <span class="n">word</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Text</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">map</span><span class="o">(</span><span class="n">Object</span> <span class="n">key</span><span class="o">,</span> <span class="n">Text</span> <span class="n">value</span><span class="o">,</span> <span class="n">Context</span> <span class="n">context</span>
</span><span class='line'>                    <span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">StringTokenizer</span> <span class="n">itr</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span><span class='line'>      <span class="k">while</span> <span class="o">(</span><span class="n">itr</span><span class="o">.</span><span class="na">hasMoreTokens</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">word</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">itr</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
</span><span class='line'>        <span class="n">context</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">one</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">IntSumReducer</span>
</span><span class='line'>       <span class="kd">extends</span> <span class="n">Reducer</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">,</span><span class="n">IntWritable</span><span class="o">,</span><span class="n">Text</span><span class="o">,</span><span class="n">IntWritable</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">IntWritable</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IntWritable</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">Text</span> <span class="n">key</span><span class="o">,</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">IntWritable</span><span class="o">&gt;</span> <span class="n">values</span><span class="o">,</span>
</span><span class='line'>                       <span class="n">Context</span> <span class="n">context</span>
</span><span class='line'>                       <span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>      <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="n">IntWritable</span> <span class="n">val</span> <span class="o">:</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="n">result</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
</span><span class='line'>      <span class="n">context</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">Configuration</span> <span class="n">conf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Configuration</span><span class="o">();</span>
</span><span class='line'>    <span class="n">String</span><span class="o">[]</span> <span class="n">otherArgs</span> <span class="o">=</span> <span class="k">new</span> <span class="n">GenericOptionsParser</span><span class="o">(</span><span class="n">conf</span><span class="o">,</span> <span class="n">args</span><span class="o">).</span><span class="na">getRemainingArgs</span><span class="o">();</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">otherArgs</span><span class="o">.</span><span class="na">length</span> <span class="o">!=</span> <span class="mi">2</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">err</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">&quot;Usage: wordcount &lt;in&gt; &lt;out&gt;&quot;</span><span class="o">);</span>
</span><span class='line'>      <span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="mi">2</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="n">Job</span> <span class="n">job</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Job</span><span class="o">(</span><span class="n">conf</span><span class="o">,</span> <span class="s">&quot;word count&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="n">job</span><span class="o">.</span><span class="na">setJarByClass</span><span class="o">(</span><span class="n">WordCount</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>    <span class="n">job</span><span class="o">.</span><span class="na">setMapperClass</span><span class="o">(</span><span class="n">TokenizerMapper</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>    <span class="n">job</span><span class="o">.</span><span class="na">setCombinerClass</span><span class="o">(</span><span class="n">IntSumReducer</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>    <span class="n">job</span><span class="o">.</span><span class="na">setReducerClass</span><span class="o">(</span><span class="n">IntSumReducer</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>    <span class="n">job</span><span class="o">.</span><span class="na">setOutputKeyClass</span><span class="o">(</span><span class="n">Text</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>    <span class="n">job</span><span class="o">.</span><span class="na">setOutputValueClass</span><span class="o">(</span><span class="n">IntWritable</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>    <span class="n">FileInputFormat</span><span class="o">.</span><span class="na">addInputPath</span><span class="o">(</span><span class="n">job</span><span class="o">,</span> <span class="k">new</span> <span class="n">Path</span><span class="o">(</span><span class="n">otherArgs</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>
</span><span class='line'>    <span class="n">FileOutputFormat</span><span class="o">.</span><span class="na">setOutputPath</span><span class="o">(</span><span class="n">job</span><span class="o">,</span> <span class="k">new</span> <span class="n">Path</span><span class="o">(</span><span class="n">otherArgs</span><span class="o">[</span><span class="mi">1</span><span class="o">]));</span>
</span><span class='line'>    <span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="n">job</span><span class="o">.</span><span class="na">waitForCompletion</span><span class="o">(</span><span class="kc">true</span><span class="o">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>当然，Hadoop有自己的一套框架，为整个的大数据处理做支持，例如HIVE，例如HDFS。Spark也不逊色，也有自己的SQL框架支持，即Shark，此外还支持流处理、机器学习以及图运算：
<img class="center" src="http://agiledon.github.com/images/2014/spark-stack.png"></p>

<p>Spark并没有自己的分布式存储方案。不过已经有了强悍的HDFS，同为Aparch旗下的Spark又何必再造一个差不多的轮子呢？所以Spark可以很好地与Hadoop集成。例如可以运行在Hadoop 2的YARN集群下，可以读取现有的Hadoop数据。当然，Spark自身也支持standadlone的部署，或者部署到EC2等云平台下。除了可以读取HDFS数据，它还可以读取HBase，Cassandra等NoSQL数据库。这扩大了Spark的适用范围。</p>

<p>目前的Spark官方发布还仅仅是0.9的孵化版本，这为它的商用造成一点点阻碍。针对一个新的大数据项目而言，是选用Spark，还是Hadoop，还真的难以抉择。当然，对于我们这种玩技术的，从来都是喜新厌旧，心里自然是偏向Spark了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阅读的力量]]></title>
    <link href="http://agiledon.github.com/blog/2014/03/04/the-strength-of-reading/"/>
    <updated>2014-03-04T20:47:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/03/04/the-strength-of-reading</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2014/steiner.jpg"></p>

<p>阅读，以灵魂融合的方式阅读，或许会战栗，恐惧，喜悦，哭泣，甚至紧张，却可以让你成为阅读的人存在，你既是独立的，又陷入作品中成为你臆想和理解的另一个人。这种阅读，使得你存在。</p>

<p>乔治.斯坦纳(George Steiner）在《语言与沉默(Language And Silence)》的第一篇《人文素养》中如是评价阅读：</p>

<blockquote><p>那么，请尽可能地与文学同道。一个人读了《伊利亚特》第十四卷（普里阿摩斯夜会阿基琉斯），读了阿廖沙.卡拉玛佐夫跪向星空那一幕，读了《蒙田随笔》的第二十章，读了哈姆雷特对这章的引用，如果他的人生没有改变，他对自己生命的领悟没有改变，他没有用一点点彻底不同的方式大量他行走其中的屋子，打量那些敲门的人，那么，他虽然是用肉眼在阅读，但他的心眼却是盲视。读了《安娜.卡列尼娜》或普鲁斯特的人，在心灵的深处，能不体验到新的虚弱或需求？</p>

<p>……读了卡夫卡的《变形记》，却依然能够无畏地面对镜中的自己，这样的读者，也许从字面上说，能够识文断字，但在最根本的意义上，不过是白丁而已。</p></blockquote>

<p>阅读确乎常常能打动我，当然，这也要取决于我面对的是何种作品。我的心灵并不坚强，甚而耽于安逸，每当阅读到那种让灵魂战栗或者恐慌的时候，我或许会想着逃离。我阅读卡夫卡《变形记》的感受如此，我几乎要被那种昏暗、恐慌、无助给击倒了，甚至有一种被人扼住喉咙要窒息的感觉。我在代入。我在想象当我在次日清晨突然发现自己变成一种爬虫，会是怎么样？又或者发现自己的爱人变成了丑陋的爬虫，蠕动着可以看到爬动的粘液，我会如何反应？答案是毫无疑问的步入心灵的昏暗层面，我既不能无动于衷，也不能泰然自若。在那一刻，是人生崩溃的感觉。</p>

<p>通常而言，好的小说会让人不忍卒读，而我在阅读《变形记》时，我有一种甩开书本的冲动。我害怕去看结果，甚至害怕想象这种场景；然而，这场景却像有了生命，拥有着执念一般地硬要挤入我的脑袋中来。坦白说，我害怕看到自己隐藏的丑恶，害怕撕开肌肤，入眼一片血淋淋！</p>

<p>我在阅读《蒙田随笔》时，就成为第三者旁观了。那些睿智充满哲思的话语，几乎无法打动我，我就像看着一个智慧老者无语的絮叨，我做出尊敬而认真倾听的样子，心里却在感叹：他，已经不是这个时代了。</p>

<p>大多数时候，当我阅读完一部伟大的作品，尤其是小说，会有一种空虚感。好像自己曾经步入过小说中虚构的世界。那个世界产生的重力如此之大，压着我直不起身；直到走出，突然感觉自己已经适应了那种重量，脚步反而变得虚浮起来。重要的是我的内心会产生寂寞感。当我阅读完《不能承受的生命之轻》、《不朽》时，如是；阅读完《树上的男爵》，也如是。</p>

<p>还有一种感觉就是解脱。小说描述主人公的种种形状，一定是被某种不可知的力量所牵引，规约。这种力量或许可以称之为命运，也可能是自己的性格，又或者是当时那个大时代的集体力量。巧合的是，这种作品多数是以第一人称描述。例如在读完《麦田的守望者》，《洛丽塔》，我几乎要长吁一口气，产生一种如释重负的轻松。</p>

<p>这样的阅读中的我，是否斯坦纳笔下的“白丁”呢？</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Akka中的Remote Actor]]></title>
    <link href="http://agiledon.github.com/blog/2014/02/18/remote-actor-in-akka/"/>
    <updated>2014-02-18T19:27:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/02/18/remote-actor-in-akka</id>
    <content type="html"><![CDATA[<p>Akka的设计目标就是为分布式准备的，因此<strong>所有Actor之间的交互都是通过消息，且所有动作都是异步的</strong>。这种做法就是为了确保Akka的所有功能无论是在单独的JVM，还是包含了成百上千机器的Cluster，都是可用的。</p>

<p>然而，本地与分布式总是存在区别，主要牵涉到两点：</p>

<ul>
<li><p>消息需要支持序列号；</p></li>
<li><p>消息传递的可靠性问题；</p></li>
</ul>


<p>为了保证本地处理与分布式处理的透明化，Akka几乎没有特别为Remoting Layer提供专门的API，区别仅在于配置。开发者只需遵循Actor设计的原则，然后在配置中指定Actor子树的远程配置即可。当然，在代码层面，Akka也提供了唯一与众不同的API，就是在包含部署信息的Props中，可以允许设置Deploy实例。不过，这件事情是可以配置的。倘若两者都设置了，配置文件优先。</p>

<p>若要支持Scale up，Akka提供了多个Actor子树以支持并行处理。然后以多种方式进行路由。开发者唯一要做的事情是声明一个确定的Actor作为“withRouter”，事实上就是创建一个路由Actor，它能够生成所需类型Children的数量值，该数量值是可以配置的。</p>

<h2>Remote Actor</h2>

<p>要调用Akka的Remote Actor，则需要对Remote Actor进行部署。首先，我们可以通过Akka的<a href="http://akka.io/downloads/">官方网站</a>下载Akka的库。我这里下载的是2.2.3版本。下载后解压。与部署有关的目录包括bin和deploy。在bin目录下是运行Akka的脚本。而在deploy目录下，除了Readme文件外，此时为空。</p>

<p>现在，我们可以编写一个Remote Actor。Akka要求我们定义一个Actor，以及它对应的Application。Remote Actor与普通的Actor定义没有什么区别，例如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">package</span> <span class="nn">com.agiledon.akka</span>
</span><span class='line'>
</span><span class='line'><span class="k">import</span> <span class="nn">akka.actor.Actor</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">RemoteActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span>
</span><span class='line'>      <span class="n">sender</span> <span class="o">!</span> <span class="n">message</span> <span class="o">+</span> <span class="s">&quot;got something&quot;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>但对于Application而言，则要求派生自akka kernel下的Bootable。akka kernel是单独的一个包，并没有包含在akka-actor中。因此需要定义依赖，例如使用sbt：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">scalaVersion</span> <span class="o">:=</span> <span class="s">&quot;2.10.2&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%</span> <span class="s">&quot;akka-actor_2.10&quot;</span> <span class="o">%</span> <span class="s">&quot;2.2.3&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%</span> <span class="s">&quot;akka-kernel_2.10&quot;</span> <span class="o">%</span> <span class="s">&quot;2.2.3&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>定义的Application如下所示：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">package</span> <span class="nn">com.agiledon.akka</span>
</span><span class='line'>
</span><span class='line'><span class="k">import</span> <span class="nn">akka.kernel.Bootable</span>
</span><span class='line'><span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span><span class="nc">Props</span><span class="o">,</span> <span class="nc">ActorSystem</span><span class="o">}</span>
</span><span class='line'><span class="k">import</span> <span class="nn">com.typesafe.config.ConfigFactory</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">RemoteNodeApplication</span> <span class="k">extends</span> <span class="nc">Bootable</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;RemoteNodeApp&quot;</span><span class="o">,</span> <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">load</span><span class="o">().</span><span class="n">getConfig</span><span class="o">(</span><span class="s">&quot;RemoteSys&quot;</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">startup</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">RemoteActor</span><span class="o">],</span> <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;remoteActor&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">shutdown</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">system</span><span class="o">.</span><span class="n">shutdown</span><span class="o">()</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们需要实现startup与shutdown方法。而在Application中，会加载配置文件application.conf的配置信息创建ActorSystem。配置如下：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>RemoteSys {
</span><span class='line'>    akka {
</span><span class='line'>        actor {
</span><span class='line'>            provider = "akka.remote.RemoteActorRefProvider"
</span><span class='line'>        }
</span><span class='line'>        remote {
</span><span class='line'>            enabled-transports = ["akka.remote.netty.tcp"]
</span><span class='line'>            netty.tcp {
</span><span class='line'>                hostname = "192.168.3.34"
</span><span class='line'>                port = 2552
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>    }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>端口号2552也是Akka的默认端口号。</p>

<h2>部署Remote Actor</h2>

<p>application.conf文件应该放到resources目录下。编译打包。然后将编译得到的jar包拷贝到akka的deploy目录下。然后转移到bin目录下，执行akka脚本（windows下是执行akka.bat)：
./akka com.agiledon.akka.RemoteNodeApplication</p>

<p>akka命令后面是application类的full name。如果一切正常，就可以显示如下界面：
<img class="center" src="http://agiledon.github.com/images/2014/akka/akka_console.png"></p>

<h2>Client(Local) Actor</h2>

<p>要调用部署了的Remote Actor，客户端的Actor可以通过将Remote Actor的address传递给actorSelection()方法（之前的版本为actorFor，目前已经被Deprecated），以此来获得Remote Actor的Ref。如下所示：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">package</span> <span class="nn">com.agiledon.akka</span>
</span><span class='line'>
</span><span class='line'><span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span><span class="nc">ActorLogging</span><span class="o">,</span> <span class="nc">Actor</span><span class="o">}</span>
</span><span class='line'><span class="k">import</span> <span class="nn">akka.util.Timeout</span>
</span><span class='line'><span class="k">import</span> <span class="nn">akka.pattern.ask</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scala.concurrent.Await</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">LocalActor</span> <span class="k">extends</span> <span class="nc">Actor</span> <span class="k">with</span> <span class="nc">ActorLogging</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">remoteActor</span> <span class="k">=</span> <span class="n">context</span><span class="o">.</span><span class="n">actorSelection</span><span class="o">(</span><span class="s">&quot;akka.tcp://RemoteNodeApp@192.168.3.34:2552/user/remoteActor&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="k">implicit</span> <span class="k">val</span> <span class="n">timeout</span> <span class="k">=</span> <span class="nc">Timeout</span><span class="o">(</span><span class="mi">5</span> <span class="n">seconds</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="n">receive</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">message</span><span class="k">:</span> <span class="kt">String</span> <span class="o">=&gt;</span>
</span><span class='line'>      <span class="k">val</span> <span class="n">future</span> <span class="k">=</span> <span class="o">(</span><span class="n">remoteActor</span> <span class="o">?</span> <span class="n">message</span><span class="o">).</span><span class="n">mapTo</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span>
</span><span class='line'>      <span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="nc">Await</span><span class="o">.</span><span class="n">result</span><span class="o">(</span><span class="n">future</span><span class="o">,</span> <span class="n">timeout</span><span class="o">.</span><span class="n">duration</span><span class="o">)</span>
</span><span class='line'>      <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="o">(</span><span class="s">&quot;Message received from server -&gt; {}&quot;</span><span class="o">,</span> <span class="n">result</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>同样需要定义配置文件，但无需指定hostname与port了：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>LocalSys {
</span><span class='line'>  akka {
</span><span class='line'>      actor {
</span><span class='line'>          provider = "akka.remote.RemoteActorRefProvider"
</span><span class='line'>      }
</span><span class='line'>  }
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p>编写Application，使其可以被运行以调用Remote Actor：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">package</span> <span class="nn">com.agiledon.akka</span>
</span><span class='line'>
</span><span class='line'><span class="k">import</span> <span class="nn">akka.actor.</span><span class="o">{</span><span class="nc">Props</span><span class="o">,</span> <span class="nc">ActorSystem</span><span class="o">}</span>
</span><span class='line'><span class="k">import</span> <span class="nn">com.typesafe.config.ConfigFactory</span>
</span><span class='line'>
</span><span class='line'><span class="k">object</span> <span class="nc">LocalNodeApplication</span> <span class="k">extends</span> <span class="nc">App</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">system</span> <span class="k">=</span> <span class="nc">ActorSystem</span><span class="o">(</span><span class="s">&quot;LocalNodeApp&quot;</span><span class="o">,</span> <span class="nc">ConfigFactory</span><span class="o">.</span><span class="n">load</span><span class="o">().</span><span class="n">getConfig</span><span class="o">(</span><span class="s">&quot;LocalSys&quot;</span><span class="o">))</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">val</span> <span class="n">localActor</span> <span class="k">=</span> <span class="n">system</span><span class="o">.</span><span class="n">actorOf</span><span class="o">(</span><span class="nc">Props</span><span class="o">[</span><span class="kt">LocalActor</span><span class="o">],</span> <span class="n">name</span> <span class="k">=</span> <span class="s">&quot;localActor&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="n">localActor</span> <span class="o">!</span> <span class="s">&quot;hello demo actor&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="nc">Thread</span><span class="o">.</span><span class="n">sleep</span><span class="o">(</span><span class="mi">4000</span><span class="o">)</span>
</span><span class='line'>  <span class="n">system</span><span class="o">.</span><span class="n">shutdown</span><span class="o">()</span>
</span><span class='line'>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在客户端模块的根目录下创建build.sbt文件：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'>
</span><span class='line'><span class="n">name</span> <span class="o">:=</span> <span class="s">&quot;actor-local&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">version</span> <span class="o">:=</span> <span class="s">&quot;1.0&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">scalaVersion</span> <span class="o">:=</span> <span class="s">&quot;2.10.2&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%</span> <span class="s">&quot;akka-actor_2.10&quot;</span> <span class="o">%</span> <span class="s">&quot;2.2.3&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;com.typesafe.akka&quot;</span> <span class="o">%</span> <span class="s">&quot;akka-remote_2.10&quot;</span> <span class="o">%</span> <span class="s">&quot;2.2.3&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>转移到客户端模块的根目录下，执行sbt命令，进入SBT。执行compile命令编译客户端模块actor-local。然后执行run命令，若运行成功，即可看到如下信息：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>[info] Running com.agiledon.akka.LocalNodeApplication
</span><span class='line'>[INFO] [02/18/2014 19:11:47.461] [run-main] [Remoting] Starting remoting
</span><span class='line'>[INFO] [02/18/2014 19:11:47.725] [run-main] [Remoting] Remoting started; listening on addresses :[akka.tcp://LocalNodeApp@192.168.3.38:2552]
</span><span class='line'>[INFO] [02/18/2014 19:11:48.066] [LocalNodeApp-akka.actor.default-dispatcher-3] [akka://LocalNodeApp/user/localActor] Message received from server -> hello demo actor got something</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
</feed>
