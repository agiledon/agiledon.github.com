<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[简单文本]]></title>
  <link href="http://agiledon.github.com/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2014-01-12T10:13:50+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[摘录《树上的男爵》]]></title>
    <link href="http://agiledon.github.com/blog/2014/01/11/excerpt-from-barone-rampante/"/>
    <updated>2014-01-11T19:32:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/01/11/excerpt-from-barone-rampante</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2014/barone_rampante.jpeg"></p>

<p>卡尔维诺《树上的男爵》书写了这么一段难以言说、无可名状的美丽的段落，让我惊叹，甚至是那种心悸的喜悦。这样的笔下的景色，仿佛让我身临其境，又似乎另有一种魔力，如夕阳之下各色景观都涂上了一层金色的光亮。这一段落并非那种精致的美，但却自有一种纤细与磅礴，很奇怪的矛盾杂糅，然后蹦出一种奇异的美。</p>

<blockquote><p>他的天地已经变了，这是一个由架在空中的细长而弯曲的桥，由粗糙树皮上的结节、瘤子和皱褶，由透过或疏或密的树叶挡起的帷幕而变幻着深浅的绿色阳光组成的世界，微风一吹，树叶的柄就抖动不已，而当树干摇摆时整棵树的叶子就像一方纱巾飘动起来。而我们的世界呢，是平贴在地面上的，我们看到的是比例失调的形象，我们当然不理解他在那上面的感受。夜里他倾听着树木如何用它的细胞在树干里记下代表岁月的年轮，树霉如何在北风中扩大斑点，在窝里熟睡的小鸟瑟缩着将脑袋钻进最暖和的翅膀下的羽毛里，毛毛虫蠕动，伯劳鸟腹中的蛋孕育成功。有的时候，原野静悄悄，耳膛内只有细微的响动，一声粗号，一声尖叫，一阵野草迅疾瑟瑟声，一阵流水淙淙响，一阵踏在泥土和石子上的蹄声，而蝉鸣声高出一切之上。响声一个接一个消失，听觉不断辨别出新的声音，就像那拆着一团毛线的手指，感觉到每根毛线变得越来越细，细得几乎感触不到了。同时青蛙一直在鸣唱，作为一种背景并不影响其它声音的传播，如同太阳光不因星星的不断闪烁而起变化。相反，每当风吹起或吹过，每一种声音都会起变化并成为新的声音，留在耳膛内最深处的只有隐隐约约的呼啸声或低吟声，那是大海。</p></blockquote>

<p>要多么细致的观察，多么敏感的心灵，与大自然的脉搏一起跳动，放开身体的所有触觉、嗅觉与视觉，才能从灵魂中涌现出这样的文字，最后再借助一只魔笔润色，天然地凸显出来，就好像它自天地诞生以来一直就存在，只是从未有人发现，偶然的，被在天地之间嬉戏的卡尔维诺发现了。是的，是被发现了，而不是创作出来了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[读《被禁锢的头脑》]]></title>
    <link href="http://agiledon.github.com/blog/2014/01/10/reading-the-captive-mind/"/>
    <updated>2014-01-10T22:24:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/01/10/reading-the-captive-mind</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2014/captivemind.jpg">
米沃什在《被禁锢的头脑》中，描述了战时东欧的白色恐怖：</p>

<blockquote><p>此时带着套马索的骑马者就会出现。那就是‘囚车’，即停在街角，用帆布遮盖着的大卡车。行人根本预见不到那里会有危险，当他们路过那个街角时，会突然感觉有一支枪顶住他。它也许会被关进集中营，或者会被推到墙下，用胶布封上嘴巴以防止他喊出反对占领国的口号，然后就被枪毙。这一切都令城市居民心惊胆战，迫使他们俯首帖耳。为了避免这种不幸，最好的办法就是足不出户。但是作为一家之主的父亲必须外出挣钱，弄点供养他的妻儿老小的面包和菜汤。每到晚上，家里人就开始心绪不宁，担心父亲是否还回得来。这种情况已经持续多年，所以人们渐渐觉得他们居住的这座城市简直就是危机四伏的原始森林，20世纪人的命运，与那些每天跟毒蛇猛兽作生死搏斗的穴居人的命运没什么两样。</p></blockquote>

<p>没有经历过这种生活的人阅读这样的文字，仍然可以体会那种惶惶的恐怖，这种恐慌如慢性毒药一般啃啮人的心灵。与其这般在极大恐惧中担惊受怕，过着如丧家犬的生活，不知什么时候会抛尸街头或者入牢笼中受非人的折磨，真还不如扛起枪冲出战壕面对冷酷而喧嚣的枪林弹火呢。</p>

<!--more-->


<p>第三章《凯特曼——伪装》描述的情景，不正是文革中诸多知识分子奉行的——美学凯特曼。同样的政治高压与知识钳制发生在同样的社会主义国家，这岂是偶然？思想正确的真理“唯一”论，已经说明了这种真理的不可信。正如奥威尔在《一九八四》借温斯顿之口说出的“所谓自由就是可以说二加二等于四的自由。承认这一点，其他一切就迎刃而解。”在真理唯一性的指导下，我们没有自由反驳老大哥的言论了，即使最蠢的傻瓜都知道这种言论的谬误。</p>

<p>这样的社会主义，何异于“指鹿为马”的赵高宣泄权利的恶时代呢？阅读《被禁锢的头脑》，感觉就是《一九八四》的现实版。</p>

<p>在第八章的219页，米沃什写道：“他们的研究对象是不同群体的居民。有产者阶级最不重要，他们由于工厂、矿山收归国有和农业改革而被剥夺了财产，不是供研究的主要对象。”</p>

<p>“小资产阶级——小商人和手工业工作者不应受到忽略，他们是深深扎根于民众的一股强大力量。”</p>

<p>然后书中以调侃方式提到什么叫“资本主义萌芽”，什么叫”资本主义复辟“，什么又叫”投机倒把者“，真是入木三分啊！</p>

<p>书中描绘对农民的斗争策略，可谓摸准了人性，各种隐藏的恶与自私在显微镜下纤毫毕现，他们就好像发现了病毒，却并不思考如何寻找疫苗，反而将这种病毒扩大，扩散，以期求得对他们更为广泛的利益。——“于是把农民分为‘贫农’、‘中农’、‘富农’，因为，只有利用他们之间彼此的敌对心理，打破农村的团结，才能达到目的。”——真正是四两拨千斤的高妙手段。</p>

<p>对付工人的手段仍然利用了人性，与对付农民的手段如出一辙：“总的来说，提出‘工人团结’的口号并不意味着可以放纵某一工厂工人的团结，因为这种团结会因选拔劳动‘突击手’而被瓦解——劳动‘突击手’就是超额完成任务者，这就会让其他工人感到有压力或力不从心。有两种手段可以影响工人们的思想：一方面激起他们的雄心壮志，一方面要求他们承受党组织所施加的压力。”</p>

<p>米沃什的结论是：一切都导致对人的头脑的统治。于是党的宣传手段如宗教信仰一般，以某种集体仪式，达成一种心理催眠的信仰氛围，即使心有不信者，也会被慢慢潜移默化了。于是——</p>

<blockquote><p>这个集合体是由个体组成的，有些人虽对这一切心怀疑虑，还是说了预先规定该说的话，唱了预先规定该唱的歌；这种行为就打造出了一种群体氛围，最后自己也被这种氛围所感染。俱乐部的影响尽管带有理性的表征，但也属于群体魔术现象之列。</p></blockquote>

<p>米沃什提到了“知识庸俗化”带来的影响，可谓猛于虎矣。</p>

<blockquote><p>例如，简单化和庸俗化的达尔文物种起源和物竞天择理论，都已不同于达尔文以及与他争论的学者们的理论。它已被改造成社会学理论的重要部分，带有某种感情色彩了。20世纪的领袖们，例如希特勒，其知识仅仅源于科普小册子，这就可以解释他们头脑中不可思议的知识混乱。<strong>庸俗化知识的特点是：它让人感觉一切都是明明白白的，一切都是可以解释清楚的；</strong>它也令人想起在深渊之上架设吊桥的方法，沿着吊桥可以大胆地往前走，同时自欺欺人地认为：脚下没有万丈深渊，同时要记住，眼睛千万不能往深渊看——但遗憾的是，这一切都不能改变现实中存在万丈深渊的事实。</p>

<p>由苏联窜改的辩证唯物主义，不是别的，正是知识的双倍庸俗化。……辩证法的出发点是科学的——运用人文科学方面，主要在于根据一时的需要，将人文科学任意改造为它想建立的学说。——人类历史的数世纪，充满了成千上万的复杂事件，结果只用几个术语就高度概括了。<strong>毫无疑问，将过去和当代的历史作为阶级斗争的表现来进行分析，比将历史展示为那些王公贵族和国王彼此之间的私下争斗胡闹更接近真理。正是因为这种分析更接近真理，它也就更加危险：这种分析给人一种完满知识的错误，似乎能对每个问题作出回答，然而这种回答实际上只是在转着圈儿地重复几种套话，什么也解释不了，同时还让人得到表面的满足。</strong>对此还得附加一点，即借助唯物主义（例如”物质不灭“的理论）将自然科学与人文科学结合起来，而我们就会看到，当斯大林出现在我们这个星球自有生命以来的历史顶点之时，整个圆就奇妙而又合逻辑地画成了。</p></blockquote>

<p>如下这一段达到了反讽的巅峰，却又如此合情合理：</p>

<blockquote><p>有一种昆虫，会将自己的毒刺戳进其他科属的毛毛虫体内，并注入毒素，那些体内被注入了毒素的毛毛虫虽然还活着却已经瘫痪不能动了。这些昆虫——投毒者，就在那些毛毛虫体内产卵，于是毛毛虫的身体就变成了这些昆虫幼虫的食物储藏室。同样的，在人民民主国家，人们的头脑里也被注入了麻醉剂——那就是辩证唯物主义，虽说马克思和恩格斯从未设想过他们的学说会被如此利用。当人们的大脑被麻醉了以后，斯大林主义的解释就在他们的大脑中产卵：“既然你已经是个马克思主义者，”他们对这位患者说，“那你就必须是斯大林主义者；因为没有斯大林主义，就没有马克思主义。</p></blockquote>

<p>哈，没有斯大林主义，就没有马克思主义。这是辩证唯物主义存在的意义。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[可视化架构与DDD]]></title>
    <link href="http://agiledon.github.com/blog/2014/01/09/visualization-architecture-and-ddd/"/>
    <updated>2014-01-09T13:57:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2014/01/09/visualization-architecture-and-ddd</id>
    <content type="html"><![CDATA[<p>从DDD的角度，领域逻辑的分析可以运用战略方法Bounded Context。可是，一个问题是：<strong>如何获得Bounded Context ？</strong></p>

<p>我查看了许多关于Bounded Context的书籍与文章，虽然都着重强调了它的重要性，也给出了一些实例，却对如何从需求——>Boundex Context这一点上语焉不详。</p>

<p>我的初步设想是通过绘制场景图（但并不成熟）。我认为有三种绘制场景图的方式：商业画布，体验地图和流程图。我认为，商业画布可以作为需求分析（尤其针对初创产品）的起点。商业画布如下图所示：
<img class="center" src="http://agiledon.github.com/images/2014/business_canvas.jpeg"></p>

<p>采用这种规范化的方式来推导商业模型，可以激发我们的灵感，理清我们的思路，以便我们思考为何要做这个产品，产品应该具备哪些功能。结合优点和缺点、成本等因素，我们可以藉此判断和决策功能的优先级，从而得到MVP。这个过程需要大量运用即时贴，让整个商业模型呈现。经过取舍后，就可以针对产品绘制场景图。此时，场景图可以采用Experience Map或流程图来体现。Experience Map的例子如下图所示：
<img class="center" src="http://agiledon.github.com/images/2014/experience_map.gif"></p>

<p>由于商业画布本身提供了“客户”项，我们应该创建Persona，找准人物角色的特征来“搜寻”需求。绘制了场景图后，就能够确定用例了，此时，可辅以ATDD帮助确定Story。在确定了用例后，可以识别Bounded Context，并通过Context Map确定上下文之间的关系。</p>

<!--more-->


<p>就我个人感觉，体验地图还是从Persona的角度设想系统如何使用，考虑它的用户体验。它其实符合“场景”的概念。这里可能还是要考虑：在一个完整的场景中，需要哪些参与者？但是，即使从粗粒度的角度出发，场景都可能存在多个，可能需要绘制多个场景图来逐步提炼Bounded Context。</p>

<p>关于如何运用Persona，我的同事熊子川在他的博客《<a href="http://www.tuzei8.com/2011/06/xd%E5%85%B3%E9%94%AE%E5%AD%975-persona/">XD关键字5：Persona</a>》中已有详细介绍，同样在他的博客《<a href="http://www.tuzei8.com/2012/06/agile-ux-content-strategy/">Agile UX内容策略工作坊</a>》中提出的“消费者建模”实践，指出：</p>

<blockquote><p>为了更好的理解我们选择的目标消费者，我们需要对消费者进行完整的建模，即Persona。越接近于真实的Persona帮助我们更好的理解其用户目标……Persona的重要产出物是一系列用户目标，对于同一个Persona，用户目标可能有不同，有些目标是基础核心目标，有些则是衍生性的，例如一个访问网站潜在投资者的核心目标可能是了解成为投资者的过程，而衍生性目标可能是获得一些关于公司历史信息增加信任度。</p></blockquote>

<p><img class="center" src="http://agiledon.github.com/images/2014/persona.jpg">
<strong>说明</strong>：本图摘自熊子川博客</p>

<p>假设我们要开发一个电子商务网站，我们就可以通过商业画布来驱动出这个产品应该具有哪些功能，它的客户有哪些等，在绘制了场景图后，可以初步得到这样的Bounded Context:
<img class="center" src="http://agiledon.github.com/images/2014/bounded_context.jpg"></p>

<p>然后，我利用Context Map得到了各个上下文之间的关系：
<img class="center" src="http://agiledon.github.com/images/2014/context_map.jpg"></p>

<p>这样，一个包图的获得就水到渠成了：
<img class="center" src="http://agiledon.github.com/images/2014/modules.jpeg"></p>

<p>在识别了Bounded Context以及Context之间的关系后，我们可以运用Hexagon架构（Cockburn提出的六边形架构）来展现系统的整体架构。Hexagon架构并不深入关注内部边界中领域部分，仅仅是简单的划分为Application与Domain两层。但它有助于我们获得基础设施层以及相关集成点的包结构。我们要合理地运用六边形架构。它更贴近应用逻辑架构，并可以驱动我们去发现诸多集成点，寻找集成模式。内外边界的分离也有助于我们将业务逻辑与应用逻辑分离开。这实际上符合“关注点分离”的架构原则。下图展现了六边形架构中常见的Port与Adapter：
<img class="center" src="http://agiledon.github.com/images/2014/Hexagon.jpg"></p>

<p>我对“可视化架构”的理解，还是要希望多通过即时贴、白板等工具来实现可视化，而非通过绘图。至少，绘图不应该成为主要的驱动力，否则，开发人员很难接受。例如，下图就是我运用Hexagon架构，并结合可视化手段分析该电子商务系统得到的应用逻辑架构，它很好地一个展现了Hexagon架构的可视化手法。
<img class="center" src="http://agiledon.github.com/images/2014/e_commerce.jpg"></p>

<p>在这个图中，直观地展现了如何与外部的支付系统以及物流系统的集成。例如，图中展现的Port实际上为防腐层（ACL）。为何要建立这样的一个防腐层呢，原因在于：支付与物流常常存在多个供应商，因而需要解除对供应商的绑定，并避免供应商系统的变化造成对电子商务系统的腐蚀。这是切合实际的决策。</p>

<p>这个电子商务系统需要与仓库管理系统集成。恰好在《面向模式的软件架构》卷四的第35页，给出了一个仓库管理流程控制系统的案例。书中描述的非功能性需求，即所谓质量属性包括：</p>

<blockquote><p>分布性。仓库管理流程控制系统天生就是分布式的。</p>

<p>性能。仓库管理流程控制系统不是一个“绝对的”实时系统，但性能仍与业务息息相关。对系统有整体的吞吐量要求，因此系统必须确保所有的运输指令能够被及时而有效地运行。</p>

<p>可伸缩性。不同仓库其大小可能会有很大的不同，因此仓库管理流程控制系统必须能既支持只有几千个箱子的小仓库，又要支持超过一百万个箱子的大仓库。</p>

<p>可用性。许多仓库操作采用三班倒的24/7模式工作，因此可用性是仓库管理流程控制系统对业务案例支持的关键因素。</p></blockquote>

<p>假设要设计这样的系统以支持这些质量属性。对于分布式而言，书中提出的解决方案是传统的分布式系统解决方案，即引入Broker模式，在本地建立对远程对象的代理。而对于支持并发的领域对象访问而言，则采用了Active Object模式，并引入Leader/Followers并发模型来获得可扩展。</p>

<p>我没有打算引入这么复杂的模式，而仅仅是通过引入消息队列，并为消息队列引入路由的方式，来实现系统的分布式。这其中当然会用到经典的Publisher-Subscriber模式。我对领域逻辑进行了识别，将整个仓库管理流程控制系统的领域逻辑分为三个Bounded Context。</p>

<ul>
<li><p>库存管理</p></li>
<li><p>物流控制</p></li>
<li><p>拓扑管理</p></li>
</ul>


<p>整个架构如下图所示：
<img class="center" src="http://agiledon.github.com/images/2014/inventory.jpeg"></p>

<p>对于库存管理而言，我认为它主要支持商品存放信息的数据管理，即获得商品数量、存放位置以及更新这些信息。对于该上下文而言，操作本身比较简单，且耗时较短。若出现大规模并发，其瓶颈也不在于获取或更新仓库信息（当然需要通过测试数据验证），而在于客户下订单后向仓库管理流程控制系统发起的发货请求。</p>

<p>我将发货请求放到了物流控制上下文中，除此之外，它还包括收货以及订单管理等。同时，对于物流控制与拓扑管理功能，基本上与具体的仓库形成了一一对应关系。此外，对于发货请求（或收货请求），并不要求很强的实时性，这使得对这些请求的异步处理成为可能。</p>

<p>物流控制由于牵涉到收货和运货，需要控制仓库的相关设备，并按照仓库的拓扑结构设定设备的路由。这说明物流控制与拓扑控制存在上下游关系，拓扑控制是上游。这两个上下文可以是Customer-Provider的关系。但它们之间不应该存在物理边界。因此，我将这两个上下文放到了同一个六边形中，而将库存管理放到了另一个单独的六边形中，以便于它们各自独立的可伸缩。</p>

<p>在库存管理与物流控制六边形之间，我引入消息队列来应对从库存管理子系统中转发而来的发货请求（发货请求实则又来自于E-Commerce的订单请求）。原则上，我针对一个物理的仓库建立一个单独的消息队列，因此库存管理在发送发货请求时，会根据商品的存放位置以及用户请求的IP地址，获得最优的仓库信息，然后通过Router将消息转发到正确的消息队列中。</p>

<p>一旦收到消息，物流控制系统作为消息队列的订阅者（或侦听器）就可以即使处理信息，进行后续的处理。</p>

<p>针对库存管理而言，我认为它是一个独立的物理边界，因此在可视化手段中，我展现为一个单独的库存管理六边形，如下图所示：
<img class="center" src="http://agiledon.github.com/images/2014/inventory_2.jpeg"></p>

<ul>
<li>建立了针对REST服务的端口，对应的适配器为Controller，其目的是支持E-Commerce系统。事实上，我们对E-Commerce系统进行过分析，获得的六边形架构正好与此对接。</li>
<li>建立了针对DB的端口，对应的适配器为DB Gateway，它负责访问库存管理自身的数据库。数据库持久化的消息包括商品的基本信息如SKU、商品名、数量等，以及商品存放的仓库名。</li>
<li>建立了针对Queue的端口，对应的适配器为Message Router，负责将发货请求消息路由到正确的消息队列。</li>
</ul>


<p>物流控制与拓扑管理放在同一个边界中，它是高度可伸缩的独立系统，为展现它的可伸缩性以及它与库存管理之间的集成，我在可视化手段中，展现出两个独立的六边形，如下图所示：
<img class="center" src="http://agiledon.github.com/images/2014/inventory_3.jpeg"></p>

<ul>
<li>针对Queue的侦听器端口，对应的适配器为Message Handler。若有必要，如为了更好的支持并发，也可以在此引入Active Object甚至Leader/Followers。</li>
<li>同样提供了针对REST的端口，对应适配器为Controller。它主要是为了支持移动终端设备、Web应用，以便于相关人员直接发出发货或收货请求。</li>
<li>同样提供了DB的端口。这个数据库是对应仓库的专有数据库，与库存管理数据库无关。</li>
<li>提供了针对设备（指仓库的设备，如叉车，箱子，运输车等）的端口，对应适配器为South Gateway。</li>
<li>提供了针对配置文件的端口，对应适配器为Configurer。此功能是为了支持拓扑信息的动态配置。</li>
<li>提供了针对外部物流系统的端口，这里为其建立了Shipping的防腐层，使其能够更好地支持各个不同的物流供应商。</li>
</ul>


<p>目前，我针对可视化架构与设计的手段仍在完善之中，并已经尝试在真实项目中实践以进行验证，并希望能够找到足够简单的方法，为架构师与开发者提供直观而又具有体验价值的沟通方式，并能形成行之有效的设计手段。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[推行TDD的思考]]></title>
    <link href="http://agiledon.github.com/blog/2013/12/25/thought-about-applying-tdd/"/>
    <updated>2013-12-25T21:26:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/12/25/thought-about-applying-tdd</id>
    <content type="html"><![CDATA[<p>目前来看，推行TDD的障碍大约有如下几点：</p>

<pre><code>1. 开发人员的质量意识；
2. 分析需求并进行任务分解的能力；
3. 将测试作为开发起点的开发习惯；
4. 开发人员的重构能力，包括如何识别坏味道和如何运用重构手法；
5. 单元测试的基础设施，尤其是测试数据准备；
</code></pre>

<h2>开发人员的质量意识</h2>

<p>开发人员对于软件质量，常常偏重于软件的外部质量，体现在他们的工作效益上，就是被测试人员发现的缺陷数。而惯常的软件开发思想，总是认为开发人员不适合做测试，因为他们总是站在自己的角度去看待问题，从而可能忽略真正需要测试的用例。这种思想给了开发人员一个错误信号，认为自己不应该写测试，即使写了测试，也写不好。殊不知，由开发人员编写测试带来的收益，最重要的一点不在于测试本身，而在于它能促进开发、测试以及需求分析人员的交流与沟通。而测试先行的方式也能让开发者跳出实现的窠臼，而从业务角度去看待问题，从消费者角度去思量接口。此外，由于开发者总是惫懒地将测试职责委派给了专门的测试人员，于是渐渐会产生一种依赖心理。测试人员的精确测试当然可以保障质量，但这种测试通常是黑盒测试，这里保障的质量主要还是外部质量。而且，这种测试带来的反馈总是慢于开发进度，一旦发现缺陷，修复缺陷的成本也会变得更高。</p>

<p>软件质量除了外部质量之外，内部质量同等重要。软件成本等于开发成本与维护成本之和，而维护成本的增加主要就归咎于内部质量的糟糕。这里讲的内部质量包括：代码的可读性、可重用性、可扩展性等。当我们让开发人员为原有代码编写单元测试时，总是觉得举步维艰。分析原因，主要问题在于代码的可测试性不好。要测试一个类，竟然连简单创建它的对象都变成了不可能完成的任务。我们为这样的代码编写单元测试，就好像在触及蜘蛛网，一旦被这些网丝给牵住，缠住，就可能无法摆脱。除非我们能够快刀斩乱麻，那对于这个系统而言，就不是维护，而是重写了。测试先行的开发至少在一定程度规避了这样的问题。即使代码的内部质量仍有所欠缺，但在足够覆盖率的保护下，我们要进行重构也变得更为简单。</p>

<!--more-->


<p>然而，这些好处都不是短期能够见到成效的，且团队若不能达成共识，只靠一二人坚定地践行TDD，在测试覆盖率不够的情况下，改进仍然有限。多数开发者在维护别人的丑陋代码时，可能会骂声连连，殊不知同时作为骂者自身，其实也在重复被骂者的故事。</p>

<p>我不是说没有采用TDD，代码质量就一定不高；但我可以说采用了TDD，代码质量至少有了可以改进的基础。</p>

<h2>分析需求并进行任务分解的能力</h2>

<p>需求分析能力常常是开发人员的短板。开发人员养成了一个习惯，看什么事情都会从技术实现的角度去思考。要实现一个网页，就会想到如何编写JavaScript来响应用户的动作，如何编写CSS，却不会去思考用户体验和操作的流程。要完成一个数据分析，总会想到数据的属性，转换和提取数据的算法，却不会想到分析数据的价值以及合理的流程。</p>

<p>而且对于繁琐的需求描述，我们总没有耐心去深入研读，而是会在掌握了大体意思后，就开始匆匆进行开发与实现。TDD要求我们在编写测试之前要做好合理的任务分解。若没有很好地理解需求，任务分解就无法顺利的进行。</p>

<p>这就带来了团队协作的问题。若我们能从需求的源头上进行改进，或许TDD会变得更容易。例如，我们对故事的拆分更合理，较好地遵循了User Story的INVEST原则，那么我们所要实现的Story在测试性、独立性方面都会有很好的改观。如果BA能够非常明确地编写出验收条件（Acceptance Cretiria），进行任务分解就变得更加容易了。</p>

<p>更进一步，若BA能够参考甚至遵循Specification By Example，并采用Given-When-Then的模式来描绘各个用例场景，再要进行任务分解，不就变得轻而易举吗？因此，有时候推行TDD非常艰难，或许最大的原因是我们仅仅将目光放到了开发者身上，而忽略了BA扮演的关键角色。正所谓：问渠那得清如许，为有源头活水来。</p>

<p>我一直强调任务分解是有层次的。分析需求时，不能一个猛子就扎进繁琐的实现细节。要从用户价值出发，先梳理出最外层的需求任务，然后抽丝剥茧，条分缕析地层层递进，如此方能理清思路，掌控复杂逻辑。基本上，任务分解可以分为三个层次，即业务价值——>业务功能——>业务实现。并且这个层次是一种“递归”的状态，视需求的复杂度而定。</p>

<h2>将测试作为开发起点的开发习惯</h2>

<p>再说说开发习惯的问题。这种改变显然不是一朝一夕可以完成的。以我个人的经验以及我所观察到的情况来看，固然是习惯的力量在作祟，然而主因还是因为对TDD方法的掌握程度以及一些误解导致。</p>

<p>前面已经述及，任务分解应该是TDD的起点。多数开发者未能形成任务分解的习惯。因此在改变为测试先行的时候，错以为应该一上来就写测试。因为思路没有理清，脑子里是一片乱麻，再加上本身对TDD不够熟悉，于是编写测试就变得举步维艰，总觉得束手束脚，就好像被绑了一只手，又好像是在泥沼中挣扎。许多时候，甚至发挥不出自己的哪怕三分的功力。</p>

<p>一贯以来，我们都在强调测试先行，测试先行……容易产生一种错觉，就是认为TDD必须一开始就写测试，“简单设计”嘛，于是就没有了设计。这让那些习惯于事先设计的开发者更难以接受。</p>

<p>以下是我对于“TDD是否需要事先设计”的个人观点：</p>

<blockquote><p>Martin Fowler的文章Is Design Dead？其实就是对此问题的正本清源。我个人认为，视场景而定，测试驱动开发仍可进行事先设计。设计并不仅包含技术层面的设计如对OO思想乃至设计模式的运用，它本身还包括对需求的分析与建模。若不分析需求就开始编写测试，就好像没有搞清楚要去的地方，就开始快步前行，最后发现南辕北辙。测试驱动开发提倡的任务分解，实际上就是一种需求的分析。而如何寻找职责，以及识别职责的承担者则可以视为建模设计。测试驱动更像是一种培养设计专注力的手段，就像冥想者通过盘腿静坐的手段来体悟天地一样，测试驱动可以强迫你站在测试的角度（就是使用者的角度）去思考接口，如此才能设计出表现意图的接口。但编写测试自身并不能取代设计，正如盘腿静坐并不等于就是冥想。</p>

<p>在开始测试驱动开发之前，做适度的事先设计，还有利于我们仔细思考技术实现的解决方案。它与测试驱动接口的设计并不相悖。解决方案或许属于实现层面，若过早思考实现，会干扰我们对接口的判断；但完全不理会实现，又可能导致设计方向的走偏。举例来说，如果我们要实现XML消息到Java对象的转换。一种解决方案是通过jaxb将消息转换为Java对象，然后再定义转换映射的Transformer，通过硬编码或者反射的方式将其转换为相关的领域对象。然后在执行了业务操作后，再将返回的结果转换为另一个Jaxb对象。而另一种解决方案则是通过引入模板，例如StringTemplate或者Velocity，定义转换的模板，然后进行替换实现。这两种解决方案的区别，直接影响了我们划分任务的方式。所以在运用TDD时，先不要一巴掌拍死，可以先抱着开放的态度尝试尝试。何况，TDD并非一招鲜，吃遍天，总要有适合它的场景。例如UI的开发，交互协作的控制逻辑，数据库开发，并发处理，都不是运用TDD的太好场景。</p></blockquote>

<h2>开发人员的重构能力</h2>

<p>TDD的核心是红——绿——重构。这意味着重构是TDD非常重要的一环，它直接关系到TDD开发出来的代码质量。没有好的重构能力，TDD就会有缺失。若说代码的内部质量是生命的话，重构就是灵魂，缺少了它，代码就没有灵性了。多数时候实施TDD，都会因为重构能力的缺乏而陷入困境。</p>

<p>重构的关键首先在于如何识别代码的坏味道。这需要代码阅读的千锤百炼，而非死记硬背老马总结的坏味道。当这些坏味道变成你的一种直觉，甚至就像与生俱来的一种能力时，你就会降低对糟糕代码的容忍度。在你眼中，这些烂代码就是垃圾，必须清扫，否则无法“安居”。</p>

<p>重构手法与代码坏味道一一对应。若有测试保障，重构就变得安全。但尽可能地，我们还是希望运用工具提供的自动重构功能，这既提高了重构效率，也在一定程度下确保了重构的安全。</p>

<p>当然，重要的是要找到重构的节奏感，即小步前行，每次重构必运行测试的良好习惯。若能结合分布式版本管理系统，做到原子提交，就会更加方便。即使重构出现问题，我也可以快速地回到前面的版本快照。</p>

<p>在TDD过程中，若能结对自然是上佳选择。当一个人在掌控键盘时，另一个人就可以重点关注代码的可读性，看看代码是否散发出臭味。两个人的眼睛终归要更锐利一些，至少视野的范围更广泛。</p>

<p><strong>及时重构</strong>是重构诸多实践中最重要的一点。不要让重构成为你在未来偿还债务的杀手锏。越拖到后面，偿还债务的成本就越高。以重构而论，可能需要的重构能力就更强，因为重构变得复杂了。当然，只要你的代码能够保证足够的覆盖率，以及较好的松散耦合，重构依旧可行。采用TDD，基本能满足这两条要求。但以成本而论，小步前行才是重构之道。</p>

<h2>单元测试的基础设施</h2>

<p>最后说说单元测试的基本设施。很多时候，这可能不是问题；但很多时候，这可能会成为大问题。面对诸如测试数据准备等问题，需要认真分析，找到应对方案。原则上最好能找到一些开源的测试框架，包括生成测试数据，模拟测试行为等……多数情况下，这些开源框架都已经提供了。因为你遇到的问题，别人可能早已遇见过。这个世界上有很多聪明而又乐于分享的程序员，不要局限在自己公司一隅。睁大眼睛看看满世界吧。所谓“君子生非异也，善假于物也”。好程序员，也要这样。</p>

<p>说不定，你会抛弃TDD，因为你找到了更好的适合你的做法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Git的使用场景]]></title>
    <link href="http://agiledon.github.com/blog/2013/12/24/the-scenarios-for-using-git/"/>
    <updated>2013-12-24T21:38:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/12/24/the-scenarios-for-using-git</id>
    <content type="html"><![CDATA[<p>无论学习什么技术，都需要了解该技术的本质。若是靠死记硬背该技术提供的方法或者语法，终归是知其然而不知其所以然，当发现错误时，你根本不知道是什么原因导致的。我在使用Git时，就处于这种知其然而不知其所以然的状态。现在，再来补补课。</p>

<p>Git有三个工作区域，分别为：工作目录（Working Directory）、暂存区（Stage或Index）以及资源库（Repository或Git Directory）。下图是文件在这三个工作区域之间的关系：
<img class="center" src="images/2013/lifecycle.png"></p>

<p>参考Pro Git一书，它给出了Git的几个要点：
* 直接快照，而非比较差异：Git与其他版本管理系统的主要差别在于，Git只关心文件数据的整体是否发生了变化，而其他多数版本管理系统则只关心文件内容的具体差异。Git并不保存文件前后变化的差异数据，更像是把变化的文件做一个快照，然后记录在一个微型的文件系统中。每次提交更新时，会比较这个快照。若文件没有变化，Git则只对上次保存的快照作一个链接。你可以理解Git就是一个小型的文件系统。
* 近乎所有操作都可本地执行：无需多说，这本身就是分布式版本管理系统的特征。
* 时刻保持数据完整性：保存到Git前，所有数据都要进行内容的校验和（checksum），并将该结果作为数据的唯一标识。Git使用了SHA-1算法计算数据的校验和，并将该结果作为索引，而非文件名。
<img class="center" src="images/2013/git-hash.png">
* 多数操作仅添加数据</p>

<!--more-->


<p>Pro Git一书认为任何一个文件在Git内部可以被分为三种状态：已提交（Committed）、已修改（Modified）和已暂存（Staged）。然而，这并不足以说明一个文件在不同的工作区域所展现的状态。我认为两种状态足以表达Git中的文件，即：未跟踪（Untracked）和已跟踪（Tracked）。而对于已跟踪状态，我又将其分为：未修改的（Unmodified），Modified（已修改的），暂存的（Staged）和已提交的（committed）。下图基本表达了我的思路：
<img class="center" src="images/2013/file-lifecycle.png"></p>

<p>这个图表现了多种场景，满足了我们在使用Git时耳濡目染的操作情形。</p>

<h2>场景1：暂存文件以及取消已暂存的文件</h2>

<p>可以参考上图中上面部分黑色箭头标示。当我们通过git init在本地初始化了Git工作目录后，新增了一个README.txt文件时，此时该文件处于Untracked状态。接下来执行命令：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>git add README.txt</span></code></pre></td></tr></table></div></figure>


<p>add命令可以暂存此文件，此时，状态变更为Staged状态，被放到了Git暂存区中。若我们要提交此文件到Git资源库，就可以执行git commit命令，文件状态变为committed。例如：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>git commit -m "first commit"</span></code></pre></td></tr></table></div></figure>


<p>有时候，我们希望取消已暂存的文件。例如说，我在工作目录中增加了两个文件，然后暂存了它们。后来发现其中一个文件并不需要在Git中管理，希望能够取消暂存。由于此时的文件处于Staged状态，我们只需要删掉Stage中对此文件的跟踪即可。这时需要执行的命令是：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>git rm --cached README.txt</span></code></pre></td></tr></table></div></figure>


<p><strong>注意：此时取消暂存的文件从来就不曾提交过，也即是说没有在Git Repository留下过它的身影。这时的取消暂存实则是删掉暂存的信息。与后面场景演示的取消暂存并不相同。</strong></p>

<h2>场景2：修改已提交文件以及取消已暂存的内容</h2>

<p>一旦文件被提交，就会在Git Repository形成提交记录（以hash作为键）。倘若我们此时push提交到远程Git服务器，Git服务器应与本地库保持一致。</p>

<p>现在，让我们看看图中红色箭头展现的流程。我们修改了已提交的README.txt文件，于是文件状态就变更为Modified。这部分修改的内容并没有被放入暂存区，若要提交此次修改，就还需要再次执行git add命令，将这次新的修改放入到暂存区。这个流程包括后面的提交都与场景1相似。唯一不同的是“取消已暂存的内容”。</p>

<p>虽然同样是取消暂存，但它与场景1是完全不同的概念。场景1实则是要取消暂存区的文件，因此使用了git rm &#8211;cached，本质上讲其实是删除。而这里的取消，其实是希望取消暂存区中已经被添加的修改内容，文件本身仍然保留在暂存区中。故而执行的命令为：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>git reset HEAD README.txt</span></code></pre></td></tr></table></div></figure>


<p>HEAD是何意呢？在Git中，HEAD是一个特别的指针，指向你正在工作的本地分支。当前分支就是master。如下图所示：
<img class="center" src="images/2013/git_head.png"></p>

<p>而reset命令的意思是重新设置当前的HEAD指针到特定的状态。由于当前的README.txt还没有提交到master分支的Repository中。因此，这条命令实则就是将HEAD指向README.txt文件在当前master分支的Repository状态，从而保证了对README.txt文件而言，暂存区与Repository的一致——取消了README.txt文件在暂存区的内容。</p>

<h2>场景3：修改文件以及撤销修改内容</h2>

<p>再看图中的绿色箭头与蓝色箭头展现的流程。我们不是初始化git工作目录，而是通过git clone从远程Repository克隆了项目，此时会在当前目录建立git工作目录。此时的文件全部处于Unmodified状态。</p>

<p>现在，我们修改文件，例如hello.java。一旦被修改，文件状态就迁移到Modified状态。倘若需要暂存此次修改，甚至提交到Git Repository，则执行的流程与场景1相同（如蓝色箭头线所示）。</p>

<p>然而，我们可能希望放弃此次修改，即不将修改的内容放入暂存区。这时，应执行checkout命令：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>git checkout -- hello.java</span></code></pre></td></tr></table></div></figure>


<p>在执行checkout命令时要慎重。因为它要撤销的内容并没有被放入到暂存区或Repository。一旦撤销，就一去不复返了。</p>

<h2>概念区分：fetch vs. pull</h2>

<p>fetch命令只是将远端数据拉到本地仓库，并不自动合并到当前工作分支。若要合并，还需手动合并。例如，执行git fetch origin，就会抓取自上次克隆以来别人上传到此远程仓库中的所有更新。</p>

<p>pull命令则除了会抓取数据，还能将远端分支自动合并到本地仓库中当前分支。</p>

<h2>场景4：撤销提交</h2>

<p>在Git中若要撤销提交，可以使用reset或者revert命令。但二者有着显著的区别：
<img class="left" src="images/2013/git_revert_vs_reset.png">
revert命令可以撤销已经提交的快照，但它并不会将该提交从项目的提交历史中移除，而是会判断要撤销的这次提交引入了哪些变化，然后将此变化撤销（此次撤销事实上还是一种变化），再将这次撤销作为一个提交。因此，在执行revert命令后，如果通过git log查看提交历史，可以看到会新增一个revert提交。命令为：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>git revert &lt;commit&gt;</span></code></pre></td></tr></table></div></figure>


<p>这个commit可以是指定提交对应的hash code。我们也可以用HEAD指针：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>git revert HEAD~n</span></code></pre></td></tr></table></div></figure>


<p>如果是revert当前提交，则不需要HEAD后的~n。</p>

<p>reset命令就字面意义已经表达了该操作的含义为“重置”。由于Git的提交记录是由HEAD指针指向当前分支。重置就是搬动这个指针到指定的snapshot。如果说revert是一种<strong>安全</strong>的撤销方式，则reset就是一种<strong>危险</strong>的撤销方式。默认情况下，如果使用reset命令，会将当前的分支回退到指定commit，然后自指定commit到最新commit之间的内容会放在工作目录下，使得我们可以再提交。这个命令为：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>git reset &lt;commit&gt;</span></code></pre></td></tr></table></div></figure>


<p>与前相同，这个commit就是提交对应的hash code。同样，也可以使用HEAD指针。不过如果是撤销当前提交，与revert不同的是，需要指定为：HEAD~1。这是因为HEAD指针指向了当前提交。reset与revert的意义不一样。revert对应的commit为目标提交，意思为：“撤销目标提交”，因而git revert HEAD，代表的就是“将当前提交撤销”。而reset对应的commit表示将指针移向给定的Commit。如果执行git reset HEAD，代表的就是“将当前指针指向当前提交”，相当于没做任何操作。所以应该执行git reset HEAD~1。</p>

<p>如果确实要撤销操作，而前面的内容并不需要，在使用reset命令时，可以添加&#8211;hard参数：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>git reset --hard &lt;commit&gt;</span></code></pre></td></tr></table></div></figure>


<p>**注意：针对远程的提交记录，应尽量避免使用git reset命令。倘若在本地进行了reset之后，又进行了另外的修改并提交。此时，本地的提交记录与远程的提交记录在reset的那个点产生了分叉。如下图所示：
<img class="center" src="images/2013/git_reset_commit.png"></p>

<p>此时，如果执行git push，会在本地合并后提交，并同步远程提交记录。则团队其他成员会因为这个变化的提交记录而困惑。由于一部分变更消失，甚至可能导致一些数据被破坏。因此，使用reset命令要格外当心，通常情况，应尽量针对本地提交（未push到远程）进行reset。优先考虑使用revert命令。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩花招的PowerMock]]></title>
    <link href="http://agiledon.github.com/blog/2013/11/21/play-trick-with-powermock/"/>
    <updated>2013-11-21T12:42:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/11/21/play-trick-with-powermock</id>
    <content type="html"><![CDATA[<p>当我们面对一个遗留系统时，常见的问题是没有测试。正如Michael Feathers在Working Effectively with Legacy Code一书中对“遗留代码”的定义。他将其简单归纳为“没有测试的代码”。真是太贴切了！正是因为没有测试，使得我们对遗留代码的任何重构都有些战战兢兢，甚至成为开发人员抵制重构的借口。从收益与成本的比例来看，对于这样的系统，我一贯认为不要盲目进行重构。因为重构的真正适用场景其实是发生在开发期间，而非维护期间。当然，提升自己的重构能力，尤其学会运用IDE提供的自动重构工具，可以在一定程度上保障重构的质量。然而，安全的做法，还是需要为其编写测试。</p>

<p>测试是分层的，即使是针对自动化测试。面对遗留系统，成本相对较低的是针对功能特性编写的功能测试（或者说是验收测试），这可以运用一些BDD框架如Cucumber、JBehave等。由于它的测试粒度较粗，可以以较少的测试用例覆盖系统的主要功能。然而，它的缺点同样存在，那就是反馈周期相对较长。这就好像你置身一个陌生的城市，在找不到路的情况下，只是跟着感觉走。走了数十公里之后，方才幡然醒悟，想起要翻一翻带在手上的地图。倘若发现方向走错，再要回转就已经晚了。反馈周期最短的自然是单元测试。同样根据Michael Feather的定义，单元测试一定要快，一定要不依赖于外部资源。单元测试的粒度自然是最小的，但不要直观地认为单元测试就是针对方法。若只是针对方法来编写单元测试，就会陷入为测试而测试的怪圈。即使是位于技术象限的单元测试，我们仍然要按照业务规则来编写。一个测试方法应该对应一个粒度最小的原子功能。</p>

<!-- more -->


<p>要让单元测试跑得快，还要不吃草（依赖外部资源），应该怎么办？答案呼之欲出，那就是Mock。Mock当然不是万能的，记得胡凯写过一篇文章，提及Mock不是银弹。我知道他仅仅是为了强调这个观点，避免太多人过于依赖Mock，因为Brooks早就发表过论断，在软件行业，其实根本就“没有银弹”。关于Mock的争论由来已久，对此，我准备避而不谈。至少在我看来，如下几点基本已成定论：</p>

<p>1、是Mock行为，而非Mock数据；如果是针对数据，则应该属于Stub的范畴；</p>

<p>2、Mock通常发生在三种情况（让我们假设被测试对象为消费者，它要协作的对象为服务，此时需要Mock服务）：服务的行为只有定义，还未实现；服务需要访问外部资源（这意味着它可能很慢，也意味着它需要依赖外部资源）；服务的行为结果不确定（例如天气服务，股票服务）。</p>

<p>自然，我们不需要自己写Mock，有许多现成的好用框架，例如Java平台下的Mockito与EasyMock，.NET平台下的Moq，以及C++下的Google Mock和MockCpp。</p>

<p>然而，问题依然存在。考虑这样两种情况：</p>

<p>1、当我们要Mock的服务，其实是Utils的静态方法时，应该怎么办？</p>

<p>2、当我们要测试的方法内部直接实例化了协作的服务对象，又该怎么办？</p>

<p>显然，这是设计和代码的坏味道，它明显违背了DIP原则，即它不应该依赖于细节，而应该依赖于抽象。换言之，它产生了对服务对象的具体依赖。若要遵循DIP，就应该在被测对象的外部来注入依赖。这种紧耦合酿成了我们设计的类不具备良好的可测试性。</p>

<p>一个蠢蠢欲动的声音在说：让我们重构吧！且住，先让我们把这苛求的眼光放柔和一点。当你视所有丑陋的代码为“蝼蚁”时，那是因为你站在了足够的高度。可是站得太高，往往摔得更惨。现在，还是脚踏实地，先设身处地地考虑这样的场景：这是一个代码行数超过1000万行的软件系统，一共有十余个开发团队，一百多名开发人员在这个团队中工作。这个系统几乎没有测试，而系统的Jar包则达到上千个。这些Utils的静态方法被数十乃至上百个类调用，牵涉到的模块也有多个甚至十余个。而且，这个系统并没有引入任何一个IoC容器。有了这样一个背景，让我们再把柔和的眼光变得锐利一点，分析分析重构的可行性。要消除前面提到的坏味道，就需要将这些静态方法修改为实例方法，并通过依赖注入的方式注入。这个变化带来的是对整个系统的全局影响，即使我们有一些自动化重构的手段，仍然不认为这种重构一定就是可行的。</p>

<p>这就是我要谈PowerMock的前提！</p>

<p>现在，轮到玩花招的PowerMock出场了。有了它，什么静态方法，方法内部实例，乃至私有方法，统统都是浮云。而且，它对Mockito与EasyMock的扩展，使得我们更容易熟悉它的语法。要使用它很简单，需先设置对它的依赖。我选择了PowerMock针对Mockito的扩展：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='xml'><span class='line'>        <span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>            <span class="nt">&lt;groupId&gt;</span>org.powermock<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;artifactId&gt;</span>powermock-api-mockito<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;version&gt;</span>1.5.1<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/dependency&gt;</span>
</span><span class='line'>        <span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>            <span class="nt">&lt;groupId&gt;</span>org.powermock<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;artifactId&gt;</span>powermock-module-junit4<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;version&gt;</span>1.5.1<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/dependency&gt;</span>
</span><span class='line'>        <span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>            <span class="nt">&lt;groupId&gt;</span>org.mockito<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;artifactId&gt;</span>mockito-all<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;version&gt;</span>1.9.5<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/dependency&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>让我先给出如下的一份奇奇怪怪的设计，它主要是为了迎合之前提到的代码臭味。</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeTableUtil</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">findAll</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">existed</span><span class="o">(</span><span class="n">employee</span><span class="o">.</span><span class="na">getId</span><span class="o">()))</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ExistedEmployeeException</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//insert employee</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">employee</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullEmployeeException</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">delete</span><span class="o">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">existed</span><span class="o">(</span><span class="n">employee</span><span class="o">.</span><span class="na">getId</span><span class="o">()))</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//delete employee</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">existed</span><span class="o">(</span><span class="n">String</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeRepository</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">EmployeeTableUtil</span> <span class="n">tableUtil</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="nf">EmployeeTableUtil</span><span class="o">().</span><span class="na">count</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">findAll</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">findAll</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">insert</span><span class="o">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">tableUtil</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">employee</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExistedEmployeeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">update</span><span class="o">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">employee</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NullEmployeeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">delete</span><span class="o">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">tableUtil</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">employee</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">double</span> <span class="nf">bonus</span><span class="o">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">employee</span><span class="o">.</span><span class="na">getSalary</span><span class="o">()</span> <span class="o">*</span> <span class="mf">0.1d</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTableUtil</span><span class="o">(</span><span class="n">EmployeeTableUtil</span> <span class="n">tableUtil</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">tableUtil</span> <span class="o">=</span> <span class="n">tableUtil</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在，我要针对EmployeeRepository编写测试，它协作的服务类为EmployeTableUtil，主要承担了访问数据库的职责。在测试EmployeeRepository时，我们需要去Mock协作对象EmployeeTableUtil的行为。</p>

<p>在使用PowerMock编写测试时，首先需要在测试类上运用框架提供的Annotation：@PrepareForTest，以及一个Runner：PowerMockRunner。因为我们要Mock的对象为EmployeeTableUtil，故而测试类的定义为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@RunWith</span><span class="o">(</span><span class="n">PowerMockRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="nd">@PrepareForTest</span><span class="o">(</span><span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeRepositoryTest</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">EmployeeRepository</span> <span class="n">repository</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Before</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUp</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">repository</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EmployRepository</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在我要使用PowerMock去Mock静态方法，如EmployeeTableUtil的findAll()方法，至于要测试的方法则为EmployeeRepository的findAll()方法。则编写的单元测试为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_mock_static_method</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">List</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">employee</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">employee</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Employee</span><span class="o">(</span><span class="s">&quot;1&quot;</span><span class="o">));</span>
</span><span class='line'>        <span class="n">employee</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Employee</span><span class="o">(</span><span class="s">&quot;2&quot;</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">PowerMockito</span><span class="o">.</span><span class="na">mockStatic</span><span class="o">(</span><span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>        <span class="n">when</span><span class="o">(</span><span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">findAll</span><span class="o">()).</span><span class="na">thenReturn</span><span class="o">(</span><span class="n">employee</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">List</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">employees</span> <span class="o">=</span> <span class="n">repository</span><span class="o">.</span><span class="na">findAll</span><span class="o">();</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">employees</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">employees</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">getId</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="s">&quot;1&quot;</span><span class="o">));</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">employees</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">getId</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="s">&quot;2&quot;</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">PowerMockito</span><span class="o">.</span><span class="na">verifyStatic</span><span class="o">();</span>
</span><span class='line'>        <span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">findAll</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Mock静态方法的关键是先要调用框架定义的PowerMockito类的mockStatic()方法（针对EasyMock有相似的类）。方法接收的参数就是我们要Mock的类的类型。接下来就可以调用Mockito框架的方法，对我们要模拟的方法findAll()进行模拟，这里主要的工作是为模拟方法的返回值设置一个stub。之后就是单元测试的验证逻辑。如果需要验证被Mock的方法是否被调用，则需要调用PowerMockito.verifyStatic()方法，紧随其后的是被mock的方法。</p>

<p>如果要Mock的方法是一个命令方法（即没有返回值的方法），做法又有不同。倘若熟悉Mockito，可以看出PowerMock完全沿袭了Mockito的风格（当然，针对EasyMock的扩展则会沿袭EasyMock的风格，这是PowerMock体贴人的地方）：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_mock_exception_for_command_method_in_mock_object</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Employee</span> <span class="n">employee</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Employee</span><span class="o">(</span><span class="s">&quot;1&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">PowerMockito</span><span class="o">.</span><span class="na">mockStatic</span><span class="o">(</span><span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>        <span class="n">PowerMockito</span><span class="o">.</span><span class="na">doThrow</span><span class="o">(</span><span class="k">new</span> <span class="n">NullEmployeeException</span><span class="o">()).</span><span class="na">when</span><span class="o">(</span><span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>        <span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">employee</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">repository</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">employee</span><span class="o">),</span> <span class="n">is</span><span class="o">(</span><span class="kc">false</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>PowerMock还可以Mock私有方法，当然只能是实例的私有方法。这主要发生在当我们不希望Mock服务的公开方法时（例如，公开方法的逻辑没有Mock的必要），但这些公开方法的内部又调用了自己的私有方法，而私有方法却需要Mock。例如，EmployeeTableUtil的insert()和delete()方法调用了私有的existed()方法。假设insert()和delete()方法不需要我们Mock，此时就需要对私有方法existed()进行Mock。因为是实例方法，所以下面的测试方法通过调用setTableUtil()方法将被模拟的对象注入到EmployeeRepository对象中：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_mock_private_method</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Employee</span> <span class="n">employee</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Employee</span><span class="o">(</span><span class="s">&quot;1&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">EmployeeTableUtil</span> <span class="n">util</span> <span class="o">=</span> <span class="n">PowerMockito</span><span class="o">.</span><span class="na">spy</span><span class="o">(</span><span class="k">new</span> <span class="n">EmployeeTableUtil</span><span class="o">());</span>
</span><span class='line'>        <span class="n">PowerMockito</span><span class="o">.</span><span class="na">when</span><span class="o">(</span><span class="n">util</span><span class="o">,</span><span class="s">&quot;existed&quot;</span><span class="o">,</span> <span class="n">anyString</span><span class="o">())</span>
</span><span class='line'>                <span class="o">.</span><span class="na">thenReturn</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">repository</span><span class="o">.</span><span class="na">setTableUtil</span><span class="o">(</span><span class="n">util</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">repository</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">employee</span><span class="o">),</span> <span class="n">is</span><span class="o">(</span><span class="kc">false</span><span class="o">));</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">repository</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">employee</span><span class="o">),</span> <span class="n">is</span><span class="o">(</span><span class="kc">true</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>PowerMock顺带还提供了测试私有方法的便捷办法（注意是测试，而不是Mock）。例如，测试EmployeeReployee类的私有方法bonus()：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_test_private_method</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Employee</span> <span class="n">employee</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Employee</span><span class="o">(</span><span class="s">&quot;1&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="n">employee</span><span class="o">.</span><span class="na">setSalary</span><span class="o">(</span><span class="mi">8000</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Whitebox</span><span class="o">.&lt;</span><span class="n">Double</span><span class="o">&gt;</span><span class="n">invokeMethod</span><span class="o">(</span><span class="n">repository</span><span class="o">,</span> <span class="s">&quot;bonus&quot;</span><span class="o">,</span> <span class="n">employee</span><span class="o">);</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">is</span><span class="o">(</span><span class="mi">800</span><span class="n">d</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后再来看看另外一种诡异的手段。假设我们要测试的方法其内部调用了协作对象的方法，而该协作对象不是在外部注入的，而是在方法中直接实例化。例如在前面例子中，EmployeeRepository的count()方法：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeRepository</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">EmployeeTableUtil</span> <span class="n">tableUtil</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="nf">EmployeeTableUtil</span><span class="o">().</span><span class="na">count</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>要针对这样一种情形进行Mock，做法有所不同。因为它实际针对的是待测类——即这里的EmployeeRepository——执行count()方法，这就需要在count()方法内部形成一个拦截点。因此，需要在@PrepareForTest标记中指向EmployeeRepository类的类型，而非我们要Mock的EmployeeTableUtil。故而，我们需要为这个测试定义一个新的测试类：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@RunWith</span><span class="o">(</span><span class="n">PowerMockRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="nd">@PrepareForTest</span><span class="o">(</span><span class="n">EmployeeRepository</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConstructionEmployeeRepositoryTest</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_mock_construction_object</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">EmployeeTableUtil</span> <span class="n">util</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>        <span class="n">when</span><span class="o">(</span><span class="n">util</span><span class="o">.</span><span class="na">count</span><span class="o">()).</span><span class="na">thenReturn</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">PowerMockito</span><span class="o">.</span><span class="na">whenNew</span><span class="o">(</span><span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">withNoArguments</span><span class="o">().</span><span class="na">thenReturn</span><span class="o">(</span><span class="n">util</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">EmployeeRepository</span> <span class="n">repository</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EmployeeRepository</span><span class="o">();</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">repository</span><span class="o">.</span><span class="na">count</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，测试方法的前两行代码调用的mock()与when()方法都是Mockito提供的方法，与PowerMock无关。</p>

<p>我虽然没有看过PowerMock的源代码，但我猜测，当我们在使用PowerMock去Mock静态方法时，定然是结合反射与代理的方式来完成对该方法的调用，其中必然需要初始化该类。由于是静态方法，更多的是需要静态初始化。此外，还有一种情形时，你所要测试的类声明和初始化了一个静态的字段。这些都可能需要调用静态初始化。我们在开发中就碰到一种情形是，我们希望Mock的一个类，定义了一个static块，其中又调用了私有的静态方法。在这个私有静态方法中，依赖了其他的一些对象，这些对象还牵扯到服务容器的问题。即使以静态的方式Mock了该类，仍然逃不过运行static块的命运，换言之，仍然需要依赖服务容器。这时，又可以祭出PowerMock的杀器了。它提供了@SuppressStaticInitializationFor的标注，在该标注中需要传入字符串类型的目标类型的全名。假设EmployeeTableUtil有一个static块是我们需要绕过的，它的类全名为com.agiledon.powermock.EmployeeTableUtil：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@RunWith</span><span class="o">(</span><span class="n">PowerMockRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="nd">@PrepareForTest</span><span class="o">(</span><span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="nd">@SuppressStaticInitializationFor</span><span class="o">(</span><span class="s">&quot;com.agiledon.powermock.EmployeeTableUtil&quot;</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeRepositoryTest</span> <span class="o">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>此外，对于@PrepareForTest以及@SuppressStaticInitializationFor标记而言，如果需要针对多个类型，则需要传入一个数组，例如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@RunWith</span><span class="o">(</span><span class="n">PowerMockRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="nd">@PrepareForTest</span><span class="o">({</span><span class="n">MockedObjectA</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">MockObjectB</span><span class="o">.</span><span class="na">class</span><span class="o">})</span>
</span><span class='line'><span class="nd">@SuppressStaticInitializationFor</span><span class="o">({</span><span class="s">&quot;com.agiledon.powermock.MockedObjectA&quot;</span><span class="o">,</span> <span class="s">&quot;com.agiledon.powermock.MockedObjectB&quot;</span><span class="o">})</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">OneTest</span> <span class="o">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>或许我已经变得像祥林嫂一般的唠叨，但我还是必须再次申明，以上Mock方式所针对的情形皆为设计与代码的坏味道。优先情况下，我们应该重构，使得它遵循DIP原则，解除对服务类的耦合，使其具有良好的可测试性；而不能因为有了强大的PowerMock而“姑息养奸”。换言之，让我们仅仅将PowerMock耍弄的种种花招，看做是压箱底的手段。实在走投无路了，再祭出你的杀手锏吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Maven为一个项目生成多个Jar包]]></title>
    <link href="http://agiledon.github.com/blog/2013/11/10/create-two-jars-from-one-project-using-maven/"/>
    <updated>2013-11-10T22:43:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/11/10/create-two-jars-from-one-project-using-maven</id>
    <content type="html"><![CDATA[<p>虽然在Java平台下，各种构建工具如Maven、Gradle、SBT已经得到了较为广泛地运用，同时Maven约定的模块目录结构也得到了业界的认可，成为了Java平台下项目结构的事实标准。但我们总无法避免与各种遗留系统或老系统打交道。在没有Maven的时代，是Ant统治的时代，它因为提供了较为灵活的编写Task的功能，而忽略了制定一套看似呆板，实则有效的标准模板。于是，在不同的企业，不同的Java项目，出现了各种各样奇怪的目录结构与打包要求。拖着这些沉重的历史包袱，我们自然希望彻底革命，把那些看不顺眼的东西全部改造，让整个项目焕然一新。这是好事儿，所谓长痛不如短痛，一下子把问题肿瘤给割了，痛快！可是现实总有那么一些阻力会让我们缩手缩脚，我们不能挥起革命的利刃一阵乱砍，这弄不好会砍伤自己的手。于是乎，我们需要做战略性的撤退。退一步海阔天空嘛。</p>

<p>我面对的就是这样一个软件系统。这个Java开发的软件系统一直没有依赖管理，仅仅编写了Ant任务用于发布打包。我们的任务是渐进地引入Maven，并在从Build到deploy的整个生命周期中，逐步替换Ant，与持续集成搭配起来。这个系统的多数模块都划分了服务端与客户端。然而不巧的是，各个模块的服务端和客户端都集中在一个模块中。同时，这个项目的目录结构并非标准的Maven结构，如下图所示。因此，还需要自定义Source与TestSource的目录结构。在原来的Ant任务中，是将它们打包成了两个Jar包。现在，我们需要在Maven中同样做到这一点。</p>

<!-- more -->


<p><img class="left" src="http://agiledon.github.com/images/2013/folder-structure.png"></p>

<p>分析这个目录结构，无非是在打包时，对文件进行include或exclude。我查阅到Maven的一位开发者Tim O&#8217;Brien写的一篇博客<a href="http://blog.sonatype.com/people/2010/01/how-to-create-two-jars-from-one-project-and-why-you-shouldnt/#.Un9DKpTN_Gp">Sonatype的博客</a>，详细介绍了具体的做法。当然，在博客中，他一再强调了这种做法的不可取，建议在项目模块上做出好的分解，保证一个Module对应一个Jar包。这篇博客介绍了两种做法，一个是在Profile中定义，一个则是在build中定义，使用的插件皆为maven-jar-plugin。对于我要解决的问题，可以考虑选择使用第二种做法，因为它只需要执行一条mvn package命令就能同时得到Server和Client的Jar包。具体的做法就是在插件的配置中，include各自的文件夹即可。配置如下：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='xml'><span class='line'>    <span class="nt">&lt;groupId&gt;</span>com.test.maven<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>testmaven<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;version&gt;</span>1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;build&gt;</span>
</span><span class='line'>        <span class="nt">&lt;sourceDirectory&gt;</span>src<span class="nt">&lt;/sourceDirectory&gt;</span>
</span><span class='line'>        <span class="nt">&lt;testSourceDirectory&gt;</span>testSrc<span class="nt">&lt;/testSourceDirectory&gt;</span>
</span><span class='line'>
</span><span class='line'>        <span class="nt">&lt;plugins&gt;</span>
</span><span class='line'>            <span class="nt">&lt;plugin&gt;</span>
</span><span class='line'>                <span class="nt">&lt;artifactId&gt;</span>maven-jar-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>                <span class="nt">&lt;executions&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;execution&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;id&gt;</span>server<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;goals&gt;&lt;goal&gt;</span>jar<span class="nt">&lt;/goal&gt;&lt;/goals&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;phase&gt;</span>package<span class="nt">&lt;/phase&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;configuration&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;classifier&gt;</span>server<span class="nt">&lt;/classifier&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;includes&gt;</span>
</span><span class='line'>                                <span class="nt">&lt;include&gt;</span>**/server/**<span class="nt">&lt;/include&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;/includes&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;/configuration&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;/execution&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;execution&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;id&gt;</span>client<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;goals&gt;&lt;goal&gt;</span>jar<span class="nt">&lt;/goal&gt;&lt;/goals&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;phase&gt;</span>package<span class="nt">&lt;/phase&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;configuration&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;classifier&gt;</span>client<span class="nt">&lt;/classifier&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;includes&gt;</span>
</span><span class='line'>                                <span class="nt">&lt;include&gt;</span>**/client/**<span class="nt">&lt;/include&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;/includes&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;/configuration&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;/execution&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/executions&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/plugin&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/plugins&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/build&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过这样的配置，运行mvn package可以生成三个包，其中testmaven-1.0-SNAPSHOT.jar同时包含了服务端和客户端的类；而服务端和客户端对应的Jar则为testmaven-1.0-SNAPSHOT-server.jar和testmaven-1.0-SNAPSHOT-client.jar。</p>

<p>在前面的配置中，我们并没有为server和client包定义自己的坐标，而是沿用了统一的一个。这就意味着依赖这个包的其他Module，可能无法通过Dependency来精确定位Server或Client。这对于部署来说，是没有问题的，但却无法进行依赖管理；除非在依赖的时候，去依赖整个大的模块。</p>

<p>要保证依赖管理，就意味着需要为server和client分别指定各自的坐标。看来需要另辟蹊径。其实，Maven是支持在一个项目中建立多个子模块的。我们可以考虑在项目中引入两个子模块，分别对应server和client，并在这两个子模块中建立自己的pom.xml文件。这在本质上是与Maven多模块支持是相同的，唯一不同的是代码结构。而且这种新建模块并没有影响原有的目录结构，对于遗留系统而言，还是可以接受的。因此，我们建立了如下图所示的模块结构：
<img class="center" src="http://agiledon.github.com/images/2013/module-structure.png"></p>

<p>在新的结构中，除了原有模块外，我还引入了另外两个新的模块server和client，它们除了拥有自己的pom.xml文件，没有其他任何内容。而在原有模块下，同样定义了一个pom.xml文件，它将作为整个项目的parent。定义如下：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='xml'><span class='line'>    <span class="nt">&lt;groupId&gt;</span>com.test.maven<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>testmaven<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;version&gt;</span>1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>    <span class="nt">&lt;packaging&gt;</span>pom<span class="nt">&lt;/packaging&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;modules&gt;</span>
</span><span class='line'>        <span class="nt">&lt;module&gt;</span>server<span class="nt">&lt;/module&gt;</span>
</span><span class='line'>        <span class="nt">&lt;module&gt;</span>client<span class="nt">&lt;/module&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/modules&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里定义的坐标是整个项目的坐标，同时指定了packaging的类型为pom。在这个pom.xml文件中还包括了两个子模块，其中的值应该与模块的名称对应。接下来配置server模块的pom.xml：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='xml'><span class='line'>    <span class="nt">&lt;parent&gt;</span>
</span><span class='line'>        <span class="nt">&lt;groupId&gt;</span>com.test.maven<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>        <span class="nt">&lt;artifactId&gt;</span>testmaven<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>        <span class="nt">&lt;version&gt;</span>1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/parent&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>testmaven-server<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;build&gt;</span>
</span><span class='line'>        <span class="nt">&lt;sourceDirectory&gt;</span>../src<span class="nt">&lt;/sourceDirectory&gt;</span>
</span><span class='line'>        <span class="nt">&lt;testSourceDirectory&gt;</span>../testSrc<span class="nt">&lt;/testSourceDirectory&gt;</span>
</span><span class='line'>
</span><span class='line'>        <span class="nt">&lt;plugins&gt;</span>
</span><span class='line'>            <span class="nt">&lt;plugin&gt;</span>
</span><span class='line'>                <span class="nt">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>                <span class="nt">&lt;version&gt;</span>3.1<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>                <span class="nt">&lt;configuration&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;includes&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;include&gt;</span>**/server/**<span class="nt">&lt;/include&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;/includes&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/configuration&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/plugin&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/plugins&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/build&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先声明了parent指向了主模块的坐标。接下来，声明当前模块的artifact id为testmaven-server。这就为server指定了独立的坐标。一旦部署后，在maven的Repository中会得到这样的文件：com/test/maven/testmaven-server/1.0-SNAPSHOT/testmaven-server-1.0-SNAPSHOT.jar。我们就可以在依赖中这样声明：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='xml'><span class='line'>    <span class="nt">&lt;dependencies&gt;</span>
</span><span class='line'>        <span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>            <span class="nt">&lt;groupId&gt;</span>com.test.maven<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;artifactId&gt;</span>testmaven-server<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;version&gt;</span>1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/dependency&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/dependencies&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行mvn package，oops……竟然出现问题了。什么问题呢？单元测试无法通过。报告的错误为：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:testCompile (default-testCompile) on project testmaven-server: Compilation failure: Compilation failure:
</span><span class='line'>[ERROR] /Users/twer/learn/testmaven/testSrc/com/test/maven/client/HelloMavenTest.java:[11,9] cannot find symbol
</span><span class='line'>[ERROR] symbol  : class HelloMaven
</span><span class='line'>[ERROR] location: class com.test.maven.client.HelloMavenTest</span></code></pre></td></tr></table></div></figure>


<p>仔细分析，原来是在执行编译server包时，报告无法编译client包对应的测试类。怎么会在编译server包时，去编译client包对应的测试呢？仔细观察我们的pom.xml文件，在maven-compiler-plugin插件中，我们配置了对server文件的引入，这就意味着在编译server包时，不会引入client文件夹下的所有文件（当然在这里就是Java类文件）。但是，我们并没有在test-compile阶段排除client对应的测试文件。这就导致client的测试无法找到对应的实现类。找到根源，问题就好解决了，显然我们需要在test-compile阶段排除client文件夹。所以，server模块下正确的pom.xml配置为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='xml'><span class='line'>    <span class="nt">&lt;parent&gt;</span>
</span><span class='line'>        <span class="nt">&lt;groupId&gt;</span>com.test.maven<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>        <span class="nt">&lt;artifactId&gt;</span>testmaven<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>        <span class="nt">&lt;version&gt;</span>1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/parent&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>testmaven-server<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;build&gt;</span>
</span><span class='line'>        <span class="nt">&lt;sourceDirectory&gt;</span>../src<span class="nt">&lt;/sourceDirectory&gt;</span>
</span><span class='line'>        <span class="nt">&lt;testSourceDirectory&gt;</span>../testSrc<span class="nt">&lt;/testSourceDirectory&gt;</span>
</span><span class='line'>
</span><span class='line'>        <span class="nt">&lt;plugins&gt;</span>
</span><span class='line'>            <span class="nt">&lt;plugin&gt;</span>
</span><span class='line'>                <span class="nt">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>                <span class="nt">&lt;version&gt;</span>3.1<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>                <span class="nt">&lt;configuration&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;includes&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;include&gt;</span>**/server/**<span class="nt">&lt;/include&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;/includes&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/configuration&gt;</span>
</span><span class='line'>                <span class="nt">&lt;executions&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;execution&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;id&gt;</span>default-testCompile<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;phase&gt;</span>test-compile<span class="nt">&lt;/phase&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;configuration&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;testExcludes&gt;</span>
</span><span class='line'>                                <span class="nt">&lt;exclude&gt;</span>**/client/**<span class="nt">&lt;/exclude&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;/testExcludes&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;/configuration&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;/execution&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/executions&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/plugin&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/plugins&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/build&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：我在IntelliJ配置execution下的configuration节时，碰到一个问题，那就是针对testExcludes配置节没有智能提示。由于其他maven配置节在正确情况下都有智能提示，因而让我产生错误，认为这个配置项不支持testExcludes，这让我纠结了好半天。</p>

<p>对于client模块而言，如法炮制，只是包含以及过滤的文件夹反转了一个个儿而已。当我们进行install甚至deploy时，在repository下的test/maven文件夹中，看到了三个文件夹，如图所示：
<img class="center" src="http://agiledon.github.com/images/2013/maven-repository.png"></p>

<p>其中的testmaven/1.0-SNAPSHOT文件夹下并没有jar包，因为它对应的配置为主模块的配置，也就是parent配置。在这个配置中，我们将packaging的类型设置为pom了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Guava提供的Preconditions]]></title>
    <link href="http://agiledon.github.com/blog/2013/10/09/using-preconditions-of-guava/"/>
    <updated>2013-10-09T22:57:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/10/09/using-preconditions-of-guava</id>
    <content type="html"><![CDATA[<p>我看到这么一段Java代码，主要逻辑是对传入的数据对象进行分析和处理。方法除了长了一点，本身没有什么问题，但一个不好的味道是方法中充斥了一部分对对象非空的处理，以及写日志的信息。这些语句本身不属于方法的主干实现，却很讨厌地干扰了方法的主要逻辑，影响了程序的可读性。</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Processor</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">ProcessData</span> <span class="n">processData</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">processData</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">processData</span><span class="o">.</span><span class="na">getInput</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;processData is error&quot;</span><span class="o">);</span>
</span><span class='line'>          <span class="k">return</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">List</span><span class="o">&lt;</span><span class="n">FavoratePolicy</span><span class="o">&gt;</span> <span class="n">policies</span> <span class="o">=</span> <span class="n">fetchPolicies</span><span class="o">(</span><span class="n">processData</span><span class="o">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">policies</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">policies</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;can not fetch favorate policies&quot;</span><span class="o">);</span>
</span><span class='line'>          <span class="k">return</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="n">FavoratePolicy</span> <span class="n">policy</span> <span class="o">:</span> <span class="n">policies</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="c1">//handle policy</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我最初想要尝试使用Guava提供的Optional。经过仔细分析，发现这里的场景并不适合Optional。Optional确实可以用于处理null object，甚至可以将其看做是Null Object模式的实现。但它为Java语言带来的好处，无非是提高了代码可读性，同时可以有效地防止程序员忘记对null的判断。它不能带来代码量的减少，用在这里，也无法消除非空判断以及日志的噪音。所幸，Guava还提供了Preconditions，它拥有更好而简洁的断言方式，可以处理程序的一些异常分支。它主要定义的方法包括checkArgument(), checkNotNull()以及checkState()等，可以通过抛指定异常的方式，将程序的主分支与异常分支有效地隔离开。通过引入checkArgument()方法，前面的代码可以调整为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Processor</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">ProcessData</span> <span class="n">processData</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">checkArgument</span><span class="o">(</span><span class="n">processData</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">processData</span><span class="o">.</span><span class="na">getInput</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">,</span> <span class="s">&quot;processData is error&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>          <span class="n">List</span><span class="o">&lt;</span><span class="n">FavoratePolicy</span><span class="o">&gt;</span> <span class="n">policies</span> <span class="o">=</span> <span class="n">fetchPolicies</span><span class="o">(</span><span class="n">processData</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>          <span class="n">checkArgument</span><span class="o">(</span><span class="n">policies</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(!</span><span class="n">policies</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()),</span> <span class="s">&quot;can not fetch favorate policies&quot;</span><span class="o">);</span>
</span><span class='line'>      
</span><span class='line'>          <span class="k">for</span> <span class="o">(</span><span class="n">FavoratePolicy</span> <span class="n">policy</span> <span class="o">:</span> <span class="n">policies</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="c1">//handle policy</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalArgumentException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="n">ex</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>经过这样的处理，程序的主体逻辑变得清晰了许多，而且也能够有效地避免日志方法的重复。当然，这里也可以使用checkNotNull()方法来处理ProcessData与List<FavoratePolicy>的null情形。但由于它抛出的异常为NullPointerException，用在这里会增加一个异常捕获（因为它无法处理isEmpty()的情况），所以就一致地选择了checkArgument()方法。不过，在使用这一方法时，要注意它传入的条件表达式与原有实现的表达式是相反的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于《恰如其分的软件架构》]]></title>
    <link href="http://agiledon.github.com/blog/2013/08/29/about-just-enough-software-architecuture/"/>
    <updated>2013-08-29T10:39:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/08/29/about-just-enough-software-architecuture</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2013/justenough_cn.jpg">
华中科技大学出版社的徐定翔问我意见，了解我对Just Enough Software Architecture这本书的观感，看是否值得引进。时间是在2010年。从一开始，我就被书名中的Just Enough理念所吸引。它让我想起宋玉的东家姑娘，“增之一分则太长，减之一分则太短”那种不可言说的美丽。我在心里说，架构设计就需要这样。我当时并没有看到本书，只是到Amazon上找到了几篇英文原版样章。犹记得我在读到第一章介绍的RackSpace案例时那种兴奋之情。于是，我迫切地向徐定翔强烈推荐引进这本书，而我则毛遂自荐，希望能作为本书的译者。之后，我在InfoQ上看到对本书的《<a href="http://www.infoq.com/cn/articles/fairbanks-jesa">访谈和书摘</a>》，进一步加强了我翻译本书的信念。于是，出版社开始与作者Fairbanks联系，然而从此音讯如石沉大海。时针指向2011年，我对于本书是否被引进，是否由我翻译，一切未知。我觉得我可能错过了它，思之仍觉怅然。谁知到了九月，消息突然确定，而徐大编辑就不容分说地直接把原书给我寄来了。</p>

<p>拿到沉甸甸的书，第一面就为本书的装帧而惊喜。心里想，我这一辈子若能写出这样一本书，绝对值得生命走过的这一遭了。我并没有迫不及待地开始翻译，这就好似遇到珍馐美味，需得先赏其色，闻其香，然后再品其味。我每天抱着这本书饶有兴味地开始阅读之旅。阅读之旅确乎如行山阴道，沿途之美，目不暇接；可一想到翻译，这种美景就成了一种折磨，因为我害怕辜负这一美景。翻译之初我就举步维艰，那些词语放在那里，我却无法解开“封印”将它们取出来，即使取出来，却又找不到存放的合适位置。一些翻译隐隐约约浮现着，当我竭力去揭开这些词语的真面目时，无论如何用力，总也不能够着。翻译就好像那些年我们一起追过的女孩——追不到，痛苦；追到了，销魂。翻译进度像蜗牛一样的爬着，我终于决定求助了。辗转寻找了好多朋友，都以各种理由拒绝或者放弃了。翻译讲解软件架构的书，确乎不是一件轻松的事儿。那个时候，我的Buddy肖鹏正从翻译《面向模式的软件架构》第五卷的泥潭中爬了出来。每一提及他的这段翻译经历，脸上就会浮现出不堪回首的表情，如看了恐怖片。终于，事情得到转机，最开始是倪健的雪中送炭，再有高翌翔的锦上添花，随着我们这个三人组的建立，翻译才算开始走向正规，我才有了交稿的信心。</p>

<p>自从开始翻译这本书后，我与人谈架构，动辄就会提及“Just Enough，恰如其分”。我像祥林嫂一般地推介着Fairbanks提出的风险驱动模型，并认真地实践着这一模型。我开始对演进的架构有了更深入的理解。我写了《<a href="http://localhost:4000/blog/2011/10/10/design-just-enough-architecture/">设计恰如其分的架构</a>》这篇博客来详细阐述我对演进式架构的理解。在2011年我参加的技术会议上，我也反复讲解了如何遵循简单之美的原则，运用风险驱动模型设计恰如其分的架构。2012年，在我参加的一个项目中需要针对遗留系统进行技术栈迁移。我撰写了文章《<a href="http://www.infoq.com/cn/articles/legacy-system-migration">遗留系统的技术栈迁移</a>》，提到了“风险驱动模型”，并在2013年的Scrum Gathering会议上分享了我的一些想法。当然，这个模型并不是锤子，更不是银弹。它更近似于质量属性驱动的架构设计，我们要满足的质量属性，可能就是我们在做架构时需要面对的风险；而在Roy Fielding的那篇关于REST的著名论文中，也提到了对约束的识别，并演示了如何从一个空约束，通过逐步添加约束演化为REST风格的架构。从某种程度上，架构的约束可能是一种风险，也可能成为设计的驱动力。</p>

<p>前几天，我参加Agile China 2013，与我新认识的一位朋友范钢聊到了关于架构重构的问题。事实上，面向对象软件开发到现在，已有十余年之久；各种经验、模式与原则甚嚣尘上并得到较好的推广。然而新的方法、新的语言乃至新的思想仍然层出不穷，尤其是在互联网开发、大数据处理以及移动开发的冲击下，传统软件开发似乎已经开始走向末路。“只见新人笑，不见旧人哭”！？？是，也不是。实际上，在传统的企业开发领域，各种大型系统仍然像一艘庞大如巨型海兽一般的船舰在海面缓缓行驶，它或许就是沉没之前的泰坦尼克，一切还都安然无恙，你甚至可以听到船头甲板传来的悠扬的小提琴声；然而，冰川就在远处出没，船长还未察觉。我们该怎么办？这样的巨型船舰，自然不可能如艨艟快艇那般的敏捷，即使是360度的转身，也可以玩得如此漂亮、优雅。这些大型的企业级软件系统已经走过了漫长的历程，它们如此巨大以至于我们只能看到它的一角，它们的零部件如此复杂以至于没有人能够彻底弄懂。我们必须认识到，这些系统是最有权力的系统，它们很有可能掌握了人类生活的根本命脉——金融管理、股市交易、生命健康、医疗管理、机械制造、国防安全、航空、航天……它们就像政治界、金融界的那些巨头，要是患了病咳嗽两声，也许世界都要抖一抖。它们可以轻易改变吗？不能！然而若是不寻求改变，这些系统会宿命地走向衰亡。若我们无法承受重写的成本，唯一的办法或许就是架构的重构。我们必须清晰地认识到这一点。而我认为，风险驱动模型恰恰可以作为架构重构的指导原则。在进行重构之前，我们需要充分评估重构的价值，回答“为什么我们需要重构”的问题；然后去识别风险。在开始重构之前，我们需要尽可能做到万无一失。风险自然是不可避免的，但如果我们能事先识别出这些风险，就能有的放矢地选择正确的技术。风险驱动模型的第三步，则是评估风险是否得到有效缓解。不要轻视这一步！重构往往意味着还债。可是，我们该用什么来说服管理者们付出成本去做一些看似没有产生直接利益的任务呢？答案就是用数据来说话，通过比较重构前后的系统健康指标，可以加重说服老板的砝码。当然，毫无疑问，这个过程一定是迭代的。</p>

<p>我想，通过这次交谈，我进一步找到了“风险驱动模型”适用的场景。而这正是我翻译并推荐本书的根本意义。本书可以在<a href="http://product.dangdang.com/product.aspx?product_id=23320387">当当网</a>购买。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ThoughtWorks读书雷达-方法学篇]]></title>
    <link href="http://agiledon.github.com/blog/2013/08/06/methodologies-of-reading-radar/"/>
    <updated>2013-08-06T10:41:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/08/06/methodologies-of-reading-radar</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2013/readingradar03.png"></p>

<p>方法学（Methodology）看似与开发技能无关，常为程序员忽略。忽略意味着未曾察觉，却不等于它的无关紧要。我们每时每刻呼吸的空气同样会被我们忽略，但空气不重要么？不要等到我们开始戴上口罩，每日关心PM 2.5指数时，方才察觉原来空气的质量已经积重难返了。在我们的读书雷达中，方法学象限囊括的书籍多与开发过程相关。如果说开发技能是程序员修炼过程中必须加强的显式的力，则开发过程的这些思想与实践，就是隐藏的推手。你若不动，它会推你前行，然而缓慢；若你后退，则推动的阻力就大，暗流汹涌。只有自愿向前，这种助力才能如鱼得水，使你能够优游地前行。</p>

<p>软件开发说通了，不是技术问题，而是人的问题。</p>

<p>由于我们所处的领域，敏捷方法才是我们的擅长，因而在这个象限中，我们推荐的书籍主要与敏捷相关。首先推荐的是一本祖师级的经典大作，Kent Beck的Extreme Programming Explained《<a href="http://book.douban.com/subject/1099376/">解析极限编程</a>》。一切关于极限编程的思想、原则与实践，都能追本溯源到本书，寻找到这些内容的出处。如果你从未曾了解或接触过XP，通过本书，可以给你最正确的引导；若你已经在项目中运用了XP，却又心存疑虑，阅读本书一定能为你答疑解惑。</p>

<p>相较于《解析极限编程》更偏重理论，Henrik Kniberg的著作Scrum and XP from the Trenches《<a href="http://book.douban.com/subject/5501718/">硝烟中的Scrum和XP</a>》会带给你不同的感受。我们喜欢它的短小，简单，实用，书的气质分外地符合敏捷的精神。该书是Henrik Kniberg真实项目经验的提炼，讲述了成功敏捷团队的工作过程，没有理论、没有引用、没有脚注、没有废话。它可以作为基础实践的入门指南，帮助团队正确实施Scrum与XP——但不能模仿。你需要了解自己所处的环境，进而对具体实践做出取舍，创造出属于自己的过程。</p>

<p>如今，精益思想已经被许多不同的行业所广泛采用，该思想在软件行业的影响尤为显著。现代化的软件开发思想和实践方法，早就开始从精益思想里学习和借鉴，包括迭代开发，质量内建，一人多技，一岗多能，全功能团队，看板管理，持续改善等等。精益思想背后的想法可以追溯到上个世纪40年代后期，丰田公司的一群工程师发现了在连续流动中进行少量生产的方法，这种方法可以像传统的大量生产者批量生产大量产品的方法一样有效率。对于初次接触精益思想的读者来说，这种&#8221;少量生产和批量生产一样有效率&#8221;的思想，未免有些反直觉和难以理解，因为我们从小接触到的观念就是”只有大批量生产才是有效率的“。Freddy Balle等人的著作The Golden Mine《<a href="http://book.douban.com/subject/1852682/">金矿</a>》就是为初次接触精益思想的读者准备的。本书采用小说的形式，描述了一家濒临破产的企业如何采用精益的方式，扭亏为盈，让人读起来非常轻松有趣。</p>

<!--more-->


<p>在我们推荐的初学读物中，基本上覆盖了XP、Scrum与精益等主流的敏捷软件开发方法与思想。但是，我们还单独挑出了Mike Cohn的著作User Stories Applied《<a href="http://book.douban.com/subject/4743056/">用户故事与敏捷方法</a>》。因为——需求的重要性无论怎么强调都不为过，只有真正理解了用户需求，才能谈得上软件开发的成功。软件的需求说明不一定要是冷冰冰的，也未必需要庞大复杂的方法理论。用户故事对需求的描述更为柔和，预留了讨论和想象的空间，又能借助此作为项目评估的依据，需求分析和确认的基础。本书是描述用户故事的经典之作，几乎涵盖了编写用户故事的方方面面，同时又结合了敏捷开发思想的精髓，以加深你对敏捷开发的理解。</p>

<p>若要更上一层楼，我们还需要进一步了解更多的实践方法，当然，也包括理论的升华。许多方法大都源于实践，然而若无更高抽象层次的思想体系，则方法仅能作用于一事一物，场景一变，就只能偃息旗鼓了。正如你看一花的开放与衰败，并不能知春来与秋逝；只有把握内在的自然运行规律，四季的变换才可以被知悉。因而就精益思想而言，我想，阅读《金矿》不过是让你有了登堂入室的资格，若要走得更深，吃得更透，更好的阅读选择还是James P. Womack等人的经典之作Lean Thinking《<a href="http://book.douban.com/subject/1424857/">精益思想</a>》。该书阐述了精益思想的五大基本原则，并阐明了一些用于所有行业，并能创造永久价值的简单而有效之原理。同时，为了更好地说明这些原理，并阐释该如何应用它们，给出了大量包括应用步骤和从大企业到小企业的应用实例。本书的视角非常的高远，它将精益思想传播到了产品生产的整个价值流，关注于精益企业的打造。这种精益思想的全局观，可以让我们跳出软件行业的狭窄领域，观察更加广阔的天地。</p>

<p>Paul Duvall等人的Continuous Integration《<a href="http://book.douban.com/subject/2580604/">持续集成</a>》和Jez Humble的《<a href="http://book.douban.com/subject/6862062/">持续交付</a>》，加上Martin Fowler的<a href="http://www.martinfowler.com/articles/continuousIntegration.html">Continuous Integration</a>，可以看做是软件构建的三部曲。你以为持续集成亦然达到了目标，可是距离交付又还差了最后一公里。然而，没有持续集成，所谓持续交付又成了一句空话。便宜的阅读方法是快速浏览Martin Fowler的这篇文章后，直接步入Jez Humble建造的持续交付殿堂。这个殿堂没有售票员拦着你查看你手持的行程票；但是，在跨入这扇门之前，先去敲开Paul那扇门，会让你的步伐走得更坦然。持续集成和持续交付到底有多重要？在我连续经历了具有持续集成与持续交付能力的项目后，要让我再回到以前的项目开发状态，我会以为自己被遣送到软件宇宙的太初，一片混沌。</p>

<p>我们的读书雷达面向程序员，可是我们仍然毫不犹豫地推荐了诸多与测试相关的著作。这一认识完全符合精益的“一人多技”原则。团队成员一起战斗，程序员对测试说：“我把后背交给你！”然后，义无反顾地冲上前去战斗。可你冲得越猛越快越发的犀利，后背的测试就越撑不住。换言之，你理解为你支撑后背的测试人员吗？当团队需要你的测试技能时，你能挺身而出吗？阅读Lisa Crispin的Agile Testing《<a href="http://product.china-pub.com/53665">敏捷软件测试</a>》，可以让你切换到测试视角，观察我们该如何在敏捷项目中执行测试行为以保障软件的质量。作者在测试领域浸淫了丰富的项目经验，因而能够完整全面地勾勒出敏捷测试的全景，且又能深入到测试的细节，可谓敏捷测试的集大成者。因此，Robert Martin推荐本书，认为它“实用、智慧、反对教条。本书意义重大，每一位软件专业人员都应该阅读”。</p>

<p>James A. Whittaker等撰写的著作<a href="http://book.douban.com/subject/7065508/">How Google Tests Software</a>揭秘了作为本世纪最成功的软件企业之一的Google，是如何应对和处理软件测试的复杂性的。Google通过对自身软件特征的定位，自我演化出一种非同寻常的测试文化。这种特立独行并非刻意为之，而是从工程实用性的角度量体裁衣。Google的测试开发工程师（SET）角色正是这种工程实用文化的凸显。Google的高级工程总监Patrick Copeland认为：“最好的办法是让测试人员有能力把测试作为产品的真实的功能写到代码库里，测试作为产品的一个功能应该和真实用户可以看到的其他功能一模一样。”这种测试工程文化未必能够照搬照学，但其中内涵的一些测试策略与原则，仍旧值得我们学习和借鉴。</p>

<p>如果是在5年或者8年之前，我们推荐阅读Matt Stephens与Doug Rosenberg的著作Extreme Programming Refactored《<a href="http://book.douban.com/subject/1400341/">重构极限编程</a>》，是希望读者能够冷静地思考极限编程，不为各种吹捧而着迷。然而，时至今日，那种膨胀以及夸大地吹捧已经烟消云散，使得我们多数人已经能够正确地对待敏捷方法，对待极限编程。那么，为何我们还要推荐本书？这是因为，我们希望转动一下极限编程的水晶球，观察它不同的棱面，即便是面对暮色折射出的幽暗光芒，同样有其诱人之处。反面地或者说批判地审视极限编程，并不会彻底的否定极限编程推崇的实践与原则，只是予我们以警示，要求我们结合具体场景因地制宜，因人而异地推行这些敏捷实践。本书只不过是完整地拉开了极限编程的帷幕，让我们不只看到了舞台上的精美表演，也看到了角落一隅可能存在的混乱与无序。</p>

<p>工程师其实并不擅长用文字去描述自己所思所想，因此何谈准确描述客户的需求？我们喜欢事实说话，数字说话，因为它不会撒谎，不会虚饰，因而不会误解。这正是Specification By Example《<a href="http://book.douban.com/subject/11611022/">实例化需求</a>》的出发点。该书是作者Gojko Adzic从大量工程项目得来的经验，基于大量的业内研究提炼出来的知识总结。这种实例化需求的方式既能清晰地表述需求，消除客户、需求分析师、开发人员与测试人员在沟通中可能产生的理解分歧；又极为融洽地支持开发人员进行有效地测试驱动，帮助测试人员条理清晰地完成对需求功能的验收和测试。实例化需求不仅仅是一种方法，更是一种对软件开发方法学的革命，我如此认为。</p>

<p>注：本文由张逸与刘龙军共同完成。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spray的模块结构]]></title>
    <link href="http://agiledon.github.com/blog/2013/08/02/analysis-sourcecode-of-spray-1/"/>
    <updated>2013-08-02T22:07:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/08/02/analysis-sourcecode-of-spray-1</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://agiledon.github.com/images/2013/spray_logo.png">
Spray是基于Akka之上的轻量级Scala库，提供对客户端与服务端REST/HTTP的支持。在使用上，大概可以将其视为Java平台下的Jersey；虽然它们的特性并不尽相同。从Scala语言来看，它提供的Future与Promise可以较好地支持并发；而Akka的Actor模型无疑助推了Spray的并发处理性能。根据<a href="http://spray.io/">Spray官方网站</a>的描述，它拥有如下的特性：</p>

<blockquote><p>完全异步的，无阻塞的APIs<br/>基于Actor与Future<br/>高性能<br/>轻量级<br/>模块化<br/>可测试性</p></blockquote>


<p>之所以称其为库（library）而非框架（Framework），源于Spray的设计哲学。似乎在Spray的设计者眼中，只要沾上了“框架”这个名词，就显得不够轻量，耦合也会随之而来。虽然框架并非容器，无需管理诸多对象的生命周期，但它总会为应用添加一些框架级别的约束。框架更像是一个骨架（Skeleton），应用所要做的是将自己的内容填充到这个骨架中。应用能否运行良好，取决于框架的支撑作用。以我之浅见，大约可以如此简单分辨：框架之于应用，是一种白盒式的调用，你须得了解一些框架细节，遵循规定的约束或规范，才能更好地发挥框架的威力；而类库之于应用，则是职责向黑盒传递的委派，若要调用库，只需明晓其接口即可。</p>

<p>正如Spray的官方网站所说，Spray更像是基于Http搭建的一个集成层（Integration Layer）。因此你不必将自己的应用搭建在Spray之上，仅仅是当需要对Http的集成时，Spray可以成为你的一项选择。这种松散耦合，去除“供应商绑定”的方式，实在招人喜爱。Spray引人驻足的魅力，不仅在于Akka Actor模式对并发的良好支持，Scala语言本身也使其增色不少。Scala的语法较之Java更其灵活而先进，那些支持不变式、函数编程以及闭包等特性，总会让Java程序员垂涎三尺(至少在Java 8之前)。若再遥想不远将来Scala提供的async以及await（一如C# 5.0的语法特性），编写Scala程序应大有可为。当然，或也可能成亦Scala，败亦Scala，毕竟面对数量级庞大的Java程序员，Scala仍属小众。这会成为Spray的阿克琉斯之踝吗？</p>

<!--more-->


<p>诸多因子促使我选择Spray作为一个研究对象。我想，通过使用Spray，并深入挖掘其源码，定能让我受益良多。当然，在剖析其源代码之前，先让我们看看Spray的模块结构吧。
<img class="center" src="http://agiledon.github.com/images/2013/spraymodules.png"></p>

<p>既然Spray号称其具有松散耦合的组件结构，就让我们对这些模块间的依赖来一个先睹为快。要识别模块之间的依赖关系，最直观的方式莫过于绘制一个依赖图：
<img class="center" src="http://agiledon.github.com/images/2013/spraydepencies.png"></p>

<p>整洁的依赖显得清爽，斩钉截铁，绝不拖泥带水。那种如网一般深邃的依赖关系，会让人迷失。这其中的要点，仍然在于职责的分配。借助依赖关系图可以更加直观展现，何处出现多余或繁复的依赖线与环，肉眼即可观察获得。这种图甚至可以通过直觉去感受，只要绘图得当，布局合理，会有平衡之感。</p>

<p>如上图所示，以浅绿标明的三个模块，都处于被依赖的层次，按照“依赖沉淀”的法则，我将其放在整个图的最底层。观其名，我们似乎也可察知这几个模块更倾向于基础设施或公共设施的范畴。值得特别书写的是spray-http，因为该模块除了必须依赖的Scala之外，完全独立，没有任何依赖。它提供了基本的Http数据结构，如Request，Response以及其他公共Header。对于一个支持Http的库而言，可以视其为核心。</p>

<p>spray-caching提供了基本的缓存功能，是一个非常小的模块，仅仅包含cache.scala与LruCache.scala两个类。它引入了Future对象，使其能够更好地满足并发处理的缓存。此外，它还调用了google code上的一个第三方开源库concurrentlinkedhashmap（上图的紫色模块），作为存储Future对象的数据结构。spray-can是整个库的主要模块，提供了高性能的Http Server与Client。在这个模块中，主要的APIs都直接或间接继承了Akka提供的Actor。spray-servlet扮演了适配器的角色，它的主要目的是在Servlet API之上提供spray-can的服务器接口，从而使得spray能够在servlet容器中使用路由功能。因此，该模块除了依赖spray-util与spray-http之外，实则还要依赖于Java的Servlet。注意，上图的虚线依赖说明的是一种可选的关系。单从这一点来看，也部分说明了spray模块间的松散耦合度。一个示例是上图未曾列出的spray-json，就属于可选的用于处理json的模块。</p>

<p>无论是依赖关系，还是模块职责展现的抽象层次，spray-client与spray-routing都属于更加high-level的模块。例如spray-client可以视为对spray-can中提供的Http Client APIs的包装，属于更高层次的抽象。spray-routing则以优雅的DSL形式提供了定义REST服务的接口。</p>

<p>观察Spray的模块分解，非常注重职责的内聚，并以较小的粒度划分模块。由于它的设计目标为库，每个模块展现了自己的关注点，使其能够最大限度地被用户单独使用。例如当我仅需要缓存功能时，完全可以忽略Spray中支持HTTP以及REST的模块。同时，它注重调用视角的区分，为不同的调用者提供不同的抽象层次。在充分满足松耦合、高内聚的架构原则之上，适度地考虑接口的可用性与可读性。我喜欢这样一种轻量级的，尽其可能简单的架构设计。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AgileChina2003架构演进杂志]]></title>
    <link href="http://agiledon.github.com/blog/2013/07/29/agilechina-magazine/"/>
    <updated>2013-07-29T22:06:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/07/29/agilechina-magazine</id>
    <content type="html"><![CDATA[<h3>“架构演进”介绍</h3>

<p>软件系统的架构从来都不是一蹴而就的，它需要在不断的演化中改进设计，甚至做出重要的架构迁移。尤其对于大型软件系统而言，组织管理、软件过程、需求变化、规模扩张、技术迁移、遗留系统等诸多因素都决定着架构的发展，甚至可能是诸多力量的博弈与权衡。</p>

<h3>技术文章</h3>

<h4>演化架构与紧急设计系列</h4>

<p>本系列文章旨在从全新的视角来介绍经常讨论但是又难以理解的软件架构和设计概念。作者 Neal Ford 将通过介绍一些具体示例来帮助您在演化架构和紧急设计的灵活实践中打下坚实的基础。通过将重要的架构和设计决定推迟到最后责任时刻，您可以防止由于不必要的复杂度而降低软件项目质量的问题。点击<a href="http://www.ibm.com/developerworks/cn/java/j-eaed/">链接</a>。</p>

<h4>遗留系统的技术栈迁移</h4>

<p>遗留系统是一个还在运行和使用，但已步入软件生命周期衰老期的软件系统。它可能会因为无法满足新的质量需求，又或者是出于企业战略决策的考虑等诸多原因，需要对其进行技术栈迁移。然而，在迁移过程中，我们既需要满足迁移后的需求，又必须保证原有的系统功能不会受到破坏，这就为技术栈迁移制造了障碍。本文提出运用“风险驱动模型”来完成这一工作。风险驱动模型就是通过识别风险，对风险排定优先级；然后根据风险选定相关技术，再对风险是否得到缓解进行评估的一种架构方法。点击<a href="http://www.infoq.com/cn/articles/legacy-system-migration">链接</a>。</p>

<h4>注重实效的架构师——大胆行前人未行之路</h4>

<p>是什么让架构师们精通自己的技艺？熟练的架构师是如何进行设计的？一次次，有人问起我这些问题，而我也不止一遍的问我自己。很明显，这并不只是软件工程过程、设计方法、技术或是编程的专业程度所决定的。很多架构师具备令人钦佩且完备的技术知识，这确实是使设计成功的必要条件。但是，还是有很多的软件项目失败了，或是在项目的架构中遭受到了严峻的挑战。掌握此道的关键在于架构师是以什么方式实现设计，他们重视什么，他们关注哪些方面以及在这些方面努力着。点击<a href="http://www.infoq.com/cn/articles/pragmatic-architect">链接</a>。</p>

<!--more-->


<h4>可扩展Web架构与分布式系统</h4>

<p>开放源代码已经成为一些大型网站的基本原则。而在这些网站成长的过程中，一些优秀的实践经验和规则也出现在他们的结构中。本文旨在介绍一些在大型网站结构设计的过程中需要注意的关键问题以及实现目标的基础工作。本文侧重于介绍网络系统，尽管一些准则在其他分布式系统中也是适用的。点击<a href="http://www.oschina.net/translate/scalable-web-architecture-and-distributed-systems">链接</a>。</p>

<h4>架构师</h4>

<p><img class="left" src="http://agiledon.github.com/images/2013/07/nealford.png"></p>

<h5>Neal Ford</h5>

<p>Neal Ford是全球IT咨询公司ThoughtWorks的软件架构师。除了常规工作，他做的事情还包括设计和开发应用程序、教学材料、杂志文章、课件和视频/DVD演示，同时还是各种技术书籍的作者或者编辑，其中包括著作The Productive Programmer。他专注于设计和开发大规模企业应用程序，同时，他也是世界开发人员会议的国际知名演说家。
<img class="right" src="http://agiledon.github.com/images/2013/07/ericevans.png"></p>

<h5>Eric Evans</h5>

<p>大型业务系统方面的领域建模和设计专家。早20世纪90年代，他就参与了很多项目，基于对象（Object）开发出许多大型的业务系统，并致力于将敏捷过程应用到现实项目中。
此外，Eric Evans还是《领域驱动设计——软件核心复杂性应对之道》一书的作者。在书中他总结了构建上述业务系统相关的经验、原则和技术等。并介绍了一个建模和设计技术的系统，成功的团队应用这一系统可以组装有业务需求的复杂软件系统，并使系统在增大时仍然保持敏捷。
Eric现在是“Domain Language”组织的负责人。该组织是一个咨询小组，它指导和训练团队实施领域驱动设计，帮助他们使自己的开发工作对业务而言更有生产力和更有价值。<img class="left" src="http://agiledon.github.com/images/2013/07/buschmann.png"></p>

<h5>FranK Buschmann</h5>

<p>德国慕尼黑西门子技术公司资深技术专家及负责人。Wiley软件设计模式系列图书主编。他的研究领域包括对象技术、软件架构、产品线、模型驱动软件开发和模式。他曾是ANSI C++标准化委员会x3J16的成员，于1996年发起了首届EuroPLoP会议。Frank Buschmann是Pattern-Oriented Software Architecture系列书籍的主要作者。
<img class="right" src="http://agiledon.github.com/images/2013/07/george.png"></p>

<h5>Fred George</h5>

<p>Fred George先生在敏捷开发领域颇有声望，在业界有将近40年的开发经验，是国际敏捷领域大师级专家、咨询师、架构师。早年他在IBM工作。退出IBM之后，以独立咨询师的身份在美国工作了十多年。后来他加盟了ThoughtWorks，成为早期致力于推动敏捷开发的一批开发者。现在他离开了ThoughtWorks，在英国的TrafficBroker公司就任解决方案架构师一职。</p>

<h4>推荐书籍</h4>

<p><img class="left" src="http://agiledon.github.com/images/2013/07/releaseit.png">#####Release It!</p>

<p><strong>推荐理由：</strong>Michael Nygard的Releast It!可以看做是处理软件系统质量属性的治病良方。本书常常会以一个具体的实例开始阐述某一个质量属性的关键性，并列出一系列的反模式作为参照和对比，最后再给出正确的模式列表。这种针对问题的叙事方法，使得读者往往能够照方抓药，又因为模式的叙述如此清晰而规范，所以常常能药到病除。正如本书书名所指，这些内容确乎与软件的发布息息相关。</p>

<p><img class="right" src="http://agiledon.github.com/images/2013/07/beautifularchitecture.png"></p>

<h5>Beautiful Architecture</h5>

<p><strong>推荐理由：</strong>全书涵盖的内容广博而宏大，涵盖了架构基本原则、企业级应用架构、系统架构、最终用户应用架构、语言与架构，分列为本书的五大部分，读之会让人产生目不暇接之感。尤其对于术有专攻的程序员来讲，要彻底吃透本书讲解的内容，无疑是一项艰巨的挑战。然而，如果从架构师所必须具备的技能来看，本书的内容其实并没有超出架构的范畴，因为架构师必须要见识广博，你才能针对不同的需求场景，面对不同的实现技术，选出最适合当前场景的恰如其分的架构方案。</p>

<p><img class="right" src="http://agiledon.github.com/images/2013/07/eip.png"></p>

<h5>Enterprise Integation Patterns</h5>

<p><strong>推荐理由：</strong>本书关注企业级软件系统的本质问题，那就是集成。对于采用异步消息传递的集成方案，本书针对不同场景给出了不同的解决方案，并以模式的方式进行概述与归纳。倘若你在设计软件系统时，需要使用异步消息传递的方式对系统进行集成，本书可以成为你的最佳指南。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[代码是如何腐化的]]></title>
    <link href="http://agiledon.github.com/blog/2013/07/05/corrupt-code/"/>
    <updated>2013-07-05T14:26:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/07/05/corrupt-code</id>
    <content type="html"><![CDATA[<p>代码是如何腐化的？这是一个很大的话题，因为这种腐化的代码样本可能会体现不同的特征，若要彻底总结，可能会又是一本《重构》。我自然没有这个能力和知识。好在有一个简便的说法，即可以诉诸于“破窗理论”的威力。无论多少坏味道识别，重构手法运用，提高代码质量的最佳实践，以及运用诸多甄别代码质量体征的工具，都仅仅限于“术”的运用而已。若未能在开发人员内心树立整洁代码的习惯，时时刻刻对各种代码臭味保持敏感，且具有一颗期待卓越代码之心，那么，随着项目的演进，时间的推移，代码最终还是会慢慢腐烂。</p>

<p>这几日在开发一个User Story时，从诸多测试代码（包括集成测试与验收测试）中，观察到了一些接近腐烂的代码坏味。这些代码虽然不是产品代码，但同样是我们交付工件的一部分。最关键之处在于：它让我察觉到一种危险的趋势，若不能及时扭转，可能会让代码陷入腐烂的泥沼。若能及时解决这些糟糕代码，其实仅仅需要一些简单的重构手法，付出几个小时时间即可。</p>

<p>首先是针对集成测试的数据准备。我们要编写的集成测试针对Spring Batch Job，这些Job需要访问数据库，以验证Job的执行是否符合期望。我们发现在之前已有与Spring Batch Job相关的集成测试存在，并提供了访问数据库，以及启动、访问和停止Ftp服务器的功能。其中，与数据准备有关的功能放到单独定义的Fixture类中。这些Fixture是为特定目的编写的数据准备，可是，随着越来越多的Batch Job出现，有诸多集成测试都需要准备数据，于是开始慢慢产生了测试数据的重叠，逐步浮现出违背DRY原则的征兆了。</p>

<!--more-->


<p>对于多数程序员而言，并非不重视重用，但多数却不愿意为了重用付出一些代价。例如针对一些具备差异性的功能，一些程序员更愿意使用Copy And Paste，然后再针对自己的需求对实现进行修改或调整。观察目前的一些集成测试，正是这样一些陋习导致的。</p>

<p>在这些集成测试中，使用了继承的方式来重用数据准备的功能。如下图所示：
<img class="center" src="http://agiledon.github.com/images/2013/07/datafixture.png"></p>

<p>在CustomerIntegratedDataFixture中，提供了相关方法实现了对Customer数据的创建。由于需要提供访问FtpServer的功能，因此又定义了CustomerIntegratedDataAndFtpPrepareFixture类，使其继承CustomerIntegratedDataFixture。它定义了startFtpServer()和stopFtpServer()方法，并在JUnit中，运用了@BeforeClass与@AfterClass标记，使其避免为每个测试启动和停止专有的FtpServer。现在，我们编写的集成测试同样需要与Customer有关的数据，但并不需要Ftp功能。换言之，我们希望重用CustomerIntegratedDataFixture。现在看来，似乎并没有问题。例如，我们可以让新增的测试直接继承CustomerIntegratedDataFixture。然而，就在同样的集成测试模块中，我们还发现了其他集成测试同样编写了自己的数据准备类。这些数据准备与Spring Batch Job无关，却同样提供了准备Customer数据的功能。存在的差异是它除了提供Customer数据外，还提供了依赖Customer的Consent数据。</p>

<p>我们没有着急去重用CustomerIntegratedDataFixture，因为我们察觉到代码会随着这种继承体系的延伸，会变得越来越难以重用。如上图的继承体系，使得数据准备与Spring Batch Job紧耦合了，同时又在CustomerIntegratedDataAndFtpPrepareFixture子类中引入了与Ftp有关的耦合，明显违背了单一职责原则。我们需要单独剥离出数据准备的类，它即可以作为超类被集成测试类继承，也可以通过组合的方式被继承了JobLauncherTestUtils的测试子类所调用。这符合Bridge模式的设计原则。因此，我们运用了“Replace Inheritance with Delegation”手法，对其进行了简单重构：
<img class="center" src="http://agiledon.github.com/images/2013/07/datafixtureafterrefactor.png"></p>

<p>之后，我们对Customer和Consent对应的数据准备类进行了相应的重构与修改，使得这些数据的准备更为内聚，并去除一些不必要的重复，使之更容易被重用。
<img class="center" src="http://agiledon.github.com/images/2013/07/customerfixture.png"></p>

<p>第二个例子是在JBehave的Story中，我看到了这样的Steps类的组织，如图：
<img class="center" src="http://agiledon.github.com/images/2013/07/steps.png"></p>

<p>我们看到了什么？——一个“扁平组织”的Steps类。显然，促成这样的结果是一个渐进的过程。由于在之前编写相关的Steps类时，还看不到分类的概念，因此，只是简单地将自己的Steps类放到step之下即可。然后，不断有开发人员增加自己的Steps类，他们找到了step位置，却没有仔细思考是否需要更好地对Steps类进行组织。这就使得Steps类略显零乱，没有展现出好的结构。我们重新组织了这些Steps类：
<img class="center" src="http://agiledon.github.com/images/2013/07/stepsafterrefactor.png"></p>

<p>只需要简单地归类，调整结构，整个Steps类就变得更加清晰了。于是，我们发现了可以重用的可能。观察重新组织之后的batch包，这里面包含的UpdateCustomerTypeSteps，ProductSystemLinkLoaderSteps与DeleteOrphanedRecordsSteps，都是与Btach Job有关的Steps类。MaintainProspectsSteps类则是我们新增的类，它同样需要用到启动Batch Job的方法。在之前存在的Steps类中，已经存在相似的代码了。例如在UpdateCustomerTypeSteps类中：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="nf">waitAndGetSatus</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">params</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">status</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">MAX_TRY_TIME</span><span class="o">;</span> <span class="n">index</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">status</span> <span class="o">=</span> <span class="n">getJobStatus</span><span class="o">(</span><span class="n">params</span><span class="o">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="s">&quot;COMPLETED&quot;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">status</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">break</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">WAIT_INTERVAL</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">status</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="nf">getJobStatus</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">params</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">db2JdbcTemplate</span><span class="o">.</span><span class="na">queryForObject</span><span class="o">(</span><span class="s">&quot;select jobExec.STATUS from TCIST_JOB_EXECUTION jobExec &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;inner join TCIST_JOB_PARAMS jobParam on jobExec.JOB_INSTANCE_ID = jobParam.JOB_INSTANCE_ID &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;and jobParam.KEY_NAME = &#39;retry&#39; &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;and jobParam.STRING_VAL = ?&quot;</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">params</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;retry&quot;</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>再看DeleteOrphanedRecordsSteps类：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="nf">waitAndGetSatus</span><span class="o">(</span><span class="n">String</span> <span class="n">currentTime</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">status</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">MAX_TRY_TIME</span><span class="o">;</span> <span class="n">index</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">status</span> <span class="o">=</span> <span class="n">getJobStatus</span><span class="o">(</span><span class="n">currentTime</span><span class="o">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="s">&quot;COMPLETED&quot;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">status</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">break</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">WAIT_INTERVAL</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">status</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="nf">getJobStatus</span><span class="o">(</span><span class="n">String</span> <span class="n">currentTime</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">queryForObject</span><span class="o">(</span><span class="s">&quot;select jobExec.STATUS from TCIST_JOB_EXECUTION jobExec &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;inner join TCIST_JOB_PARAMS jobParam on jobExec.JOB_INSTANCE_ID = jobParam.JOB_INSTANCE_ID &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;and jobParam.KEY_NAME = &#39;time&#39; &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;and jobParam.STRING_VAL = ?&quot;</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">currentTime</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>比较这些方法，除了jobParam的key与value存在细微区别，其余实现完全相同。若按照这样一个态势发展，随着与Batch Job有关的Story逐渐增多，不发现这种代码的臭味并即刻解决，这些代码就会逐渐蔓延，最后变得“无法自拔”。想要修改，已经变得极为困难了。</p>

<p>我们为这些Steps类提供了一个抽象的超类AbstractBatchJobSteps，并将这些可能重用的方法提取到这个超类中：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AbstractBatchJobSteps</span> <span class="kd">extends</span> <span class="n">AbstractSteps</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">WAIT_INTERVAL</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_TRY_TIME</span> <span class="o">=</span> <span class="mi">30</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">protected</span> <span class="n">String</span> <span class="nf">waitAndGetSatus</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">params</span><span class="o">,</span> <span class="n">String</span> <span class="n">paraKey</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">status</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">MAX_TRY_TIME</span><span class="o">;</span> <span class="n">index</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">status</span> <span class="o">=</span> <span class="n">getJobStatus</span><span class="o">(</span><span class="n">params</span><span class="o">,</span> <span class="n">paraKey</span><span class="o">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="s">&quot;COMPLETED&quot;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">status</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">break</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">WAIT_INTERVAL</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">status</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="nf">getJobStatus</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">params</span><span class="o">,</span> <span class="n">String</span> <span class="n">paraKey</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">queryForObject</span><span class="o">(</span><span class="s">&quot;select jobExec.STATUS from TCIST_JOB_EXECUTION jobExec &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;inner join TCIST_JOB_PARAMS jobParam on jobExec.JOB_INSTANCE_ID = jobParam.JOB_INSTANCE_ID &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;and jobParam.KEY_NAME = &#39;&quot;</span> <span class="o">+</span> <span class="n">paraKey</span> <span class="o">+</span> <span class="s">&quot;&#39; &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;and jobParam.STRING_VAL = ?&quot;</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">params</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">paraKey</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上的例子都可以通过一些细小的重构手法改进代码，使得代码的结构更加清晰，并有利于代码的重用。我深信大多数开发人员都具备这样的技能，且只需要稍加思索，即能发现这些代码的坏味。然而，我们总是因为种种原因，对这种还不太严重的“破窗”风景视而不见。殊不知当我们开始对这种不够整洁的代码采取纵容态度时，就可能会是代码腐化之始。一旦真正腐化，就将积重难返，到了那时，我们就可能真正无能为力了。</p>

<p>你是否遭遇过这样的情形？面对一个承担了无数职责似乎无所不能的上帝类，它被无数多的Client调用，且又没有足够覆盖率的测试，你是否会产生心有余而力不足的感慨。这时的你，是否像一位奋战沙场，出生入死却无力挽回败局的将军，面对那汹涌而来占据压倒性优势的敌军，唯有对天长叹：“某有心杀贼，却无力回天啊！”</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用扩展方法实现重用]]></title>
    <link href="http://agiledon.github.com/blog/2013/06/16/reuse-with-extention-method/"/>
    <updated>2013-06-16T20:06:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/06/16/reuse-with-extention-method</id>
    <content type="html"><![CDATA[<p>我们已经有了一个IRepository接口，它提供了诸如BatchSave()，Insert()之类的方法。其中，BatchSave()方法接收一个由实体类组成的数组，从而完成对实体对象的批量存储。
<img class="center" src="http://agiledon.github.com/images/2013/06/IRepository.png"></p>

<p>对于单个实体对象而言，我们当然也需要有相关的方法来完成存储。它与BatchSave()的区别仅在于它要接收的参数只是一个实体对象。事实上，我们可以调用IRepository接口本身提供的BatchSave()来实现Save()方法。Save()方法的实现对于所有实现了IRepository接口的类而言，完全是一样的。那么，我们该如何为IRepository接口增加一个Save()方法，同时又能避免代码做出太多修改？由于接口自身并不能提供实现，因此唯一可以容纳这个方法实现的就是实现了IRepository接口的类。一个办法是为所有这些实现类定义一个公共的抽象父类，并让它再实现IRepository接口，于是将Save()的实现放到这个抽象父类中，就可以使得所有子类共享Save()方法的实现了。可是，为了这个Save()方法的实现与重用，专门引入一个抽象父类，是否值得呢？除非在现有的Repository继承体系中，已经存在了这样的抽象父类，否则该类的引入会导致整个继承体系发生较大的变化。</p>

<p>在.NET中，我们可以巧妙地借助扩展方法来完成对Save()方法的重用，同时又能保证现有的继承体系不变。方法就是为IRepository接口提供扩展方法：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">RepositoryExtensions</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Save</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IRepository</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">repository</span><span class="p">,</span> <span class="n">T</span> <span class="n">entity</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">repo</span><span class="p">.</span><span class="n">BatchSave</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span><span class="n">entity</span><span class="p">});</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[处理文件请求限制]]></title>
    <link href="http://agiledon.github.com/blog/2013/06/13/handle-the-limitation-of-requesting-file/"/>
    <updated>2013-06-13T21:29:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/06/13/handle-the-limitation-of-requesting-file</id>
    <content type="html"><![CDATA[<p>在我参与的一个项目中，遇见了一个结合功能性需求与非功能性需求，并要求同时满足的场景。它的功能其实很简单，就是需要向系统发出处理文件的请求。文件的处理则涉及到多个数据表的查询，对相关数据的解析，并依照事先设定好的模板填充数据，最后生成PDF文件。一旦文件处理完毕，就可以返回处理后的文件。由于该系统的业务特殊性，这一功能需求会在某个特定时间，迎来数以万计的客户请求。同时，文件处理功能是一个相对漫长的处理过程，且生成的文件较大。在系统的最初版本中，经历过数千人次的并发数，在只有一台服务器的情况下，导致了大量请求的阻塞。同时，由于加载文件和文件读写需要耗费内存，在请求较为频繁的情况下，多次抛出OutOfMemory异常。即使在最好的情况下，服务端响应了客户端请求，也可能花费大量的时间，严重影响了用户体验。</p>

<p>我们希望在后续版本中解决这一问题。然而，现实总是这么残酷。真正处理文件并提供下载功能的系统并不在我们的掌控之中。它是第三方Vendor提供的Web Service，我们开发的系统仅仅涉及到请求的转发，完成对该Web Service的调用；并在获得结果后，将响应（包含了文件流数据）返回给客户端。换言之，我们既不能改善文件处理的实现逻辑，以提高处理的速度；也无法对该Web Service进行水平伸缩，例如通过引入多台服务器建立集群和负载均衡的方式。</p>

<p>遭遇如此场景实属无奈，要得出好的设计决策就好似戴着镣铐跳舞，只有在自己的服务端下功夫。我们首先想到的是限流（throttle）的方式，通过引入一个类似Controller角色的对象RequestHandlerPool，对客户端的请求进行控制。我们可以设定一个阈值，一旦超过该阈值，就将后续的请求放入队列进行排队。这个限流可以采用简单地在内存实现请求池全局对象。当然，也可以考虑引入消息队列中间件。改进后的时序图如下所示：
<img class="center" src="http://agiledon.github.com/images/2013/06/filehandling.png"></p>

<p>引入RequestHandlerPool仅仅是对请求进行了限制，从而避免请求过多导致File Cabinet的阻塞，或者导致抛出OutOfMemeory异常。但整体的处理时间并没有得到任何改善。我们首先考虑将该功能分为两阶段。第一阶段是发起对文件的处理请求，第二阶段则是下载处理好的文件。对于耗时较长的文件处理请求，可以考虑使用异步请求，一旦文件处理完毕，就可以通过Callback通知请求者。然而，由于文件处理的时间过长，可能会导致请求者不愿继续等待结果，从而退出系统，形成一次失败的请求。因而，我们考虑系统的Callback可以通过发送邮件的方式通知发出请求的客户，在邮件内容中附带下载地址，以供客户下载。</p>

<p>纵观整个场景，存在太多制肘，我们也没有太多好的解决方案。而且，我们还应该保证这个解决方案足够简单，因为我们需要在尽量短的周期内对原有方案进行改善，以迎接新一期的业务高峰。这些限制不同于架构约束，它常常迫使我们在逼仄的空间中闪转腾挪。我们还必须尽快地实现方案的原型，并营造与真实业务场景相当的数据，对其进行压力测试和性能测试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ThoughtWorks读书雷达-架构设计篇]]></title>
    <link href="http://agiledon.github.com/blog/2013/05/13/architecture-and-design-of-reading-radar/"/>
    <updated>2013-05-13T20:41:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/05/13/architecture-and-design-of-reading-radar</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2013/04/reading_radar_02.png">
编码的能力与设计的能力，二者均不可偏废。我们认为，编码事实上是设计的一部分，只不过它更多的是以代码的形式来呈现，而设计则主要由模型来组成。这种设计模型有助于知识的传递与分享，同时也可以有效地提高编码质量。至于架构，则是软件系统中重要的事物，它关乎的内容往往是难以更改的。卓越的软件设计一定拥有美的架构，也能够有助于促进架构的演化。在ThoughtWorks，并没有明确的架构师职位。如果有，我们也希望这个角色应该是Martin Folwer认为的Architectus Oryzus，这些架构师与处理最困难部分的其他开发人员合作，积极地向项目贡献代码。显然，我们认为架构师也是程序员。这正是我们要在这个读书雷达中列出Architecture &amp; Design象限的原因。</p>

<p>整体概览本象限列出的书籍，若有相关读书经验的人一定会注意到，这里列出的书籍并没有脱离面向对象设计体系的范畴。我们认为，在当今的企业级软件开发领域中，面向对象的思想体系仍然占据了主要的地位。对于程序员而言，建立面向对象的设计思维仍然至关重要。但是，我们从来都不曾忽略函数式语言对设计领域带来的冲击，以及它可能产生的巨大影响。在<a href="http://www.thoughtworks.com/insights">最新的ThoughtWorks Technology Radar</a>的Languages &amp; Frameworks象限中，ThoughtWorks对Scala，Clojure，F#等函数式语言青睐有加，同时也谈到了在Java中引入高阶函数等函数式特性的Functional Java发展趋势。我们也注意到在2012年的DDD eXchange会议上，函数式语言对设计范式的转变产生的影响。遗憾的是，除了少量介绍具体函数式语言的书籍，我们很少看到如面向对象设计一般专门讲解与深入探讨函数式软件设计的书籍。与其滥竽充数，不如抱残守缺。我们选择了在这期读书雷达图中，让函数式设计范式集体缺席。</p>

<p>架构内容包罗万象，在这个象限中我们关注的书籍主要与架构本质内容相关，包括架构风格、架构模式和重要的架构设计原则。虽然云计算、大数据以及REST服务等相关技术已经成为架构师的必备知识，也诞生了许多优秀的书籍；但我们还是希望让这个象限的内容变得更内聚一些，从而帮助读者能够从中挑选出合适的书籍，组成学习架构与设计技能的读书路线图。或许，在将来我们希望引入Tools、Frameworks以及Platforms等更多的象限来囊括这部分内容。</p>

<!--more-->


<p>在Architecture &amp; Design象限的基础篇中，我们仍然选择设计模式作为面向对象设计能力提高的突破口。因此，我们将浅显易懂的Head First Design Patterns《<a href="http://book.douban.com/subject/1488876/">深入浅出设计模式</a>》作为学习设计模式的入门书。图文并茂以及与生活有关的设计案例可以很容易启发读者的阅读理解，快速地掌握设计模式的精要。我们唯一担心的是这样一本充斥着玩具项目的入门书籍，可能很难让读者将自己学到的设计思想运用到真实项目中。因此，我们强烈推荐Robert Martin的经典著作Agile Software Development《<a href="http://book.douban.com/subject/1140457/">敏捷软件开发</a>》。该书很好地总结了面向对象设计的SOLID原则，在设计理论上做到了高屋建瓴；同时又给出了丰富的更加贴近真实项目的案例来分析设计模式。</p>

<p>我们必须列入GOF的Design Patterns《<a href="http://book.douban.com/subject/1052241/">设计模式</a>》，不仅仅是因为本书对整个设计领域的影响力，还因为本书讲到的设计理念与原则，至今读来，内涵的真知灼见仍然熠熠生辉。我强烈建议读者仔细研读本书的第一章，几乎每一句话都值得我们深思。即使你曾经读过，我仍然建议你再次阅读。本书第二章给出的案例实在太精妙了，仿佛一件艺术品，虽为人工雕刻，你却看不到斧凿的痕迹。如此浓缩的两章内容，抵得上许多讲述设计模式书籍的千言万语。当然，从今天的视角来看，GOF提出的一些设计模式如今已经变得不合时宜；然而我认为，在你没有真正理解设计模式之前，请先闭上质疑的眼光，收回批判的言辞。</p>

<p>在Medium的层级，我们开始将目光投向更高层次的架构模式，这其中尤以Martin Fowler的著作Patterns of Enterprise Application Architecture《<a href="http://book.douban.com/subject/1230559/">企业应用架构模式</a>》为代表。该书围绕着分层架构模式，根据不同层次呈现出的不同特征，提炼出了在企业开发中得到广泛使用的模式。可以认为这是Martin Fowler给出的企业应用开发的最佳实践，以模式的形式告诉你在不同的场景下，你应该选择何种设计方案。书中的多数模式已经如设计模式一般深入人心，在某种程度上甚至可以作为设计人员的交流术语。换言之，倘若你不曾掌握这些模式，或许会失去在许多场景下说话的资格。</p>

<p>Eric Raymond的The Art of UNIX Programming《<a href="http://book.douban.com/subject/1467587/">UNIX编程艺术</a>》则从艺术的角度剖析了UNIX的编程哲学，使得我们明白软件设计其实并没有阵营之分，即使是面向过程的语言，也能做出优雅的设计。而且，面向对象设计中所有精华的设计思想与原则，其实都可以从UNIX的编程哲学中找到，例如使用简洁的接口拼合简单的部件，清晰胜于机巧，策略同机制分离，设计追求简洁，健壮源于透明与简洁。愿本书能够开拓你的设计视野。</p>

<p>Jaroslav Tulach的Practical API Design《<a href="http://book.douban.com/subject/6003832/">软件框架设计的艺术</a>》则从框架的角度讨论了如何针对API进行实效主义的设计。这在一定程度上弥补了软件设计技术书籍在API设计方面的空白。本书对于API与SPI的讨论，对模块化设计的分析，尤其是来自于NetBeans框架产品版本演化的实践经验，都是非常重要的设计知识。</p>

<p>在Architecture &amp; Design象限中，放入Martin Fowler的Domain Specific Languages《<a href="http://book.douban.com/subject/21964984/">领域特定语言</a>》似乎有些突兀，或许它更应该放入Coding Practice象限。然而，我们认为掌握领域特定语言在一定程度上可以改进我们的设计，尤其是API的设计。无论是内部DSL还是外部DSL，必然会涉及到如何合理设计语言，这其中蕴含了精妙的设计思想。看看书中对状态机以DSL风格进行的分析，阐释各种解析表达式树的算法，讨论如何设计分离更有利于重用和测试，这其中又包括了对语义模型的提炼与分析。无疑，这是一本DSL的集大成之作，但如果我们仅仅将其范围局限在语言层面，你可能会错失对Martin Fowler深邃的设计思想领悟的机会。</p>

<p>入选Advanced层级的书籍除了Eric Evans的Domain Driven Design《<a href="http://book.douban.com/subject/1629512/">领域驱动设计</a>》，均与软件架构直接相关。我们尤其尊重《领域驱动设计》一书在设计领域的开创与先驱地位，它提出的以领域为核心，以建模为手段的设计方法学，为设计业务复杂的大型企业级软件提供了具有实践意义的方法体系，进而催生了领域驱动设计。书中提到的诸多概念包括Entity、Value Object、Repository、Aggregation、Bounded Context，已经成为了设计知识的专用术语。我们强烈推荐此书，是因为对于程序员而言，只要你逃避不了对业务领域的分析与建模，就不能绕过领域驱动设计。</p>

<p>以五卷本的系列著作来阐述软件架构模式，可见作者的宏伟决心以及对架构设计驾轻就熟的能力。我们认为，在模式领域里，以Frank Buschmann为主要贡献者的Pattern-Oriented Software Architecture《<a href="http://book.douban.com/subject/4848563/">面向模式的软件架构</a>》系列对软件设计领域带来的影响巨大而深远。这个系列虽然都是讲解架构模式，但各有其特色，关注点也有不同，分别涵盖了通用架构模式、并发模式、资源模式、分布式模式与模式语言。阅读这一系列确实需要读者下定一百万分的决心，若你不愿意通读，那么它也可以成为很不错的架构模式参考书籍。我们相信，你在软件设计中可能会遭遇的大多数设计场景，都能在本系列中找到对应的架构模式，从而作为设计方案的重要输入。</p>

<p>在Pattern-Oriented Software Architecture系列中，虽然介绍了分布式系统的架构模式，但关于系统集成包括消息处理等内容却显得不够深入和详尽，这是因为已有一本优秀著作专美于前，即Gregor Hohpe与Bobby Woolf的Enterprise Integation Patterns《<a href="http://book.douban.com/subject/1766652/">企业集成模式</a>》。本书关注企业级软件系统的本质问题，那就是集成。对于采用异步消息传递的集成方案，本书针对不同场景给出了不同的解决方案，并以模式的方式进行概述与归纳。倘若你在设计软件系统时，需要使用异步消息传递的方式对系统进行集成，本书可以成为你的最佳指南。</p>

<p>如果将《领域驱动设计》视为应对领域复杂性的解决之道，Michael Nygard的<a href="http://book.douban.com/subject/2065284/">Releast It!</a>则可以看做是处理软件系统质量属性的治病良方。本书常常会以一个具体的实例开始阐述某一个质量属性的关键性，并列出一系列的反模式作为参照和对比，最后再给出正确的模式列表。这种针对问题的叙事方法，使得读者往往能够照方抓药，又因为模式的叙述如此清晰而规范，所以常常能药到病除。正如本书书名所指，这些内容确乎与软件的发布息息相关。</p>

<p>最后一本推荐书籍看似有些大杂烩，实则是大家云集的架构师合唱团，可谓架构的盛宴，那就是Till Adam编著的Beatiful Architecture《<a href="http://book.douban.com/subject/4086029/">架构之美</a>》。全书涵盖的内容广博而宏大，涵盖了架构基本原则、企业级应用架构、系统架构、最终用户应用架构、语言与架构，分列为本书的五大部分，读之会让人产生目不暇接之感。尤其对于术有专攻的程序员来讲，要彻底吃透本书讲解的内容，无疑是一项艰巨的挑战。然而，如果从架构师所必须具备的技能来看，本书的内容其实并没有超出架构的范畴，因为架构师必须要见识广博，你才能针对不同的需求场景，面对不同的实现技术，选出最适合当前场景的恰如其分的架构方案。当然，在阅读时，千万不要在太多的技术细节中迷失自己，关键还是要把握美丽架构的基本原则。而这正是本书的主线，使得本书能够在散乱的主题中，还能做到“形散而神不散”。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Struts 1.x一路走好]]></title>
    <link href="http://agiledon.github.com/blog/2013/05/08/farewell-struts-1-dot-x/"/>
    <updated>2013-05-08T22:38:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/05/08/farewell-struts-1-dot-x</id>
    <content type="html"><![CDATA[<p>因为Struts 1.x宣布退出了历史舞台，于是InfoQ组织了一次虚拟访谈。恰好在我现在的项目中，仍然能够看到Struts 1.x的身影，以我这浅薄的Web开发经验，也能有幸被丁雪丰邀请参加了这次虚拟访谈，和李锟、张龙就这一事件畅谈了各自的感受和想法。这篇<a href="http://www.infoq.com/cn/articles/virtual-panel-struts1?utm_source=infoq&amp;utm_medium=popular_links_homepage">虚拟访谈</a>发表在了InfoQ上。这里发布的则是我自己就主持人提出的问题给出的回答。</p>

<p><strong>1. Struts是最早的MVC框架之一，影响了很多人，你是否还记得最早接触到它时，给你留下的印象是什么？</strong></p>

<p><strong>张逸：</strong>从业15年来，我主要参与的开发工作除了早期的Windows Form应用开发外，主要还是集中在后端。用分层的角度来说，即工作在数据层、领域层以及服务层。虽然早已知道Struts的大名，甚至了解到所谓Struts+Spring+Hibernate几乎成为了Java企业开发的标配，却一直没有机会使用Struts。我当时工作的项目主要还是在微软的.NET平台上，经历了从ASP到ASP.NET，再到ASP.NET MVC的过程。在使用ASP时，我很质疑那种业务代码与表现代码混杂在一起的开发方式；而在最初拥抱ASP.NET时，我认为这种Code-Behind会是一种良好的职责分离。然而，ASP.NET在灵活性或扩展性方面带来的约束，使得它越来越不适合富客户端的开发了。于是，才有了借鉴Ruby On Rails思想的ASP.NET MVC出现。或许我的回答偏题了，但我想借ASP的这种发展来看待此次Struts 1.x退出历史舞台的事件，那就是任何产品都会步入晚年的衰落期，跟不上技术的发展，必然会被淘汰，没有什么好奇怪的。</p>

<!--more-->


<p><strong>2. Struts 1.x即将走完最后的历程，对于那些仍在使用它的系统，你有什么建议？如果要升级，有几个备选方案，例如Struts 2.x、Spring MVC等等，你会如何选择？</strong></p>

<p><strong>张逸：</strong>奇怪的是，虽然在早期我不曾有机会使用Struts 1.x，然而我现在正在工作的一个大型项目，因为其漫长的历史，一部分Web前端使用的正好是Struts 1.x。对于这种正在使用它的系统，若要说有何建议，简言之，还是需要在决策时视情况而定。在我们当前项目的一个子系统中，Struts 1.x是与Spring MVC 2.0共存的；而在另一个子系统中，又存在Struts 2.x与Spring MVC 3.x共存的情况。从架构的一致性来看，这是很不合理的；然而就项目的真实情况，我又认为这种现象未尝不可。迁移的成本往往是昂贵的，尤其对于遗留系统而言，若没有覆盖率极高的验收测试，盲目地为了追求架构一致性进行迁移，反而会引入新的问题。这就需要权衡迁移的成本和迁移得到的好处。在Java平台下，可供选择的成熟Web框架并不多，Struts 2.x以及Spring MVC相较于Struts 1.x而言，主要还是体现在模式上的区别，属于侵入性更小、架构更为简单的框架。相对于升级，我更倾向于保留原有框架，对于新增的功能则可以引入更新的框架。若因为种种原因硬要升级，我更倾向于选择Spring MVC，一方面它与Spring框架的集成度更好，学习曲线低；同时它对于Struts 1.x实现方式的固有支持，会使得迁移的成本会降低。最重要的一点是Spring MVC目前还保有一定程度的活力，它的版本还在演化中；相对而言，Struts似乎已经失去活力了。</p>

<p>若抛开这些成熟的Web框架不谈，我的建议是不妨试试Java平台下的其他框架，例如jRails，Spring Roo、Apach Wicket或者Play。若想继续工作在Spring的技术栈下，Spring Roo会是一个有趣的选择。事实上，你可以认为它是Spring所要力推的下一代Web框架，如果你不想重蹈Struts 1.x的覆辙，可以在决策时冒着风险给予提前尝鲜的机会。Play框架是基于Java和Scala开发的Web框架，它似乎更偏重于建造可伸缩性的Web框架。此外，它的安全模块、持久化支持(包括对NoSQL与Big Data的支持)、RESTful以及Mobile的支持，使得它更适合开发当今的Web应用程序。</p>

<p><strong>3. 经常会有框架或软件结束生命周期，不再进行维护，这对使用它的用户多多少少带来了一些困扰，能否聊聊您在项目最初进行选择时的一些经验之谈。</strong></p>

<p><strong>张逸：</strong>对于框架的选择，我比较偏重于框架的简单性和无侵入性这两个特点。简单性可以保证我们快速地理解框架的架构，并能够正确地使用它；无侵入性则使得我们可以避免所谓“供应商锁定”的反模式，在需要迁移框架时，可以尽快摆脱原有框架的约束。当然，这种选择总要结合项目需求，根据风险对各种质量属性进行综合权衡，方能做出合理的设计决策。因此，我会将这两个特点看做是重要的衡量指标，但并非绝对。在一定程度上，我们还可以通过更好的架构设计来规避对框架的依赖，例如通过好的分层设计，或者引入防腐层隔离对框架的依赖。以Struts 1.x而言，只要我们避免在Action中引入业务逻辑，选用新Web框架的成本就会更低一些。同时，保证足够的测试覆盖率是必要的，尤其是足够覆盖率的单元测试与集成测试，它常常可以放缓系统衰老的脚步。对于旧系统的维护或重构而言，测试覆盖率是进行改造的良好基石。</p>

<p><strong>4. 随着像Backbone.js这样的前端MVC框架的流行，Struts这样的服务器端MVC的作用似乎有所减弱，您觉得MVC逻辑“前移”会是今后的发展趋势么？</strong></p>

<p><strong>张逸：</strong>我完全赞同这一点。在我参与的上一个项目中，对于服务端的Web层而言，几乎就成为了一个Controller+JSON+REST的组合，MVC中的M被JSON或资源所替代，V则干脆消失了，由Controller来负责必要的服务端验证，并完成HTTP请求的路由功能，其余的前端逻辑都交由我们当初选择的ExtJS了。</p>

<p>这种设计是完全合理的。但我仍然要说明一点的是，这种设计由于加大了前端的复杂度，因而需要我们更加关注前端的代码质量。传统开发要求的关注点分离、松耦合与高内聚原则同样适用于这样的前端代码。虽然不一定要提倡前端代码的测试驱动开发，但至少要保证这些代码具有足够的测试覆盖率。例如，我们可以为Javascript（或者jQuery)引入Jasmine，QUnit等测试框架。在我的同事曾经参与的一个项目中，由最初只支持一个品牌，增强到支持多个品牌的需求变化，这其中需要涉及到对大量前端代码的复用。由于之前的设计并未考虑到多品牌的支持，因而需要重构前端代码，以达成复用的目的。如果没有足够的测试覆盖率，以及良好的职责分离，要做到这一点的难度不言而喻。</p>

<p>我还提到，前端的许多模式事实上都是从MVC模式衍生而来，例如MVP，MVVM等。此时，MVC可以作为核心模式的一个名词。应该为那些变种的模式命名，并给出最佳实践，从而表达特定的含义。对于这种服务端与客户端结合起来共同协作的模式，可以命名为MC2MVC，或者RC2MVC。有个“2”，就表示从服务端到客户端的意思。至于RC2MVC，则是为了强调服务端提供的“资源”，而非传统意义上的模型。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从Go语言的设计学习设计决策]]></title>
    <link href="http://agiledon.github.com/blog/2013/05/04/design-decision-learning-from-go/"/>
    <updated>2013-05-04T21:12:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/05/04/design-decision-learning-from-go</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2013/05/decision.jpg">
阅读了Rob Pike撰写的《<a href="http://www.oschina.net/translate/go-at-google-language-design-in-the-service-of-software-engineering">Go在谷歌：以软件工程为目的的语言设计</a>》，颇多感触。这些感触并不在于语言层面，或者Go这门语言的语法以及底层实现；而是因为语言设计者们在设计Go这门语言时，做出设计决策的合理性以及基于的事实与根据。正如此文标题所言，显然，Go的创造者们从一开始就树立了准确的愿景与目标，并且清晰地确定了该语言的适用场景，即它需要解决“由多核处理器、系统的网络化、大规模计算机集群和Web编程模型带来的编程问题”，这是理解这门语言，进而明确其设计意图的最根本所在。</p>

<p>刚刚参加了公司八叉大神组织的轮子大赛，我们写了一个轻量级的IoC容器<a href="https://github.com/agiledon/melt">Melt</a>。就这个容器或者说框架本身，和八叉讨论了框架设计的特点。他提到“framework开发和功能开发的一个最大分别就在于，你需要规定在这个framework里那些是支持的，哪些是不支持的。这条线要你自己来划，或者说你的framework要有态度。”这是我非常认同的观点。Framework要有态度，这意味着你在践行并且在引导一种最佳实践。或者我们可以理解为这是一种架构的约束。我们都知道，在软件设计中，如果没有任何约束，带来的问题反而会更大。约束是一种驱动力，例如我们需要可伸缩性的约束，就需要我们设计的服务不应该是有状态的。框架的态度大意如此。</p>

<p>回过头来看这篇文章介绍的Go设计理念，无时无刻不是在体现设计者施加在这门语言身上的态度。必须注意，这种态度或者说设计理念又绝对离不开这门语言的设计愿景。若是脱离这种具体场景来看Go语言，或许有众多不合理之处，但我们并不能依此妄加论断。正如话剧演员在舞台上的表演，总带着几分略带夸张的表情与语气，我们却不能指责这种表演不够生活化。当我们在思考一个设计决策是否合理时，是否参考了当时的场景做出判断呢？进一步讲，当我们自己在进行设计决策时，又是否充分地考虑了具体的场景呢？例如，Go语言之所以采用C语言风格的花括号，其考量并非简单地延续C语言风格那么简单，在前面提及的愿景的大前提下，设计者必须考虑如果使用Python或Haskell风格的空格缩进，对于大规模程序而言，可能会造成太多的问题。如文中所云：“我们的观点是，虽然空格缩进对于小规模的程序来说非常适用，但对大点的程序可不尽然，而且程序规模越大、代码库中的代码语言种类越多，空格缩进造成的问题就会越多。为了安全可靠，舍弃这点便利还是更好一点，因此Go采用了花括号表示的语句块。”</p>

<!--more-->


<p>再看Go语言的依赖处理，它施加了一个看似比较独裁的约束，即“不允许其依赖图中有循环性的包含关系，编译器和链接器都会对此进行检查以确保不存在循环依赖”。设计者并不否认循环依赖存在一定的价值，然而在大规模程序的前提下，它带来的问题远远超过了可能存在的价值。文中提到：</p>

<blockquote><p>循环依赖要求编译器同时处理大量源文件，从而会减慢增量式build的速度。更重要的是，如果允许循环依赖，我们的经验告诉我们，这种依赖最后会形成大片互相纠缠不清的源代码树，从而让树中各部分也变得很大，难以进行独立管理，最后二进制文件会膨胀，使得软件开发中的初始化、测试、重构、发布以及其它一些任务变得过于复杂。</p><p>不支持循环import偶尔会让人感到苦恼，但却能让依赖树保持清晰明了，对package的清晰划分也提了个更高的要求。就象Go中其它许多设计决策一样，这会迫使程序员早早地就对一些大规模程序里的问题提前进行思考（在这种情况下，指的是package的边界），而这些问题一旦留给以后解决往往就会永远得不到满意的解决。</p></blockquote>


<p>显然，Go语言的设计者并不是要设计一门大而全，兼容并包的全能语言，它严格而合理地压制着设计时可能膨胀的欲望，不与设计愿景相悖，并时刻从工程学的角度看待设计。设计一门语言如此，开发一个产品或项目更应如此。例如对于产品而言，当下流行的Lean Startup对于产品的理念，正是这种实效的工程主义。MVP（最小可验证产品）的划分将精简与避免浪费做到了极致，严格避免功能盲目的扩大化。</p>

<p>Rob Pike还提到：“在依赖关系方面保持良好状况要比代码重用重要”，甚至支持“为了使用一个函数，把所需的那一小段代码拷贝过来要比拉进来一个比较大的库强”。虽然我们在设计与开发时，常常会严格遵循DRY原则，同时也尽可能地追求重用，因为我们知道重复其实是一种“恶”。若要最大限度地重用，就必须保证实体的细粒度。从类级别来讲，粒度越细，就意味着类的数量越多，这可能会加大系统的复杂度。Kent Beck提出的简单设计中，第四条即为保证类的数量尽可能少。整体结合来看，实质是指在没有看到重用以及变化的征兆前，应尽可能避免类的数量被无谓地扩大。熊节将其概述为“如无必要，勿增实体”，非常准确。显然，细粒度的类虽然可以在重用上带来好处，但却可能使得系统变得更复杂。细粒度的类还在可控制的范畴，因为我们可以采用一些方式例如Facade或Mediator模式来简化或隐藏多个细小类之间的协作。然而，对于模块（指物理模块）层面来讲，粒度过细的模块会导致对依赖的管理变得复杂。我曾经在一个.NET项目中看到过多达100多个程序集，若尝试在Visual Studio中为其生成依赖图，可能会耗尽内存。而且这些细粒度的程序集，也会导致本地构建时间的增长。关于.NET项目中依赖管理的问题，Patrick Smaccla的文章《<a href="http://www.infoq.com/cn/articles/NDepend">避免在.NET代码中出现不恰当依赖</a>》有详细论述。然而，若是不能保证模块的细粒度，根据Robert Martin提出的共同复用原则，则可能导致即使是对一个细小功能的重用，也需要引入对整个包的依赖。</p>

<p>看来，我们有必要正视依赖与重用之间存在的鱼与熊掌不可兼得的问题。我的意见是当出现此类问题时，我们可以考虑职责分配上是否出现问题。如果模块的分解遵循了“高内聚”原则，可能此类依赖就只会发生在模块的内部。另一种思路是考虑我提出的所谓“依赖的沉淀”，即随时绘制组件图或包图，清晰地标明依赖的关系和方向，并根据权值来判断该模块应该位于纵向的物理分布层级的哪一层。具体细节可参考我写的一篇文章《<a href="http://agiledon.github.io/blog/2013/03/03/assigning-responsibility-between-modules/">模块间的职责分配</a>》。</p>

<p>文中还提到了Go语言故意缺失的一个特性就是不支持缺省参数。设计者认为：</p>

<blockquote><p>缺省参数太容易通过添加更多的参数来给API设计缺陷打补丁，进而导致太多使程序难以理清深圳费解的交互参数。默认参数的缺失要求更多的函数或方法被定义，因为一个函数不能控制整个接口，但这使得一个API更清晰易懂。哪些函数也都需要独立的名字， 使程序更清楚存在哪些组合，同时也鼓励更多地考虑命名&#8211;一个有关清晰性和可读性的关键因素。</p></blockquote>


<p>姑且不谈这一设计的驱动因素是否可取，这里显然教会了我们在软件设计时应该懂得如何去权衡。权衡的能力是架构师必备的技能，就好像老婆和老妈同时落水了，你该去救哪一个，这个命题总是让人不舒服，因而不肯回答。说来简单，在进行设计决策时，如果要权衡多个指标，一定要以最重要的哪个指标为主。问题是当我们不知道哪个指标更重要时，应该怎么办？我想，答案还是应该从愿景中去寻找。根据Go语言的愿景，对于大规模程序而言，清晰易懂的API会降低维护成本，并在一定程度上保障软件的质量，这显然比API的兼容性更为重要。</p>

<p>Go语言对于可见性的设计非常漂亮，“名字自己包含了可见性的信息，而不是使用常见的private,public等关键字来标识可见性：标识符首字母的大小写决定了可见性。如果首字母是大写字母，这个标识符是exported(public); 否则是私有的。”最初看来，这样的约定非常怪异，可是仔细琢磨，你不觉得通过这样一个简单的约定，让程序一下子变得精简了许多吗？其实只要明确了这一约定，代码的可见性仍然是清晰可知的。从某种程度讲，甚至比显式地声明public或private更加清晰。</p>

<p>Go语言对于继承的处理也显得特立独行，因为在Go语言中，没有类型层级（type hierarchy）的概念。它选择了组合而非继承，在于它对继承滥用表达了足够的忧虑和担心。作者认为：“类型层次结构这种模型会促成早期的过度设计，因为程序员要尽力对软件可能需要的各种可能的用法进行预测，不断地为了避免挂一漏万，不断的增加类型和抽象的层次。这种做法有点颠倒了，系统各个部分之间交互的方式本应该随着系统的发展而做出相应的改变，而不应该在一开始就固定下来。”我对此持保留意见，但在支持接口的前提下，这种规避继承的做法，仍有可取之处。因为接口可以支持OO中多态的特性，而组合又能保证逻辑的重用。这意味着，继承给我们带来的好处已经找到了合理的替代品。</p>

<p>Go抛弃了大多数传统语言所支持的异常机制，而转而使用error。这种机制建立在一个前提，即Go语言支持多个返回值。倘若像Java、C#等多数语言那样，仅支持一个返回值，则异常机制就变得完全有必要了。鉴于对多返回值的支持，且Go中的error又是抽象的接口类型，这样的设计就变得合乎情理了。</p>

<p>我们注意到Go语言中一些与众不同的特征，其实皆为设计者设计理念的体现，从中我们可以看到设计者做出设计决策的依据。显然，这些决策皆围绕着最高的设计愿景，并结合实际的工程场景，在通过合理权衡的前提下做出的。这种决策之道，值得软件架构师与设计师借鉴。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ThoughtWorks读书雷达-编码实践篇]]></title>
    <link href="http://agiledon.github.com/blog/2013/04/27/coding-practice-of-reading-radar/"/>
    <updated>2013-04-27T16:03:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/04/27/coding-practice-of-reading-radar</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2013/04/reading_radar_01.png">
期望通过四分之一的读书雷达图就能将与编码实践有关的优秀书籍一网打尽，自然是不现实的打算。因此，我们希望就我们的侧重点来推荐书籍。对于编码实践而言，我们共同认为培养良好的编码习惯，编写整洁简单而又合理的代码，是一名好程序员的基本要求。因此，这里我们更强调与程序员基本编码技能相关的知识。我们并没有给出与算法直接有关的书籍，虽然我们认为算法知识同样属于编码实践的范畴，虽然我们认为诸如《计算机程序设计的艺术》、《编程珠玑》、《算法导论》之类的书籍同样很重要很优秀；然而，我们取舍再三，仍然将它们划出了读书雷达的范围。我们认为：算法知识更应该划定到大学教育的范畴，若工作需要，则又偏向于更为专精的领域，并不适合读书雷达这种普适性的推荐。相对于具体的算法，或许我们更看重程序员的逻辑思维以及抽象建模的能力。</p>

<p>在Coding Practice象限的Fundamental圈中，我们强烈推荐了Robert Martin的Clean Code《<a href="http://book.douban.com/subject/4199741/">代码整洁之道</a>》与<a href="http://book.douban.com/subject/6114900/">The Clean Coder</a>《<a href="http://book.douban.com/subject/11614538/">程序员的职业素养</a>》，以及Martin Fowler的Refactoring《<a href="http://book.douban.com/subject/4262627/">重构：改善既有代码的设计</a>》。我不知道有多少人是阅读了Clean Code之后，才开始自己的整洁代码之旅；至少在我身边，这样的例子不胜枚举。把代码写成像散文那样美好，不仅仅是对美学的追求，更重要的是它能够极大地降低维护成本。在某种程度上讲，代码可以说是软件系统的质量基石。虽然重构的重要性被一直不断地提起，但我们发现真正掌握了重构手法的程序员，仍然屈指可数。通过对Refactoring一书的阅读，弄清楚什么是代码的坏味道，继而运用正确的重构手法，就能保证代码足够的整洁，甚至优雅。Robert Martin的另一本书Clean Coder与Clean Code一字之差，内容却大相径庭。它更多地是对程序员自身修养的关注。我们之所以强烈推荐它，并将其放入Fundamental圈中，是因为它介绍的知识，能够有效地帮助新入职场的程序员从一开始就能建立良好的编码习惯与意识。我们认为，这种好的习惯与意识，甚至比掌握某种开发技能显得更为重要。</p>

<!--more-->


<p>我们仍然要推荐Kent Beck的Test-Driven Development By Example《<a href="http://book.douban.com/subject/1230036/">测试驱动开发</a>》以及Andy Hunt的Pragmatic Unit Testing《<a href="http://book.douban.com/subject/1239651/">单元测试之道</a>》，固然源于我们对测试驱动开发以及提高单元测试覆盖率抱有强烈的热忱，还在于我们认为目前中国软件开发的现状，测试不足仍然是普遍现象。姑且不谈测试驱动开发的优劣，至少我们认为这种测试驱动的理念对于提高开发与设计质量颇有可观之处。我们也看到了太多测试不足的遗留系统，在希望通过重构来改善结构时的举步维艰。我们还选择了Neal Ford的著作The Productive Programmer《<a href="http://book.douban.com/subject/3558788/">卓有成效的程序员</a>》，它与Robert Martin的The Clean Coder颇有相似之处。我们喜欢本书的理由在于，如果我们能践行该书提到的方法与理念，确乎能够提高我们的开发效率，成为一名高效的程序员。我们一直认为中国的读者低估了本书的重要性，是因为该书涵盖的理念，其实可以扩充为好几本高文厚册。对于书中提到的设计原则，我们不是了解得太多，而是太少。选入Dustin Boswell等人的著作The Art of Readable Code《<a href="http://book.douban.com/subject/10797189/">编写可读代码的艺术</a>》，主要因为该书讨论的可读性代码，包含了Clean Code没有涉及的其他语言，例如C++、PHP、Javascript。要写出可读性良好的代码，了解多种语言是有必要的，且不同语言的编码风格总有不同之处。</p>

<p>对于Medium层次的程序员而言，我们希望能开拓程序员的眼界，至少要将编码实践的技能纳入到整个软件开发生命周期中。因此，我们推荐了David Thomas与Andy Hunt的著作The Pragmatic Programmer《<a href="http://book.douban.com/subject/1152111/">程序员修炼之道</a>》以及Steve McConnell的著作Code Complete《<a href="http://book.douban.com/subject/1477390/">代码大全</a>》。这两本书都获得了广泛的赞誉，前者是对程序员综合技能的整体梳理，后者则是对软件开发过程的高度提炼。The Pragmatic Programmer一书既有战略层面的思想与决策，又有战术层面的技巧与招式。整体而言，它提供了程序员修炼的法则，努力遵循这些法则，你就有机会成为编程专家。Code Complet则为我们展示了一幅巨细无靡的软件开发画面，牵涉到了架构、设计、编码、测试、构建等诸多内容，内容全面但并不肤浅。唯一不足之处在于，它实在太厚了。</p>

<p>Kent Beck的Implementation Patterns《<a href="http://book.douban.com/subject/3324516/">实现模式</a>》提到的模式，似乎更近于惯用法与设计模式之间。Kent Beck是真正将Java与设计精髓吃透，并能编写出好代码的大师，他的著作总是显得那么睿智而又简练，内容直指本质，没有多余的废话。我们要强烈推荐本书的理由只是因为它的内容太精彩了，尤其对于Java程序员而言，你需要再三阅读。我们还将Joshua Kerievsky的Refactoring to Patterns《<a href="http://book.douban.com/subject/1917706/">重构与模式</a>》放到了这个象限，是因为我们更愿意从编码以及重构的角度去看待设计。本书填补了Martin Fowler著作的空白，书中介绍的重构手法与设计理念，可以帮助我们更好地理解何谓“简单设计”，时刻警惕“过度设计”的陷阱。</p>

<p>我们之所以将Michael Feathers的著作Working Effectively with Legacy Code《<a href="http://book.douban.com/subject/2248759/">修改代码的艺术</a>》放到Coding Practice的Advanced圈中，是因为我们充分考虑了遗留代码的复杂性。面对这种复杂性，不能仅仅靠纸上谈兵的方式，寄希望于书中介绍的手法就能处理这些纠缠不清的糟糕代码。因此，我们认为阅读本书的前提是具有相当的处理遗留代码的经验，至少曾经经历过那种无从下手的茫然。当然，我们也不能狭隘地根据书名得出结论，认为这本书专为遗留代码服务。书中介绍的诸多解除依赖的技术，事实上也可以作为通用的设计手法。</p>

<p>在Coding Practice象限中，我们唯一推荐了一本似乎与工程实践无直接关联的书籍，即Harold Abelson与Gerald Jay Sussman的著作Structure and Interpretation of Computer Programs《<a href="http://book.douban.com/subject/1148282/">计算机程序的构造和解释</a>》(即SICP)。作为MIT（曾经的）计算机系第一门编程课的教材，这本书没有像诸多基于C或者Java的编程入门教材那样纠结于语法和库——LISP的语法确实也没什么可以纠结的。本书讲的是一些最基本的问题，比如什么是计算、什么是抽象、什么是模块化、乃至什么是时间和什么是自然数。一个以软件开发为业的程序员，或早或晚终归要想透这些问题，然后才能看破各种琳琅满目的编程语言所提供的五花八门的语法糖，以不变应万变地坦然面对一切不涉及并发的程序设计问题。把这本书当做第一本编程教材或许有些激进（MIT也已经不再这样做），但你早晚会遇到它。有人不无夸张但相当在理地说：自SICP以降，【无并发的】编程没有任何新鲜问题；如果你觉得自己有了新发现，要么是SICP已经写过只是你不知道，要么是你想错了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[遗留系统的技术栈迁移]]></title>
    <link href="http://agiledon.github.com/blog/2013/04/24/technical-stack-migration-for-legacy-system/"/>
    <updated>2013-04-24T17:55:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/04/24/technical-stack-migration-for-legacy-system</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2013/04/legacy.png">
什么是遗留系统（Legacy System）？根据维基百科的定义，遗留系统是一种旧的方法、旧的技术、旧的计算机系统或应用程序[1]。这一定义事实上并没有很好地揭露遗留系统的本质。我认为，遗留系统首先是一个还在运行和使用，但已步入软件生命周期衰老期的软件系统。它符合所谓的“奶牛规则”：奶牛逐渐衰老，最终无奶可挤；然而与此同时，饲养成本却在上升。这意味着遗留系统会逐渐随着时间的推移，不断地增加维护成本。</p>

<p>维护一个软件系统，就需要了解该软件系统的知识。若知识缺失，就意味着这会给维护人员带来极大的障碍和困难。从这个角度讲，所谓“遗留系统”，就是缺少了一部分重要知识，使得维护人员“知其然而不知其所以然”的软件系统。</p>

<p>若要让遗留系统焕发青春，最彻底的做法自然是推倒重来，但这样付出的代价太高；而且，即使对系统重新设计和开发，仍然免不了会重蹈遗留系统的覆辙。或者，可以对遗留系统进行重构，在不修改系统功能的情况下改善系统设计。只是这种重构常常是对系统进行重大扩展或修改的前奏，如无绝对必要，并不推荐这种偿还“技术债务（Technical Debt）”的方式。重构应与开发同时进行，而不应将其作为债务推迟到最后，以至于支付高昂的利息。最后，还有一种方式，则是对遗留系统进行技术栈迁移。<!--more--></p>

<h3>一. 决策技术栈迁移的因素</h3>

<p>那么，为何要进行技术栈迁移呢？是否是原有技术无法满足新的业务需求？对于遗留系统而言，这种情况总是存在，即需要扩展旧有系统的功能来满足新的业务。然而，这一原因并不足以支持做出技术栈迁移的决策。因为，从技术实现的角度来看，无论采取何种技术，都可以实现各种业务功能，无非是付出的成本不同而已 。基本上，这种成本一定会低于技术栈迁移的成本。此外，当今的软件开发，常常会将一个软件系统看做是完整的生态系统，在这个生态系统圈中，完全允许有多种技术平台（包括多种语言，甚至多种数据库范式）存在，只要我们能够合理地划定各个功能（或服务）的边界。</p>

<p>牵涉到架构中的任何一个重大决策，都需要综合考量和权衡，只有充分地识别了风险，才能制订有效的设计决策。个人认为，只有在如下几种情形出现时，才值得进行技术栈迁移。</p>

<h4>原有技术不能保证新的质量需求</h4>

<p>在一个系统的完整生命周期内，系统从诞生到发展，衰老和死亡，与人一样，是不可规避的过程。对遗留系统进行技术栈迁移，无非是希望通过新的技术给旧有系统注入活力，就像器官移植一般，对腐朽的部分进行切除与替换。系统之所以会衰老，会腐朽，原因还在于需求的变化，从而导致系统结构变得庞大而混乱。我们在进行技术决策时，常常是根据当下的需求以及目前现有的技术，结合团队技术能力做出的最符合当时场景的合理决策。因而，技术栈迁移的原因常常是是因为“此一时彼一时”。在当时场景下做出的明智决策，随着时间的推移，会显得不合时宜。这一点在质量需求的满足上，体现得尤为明显。例如，系统对可伸缩性、性能、安全的要求，都可能因为新的质量需求的提出发生变化。而这些质量属性往往靠旧有技术无法解决。RackSpace对日志处理的案例就属于这一场景[2] 。RackSpace的架构对日志的支持，先后经历了三个大版本的演化，从文件服务器到中心数据库，再到MapReduce，每次技术栈的迁移都是质量属性的驱动，不得不为之。</p>

<h4>出于战略的考虑</h4>

<p>这常常是因为企业架构的因素。对于一个企业而言，应该将其IT系统看作是一个整体的生态系统。对于一个正在成长中的企业而言，必然会随着整个企业组织结构、业务体系的变化而影响到IT系统。一般而言，企业IT系统的架构会存在两种情况。第一种情况是从无到有，根据企业架构师与业务架构师的设计，严格按照设计蓝图来规划所有的IT系统。第二种情况则可能是多种不同的系统并存（可能是因为企业采用了并购等方式兼并其他公司业务，也可能是因为不同的业务需要，购买了不同的软件系统）。第一种情况看似美好，但仍有可能发生规划蓝图不能满足需求的可能。第二种情况则处于龙蛇混杂的局面，最后可能导致所谓的“烟囱系统（Stovepipe System）[3]”，需要花大力气对各种系统进行整合。</p>

<p>无论是哪一种情况，一旦做出技术栈迁移的决定，都必然是企业战略上的考虑。当然这种战略指的是IT战略，也可能是企业的整体战略对IT系统产生影响。</p>

<p>我们的一个客户是一家大型的金融企业，提供了多种品牌的保险与银行业务。企业的战略目标是在体现品牌价值的同时，整体展现企业的平台作用。这对于IT系统而言，就意味着需要对各种业务系统进行整合、迁移。整个系统的主要核心是对客户数据的管理，这些数据的管理会影响到整个企业的服务质量、市场推广与产品维护。由于该企业在银行业与保险业的发展壮大，是通过不断的合并与兼并来促进自身的发展。因而在其IT系统中，事实上存在多种不同的系统。客户信息散落在不同系统的数据库中。客户数据的整合，不仅有利于对这些信息的管理，保证数据的一致性，还在于从市场营销角度考虑，可以通过一致的客户信息对客户的情况做出全面了解，制定更好的推广策略。</p>

<h4>原有的技术提供者不再提供支持</h4>

<p>这种情形最是无奈，却时有发生。一种情况是使用的技术（平台、框架）不再被供应商维护，这一点体现在开源项目上更为明显。另一种情况则是所选的技术平台进行了升级，却没有很好地提供向前兼容，使得系统难以随之而升级。在架构设计中，这种绑定具体平台与技术的做法，实际上是反模式的一种，即“供应商锁定（Vendor Lock-In）[4]”。</p>

<h4>使用旧有技术的成本太高</h4>

<p>IT技术并非一定是新技术成本高于旧技术，事实上，随着技术的创新和发展，技术越新，成本越能得到更好的控制。当新旧技术的成本之差，远远高于技术栈迁移的成本，就值得做出迁移的决策了。例如，我们的一个项目需要处理的遗留系统，使用了某软件公司的产品，该产品必须运行在大型服务器上。该产品主要提供客户信息的处理。这是一个存在超过十年以上的产品，之后加入的子系统并未再使用该产品。如今，该产品所支持的客户数量并不多，而每年的产品许可费用以及大型服务器的维护成本都非常高。最后，我们对该产品提供的功能进行了迁移，以渐进地方式逐渐替换了该产品，降低了系统成本。</p>

<h3>二. 引入风险驱动模型</h3>

<p>George Fairbanks提出的风险驱动模型（Risk-Driven Model）非常适合遗留系统的技术栈迁移。所谓“风险驱动模型”，就是通过识别风险，对风险排定优先级；然后根据风险选定相关技术，再对风险是否得到缓解进行评估的一种架构方法[5] 。在对遗留系统进行技术栈迁移时，如果未能事先对迁移过程的风险进行有效识别，就可能为系统引入新的问题，降低系统质量，或者导致迁移的成本过高。</p>

<p>根据我的经验，在对遗留系统进行技术栈迁移时，可以识别的主要风险包括：</p>

<blockquote><p>遗留系统本身存在的质量问题，例如紧耦合、缺乏足够的测试、系统可维护性差；<br/>缺乏足够的知识来帮助我们理解整个遗留系统；<br/>成本、时间与人力的风险；<br/>对迁移的新技术缺乏充分认识；<br/>迁移能力的不足</p></blockquote>


<h3>三. 选择缓解风险的技术</h3>

<p>一旦识别出迁移过程中可能存在的风险，我们就可以有的放矢地选择相关技术，制订降低风险的解决方案。</p>

<h4>寻找丢失的知识</h4>

<p>只有体验过去，才能谋划未来。如果缺乏对遗留系统的足够认识，这种技术栈的迁移就很难取得成功。通常来讲，一个软件系统的知识，主要体现在如下三个方面，如下图所示：
<img class="center" src="http://agiledon.github.com/images/2013/04/legacy_01.png"></p>

<p>在这三个方面中，团队成员拥有的知识无疑是最值得寄予厚望的。在迁移过程中，若有了解该系统的团队成员参与，无疑可以做到事半功倍。可惜，这部分知识又是最为脆弱的，它就好似存储在内存中的数据一般，一旦断电就会全盘丢失。遗留系统的问题恰在于此，由于系统过于陈旧，而人员的流动总是比较频繁，在对系统进行迁移时，可能许多当年参与系统开发的成员，已经很难找到。</p>

<p>缺乏团队成员在知识方面的传承，就只能寄希望于文档与代码。文档的问题有目共睹，无论采用多么严谨的文档管理办法，文档与真实的实现总是存在偏差。正如“尽信书不如无书”，文档可以提供参考价值，但绝对不能完全依赖于文档。毫无疑问，代码是最为真实的知识。它不会说谎，但却过于沉迷于细节，要通过代码来了解遗留系统的知识，一方面耗时耗力，另一方面也难免会产生“只见树木不见森林”之叹。</p>

<p>引入自说明的可运行文档，可以有效地将文档与代码结合起来。通过运用业务语言编写功能场景来体现业务需求，完成文档的撰写；同时，它又是可以运行的代码，通过直接调用代码实现，可以完全真实地验证功能是否准确。目前，有许多框架和工具可以支持这种规格文档，例如Java平台下的<a href="http://jbehave.org/">jBehave</a>，Ruby语言编写的<a href="http://cukes.info/">Cucumber</a>，支持HTML格式的<a href="http://www.concordion.org/">Concordion</a>，以及ThoughtWorks的产品<a href="http://www.thoughtworks-studios.com/twist-agile-testing">Twist</a>[6]。</p>

<p>在我们的一个项目中，需要完成系统从WebLogic到JBoss的技术栈迁移。该系统是一个长达十年以上时间的遗留系统。虽然有比较完整的文档说明，但许多具体的业务对于我们而言，还是像一个黑盒，不知道具体的交互行为。此时，我们和客户一起为其建立了一个专门的项目，通过运用jBehave为该系统的业务行为编写可以运行的Story。在编写Story时，我们参考了系统的文档，并根据文档描述的功能建立场景，确定输入和输出，判断系统的行为是否与文档描述一致。事实上，我们在编写Story的过程中，确曾发现系统的真实行为与文档描述不一致的地方。这时，我们会判断这种不一致究竟是缺陷，还是期待的真实行为。在编写Story的过程中，我们寻找回了已经丢失的知识，并进一步熟悉了系统的结构，了解到系统组件的功能以及组件之间的关系。通过这些不断完善的Story，我们逐渐建立起了一个完全反应了真实实现的可运行文档库，它甚至可以取代原来的文档，成为系统的重要知识。</p>

<h4>及时验证，快速反馈</h4>

<p>在对系统进行技术栈迁移时，我们常常会担心修改会破坏原有的功能。尤其是对于大多数遗留系统，普遍存在测试不足，代码紧耦合，可维护性差的特点。虽然遗留系统会因为这些缺点而受人诟病，但不可否认的是，这些遗留系统毕竟经历了长时间的考验，在功能的正确性上已经得到了充分的验证。在迁移到新的技术时，如果不慎破坏了原有功能，引入了新的缺陷，就可能得不偿失了。</p>

<p>为了避免这种情况发生，我们就需要为其建立充分的测试，并通过建立持续集成（Continuous Integration）环境，提供快速反馈的通道。一旦发现新的修改破坏了系统功能，就需要马上修复或者撤销之前的提交。</p>

<p>问题是我们该如何建立测试保护网？为遗留系统建立测试是一件非常痛苦的事情，为了减小工作量，我们首先应该根据技术迁移的目标，缩小和锁定系统的范围。例如，倘若我们要将系统从IBMMQ迁移到JBossMQ，那么就只需要验证那些与消息队列通信的组件。若要将报表迁移到JasperReport，就应该只检测整个系统的报表组件。另一方面，我们应尽量从粗粒度的测试开始入手。一个好消息是，在之前为了寻找失去的知识时建立的可运行文档，事实上可以看作是一种验收测试。它不仅提供了自说明的文档，同时还建立了覆盖率客观的测试保护网。这种验收测试是针对业务行为编写的完整功能场景，更接近业务需求。它的抽象层次相对较高，并不会涉及太多编程细节。即使实现模块（包括类）是紧耦合的，没有明显的单元边界，我们仍然可以为其编写测试。这就可以省去对类与模块进行解耦这一难度颇高的工作。</p>

<p>通常，我们会将这些测试作为持续集成的一个单独pipeline。每次对原有系统的修改，都要触发该pipeline的运行，以期获得及时的反馈。这样，就可以为原有系统建立一个覆盖范围广泛的测试保护网，使得我们可以有信心地对系统进行技术栈迁移。</p>

<p>针对一些核心场景，我们还可以为遗留系统编写集成测试。这种粗粒度的测试不需要对原有代码进行太多的调整或重构，唯一需要付出的努力是对集成测试环境的搭建。</p>

<p>对于遗留系统的集成测试，最好能够支持本地构建。因为若能在本地开发环境运行集成测试，就可以通过在本地运行构建脚本，快速地获得反馈，避免一些集成错误流入到源代码服务器中，导致持续集成Pipeline频繁出现错误。这种快速失败的方式，可以更好地验证错误，降低集成风险。在搭建本地集成环境时，可以选择一些轻量级框架或容器，提高部署性能。例如我们可以在本地运行Jetty这种轻量级的Web服务器，使用HSQL内存数据库来准备数据。对于某些集成极为困难的情况，也可以适当考虑建立Stub。例如对外部服务的依赖，可以建立一个Stub的Web Service。这种方式虽然没有真实地体现集成功能，但它却可以快速地验证系统内部的功能。</p>

<p>倘若因为一些外部约束，我们无法做到完全的本地构建，也应该提供足够的集成环境，采取混合的方式运行构建脚本。例如可以将正在进行迁移的系统运行在本地环境上，而将该系统需要访问的中间件或者数据库放到其他的集成环境下。我们还可以利用构建脚本如Gradle，建立多种部署环境，例如Dev、Local、Stub、Intg等，使得开发人员或测试人员可以根据不同情况运行不同环境的构建脚本。</p>

<h4>做好充分的技术预研</h4>

<p>所谓“技术栈迁移”，必然是指从一种技术迁移到另一种技术。在充分了解系统当前存在的问题后，还需要深思熟虑，选择合理的目标技术。通常，我们会识别出待迁移模块（或系统）希望达到的质量属性，然后就此功能给出候选技术，建立一个用于权衡的矩阵。接着，再对这些待选技术进行技术预研（Spike），预研的结果将作为最终判断的依据。这种决策是有理有据的，可以有效地规避迁移中因为引入新技术带来的风险。下图是我们在一个项目中对文本搜索进行的技术预研结果矩阵。
<img class="center" src="http://agiledon.github.com/images/2013/04/legacy_02.png"></p>

<p>因为是技术栈迁移，必然要求目标技术一定要优于现有技术，否则就没有迁移的必要了。通过技术预研，既可以提供可以量化的数据，保证这种迁移是值得的；同时也相当于预先开始对目标技术展开学习和了解，及早发现技术难点和迁移的痛点。</p>

<p>在我曾经参与的一个项目中，我们针对报告生成器模块编写了自己的一个支持并发处理的Batch Job。但随着系统用户数量的逐步增加，在生成报告的高峰期，并发请求数超过了之前架构设计预见的峰值，且每个报告生成所耗费的时间较长。于是，我们计划引入消息队列技术来替换现有的Batch Job。我们对一些候选技术进行了前期预研，这其中包括微软的MSMQ、Apache ActiveMQ以及RabbitMQ，针对并发处理、可维护性、成本、部署、安全、分布式处理以及灾备等多方面进行了综合考虑，如下表所示：
<img class="center" src="http://agiledon.github.com/images/2013/04/legacy_03.png"></p>

<p>技术选型从来都不是以单方面的高质量作为评价标准，即使某项技术在多个评判维度上都得到了最高的分数，也未必就是最佳选择。我们必须结合当前项目的具体场景，实事求是地进行判断，以期获得一个恰如其分的迁移方案。</p>

<h4>新旧共存，小步前行</h4>

<p>技术栈迁移的某些特征与架构的演化不谋而合，我们绝对不能奢求获得一个一蹴而就的完美方案，更不能盼望整个迁移过程能够一步到位。尤其针对那些因为战略调整而驱动的技术栈迁移，可能牵涉到架构风格或整个基础设施的修改或调整，单就迁移这一项工作而言，就可能是一个浩大的工程。这时，我们必须要允许新旧共存，通过小步前行的方式逐步以新技术替换旧技术。我们必须保证前进的每一小步，都不会破坏系统的整体功能。这种新旧共存的局面，可能导致在一段时间会出现架构风格或解决方案的不一致，但只要做好整体规划，最终仍能在一致性方面获得完美的答案。</p>

<p>在我们工作的一个项目中，需要将一个独立的系统彻底移除，并将该系统原有的功能集成到另一个系统。需要移除的目标系统目前以Web Service方式提供服务。我们选择的解决方案是渐进地移除该系统。假设待移除的目标系统为Target，要集成的系统为Integration，我们采用了如下的迁移步骤：
1、修改Integration，为其创建与Target提供的Web Service一致的服务接口；
2、让新建立的服务接口的实现调用Target提供的Web Service；
3、修改客户端对Target服务的调用，改为指向新增的Integration服务接口；
4、如果运行一切正常，再将Target中的实现迁移到Integration中；
5、在迁移过程中，提供Toggle开关，可以随时通过改变Toggle的值，选择使用新或旧的调用方式；
6、再次确定采用新的调用方式是否正常，如果正常，彻底去掉原有的实现，移除Target系统。</p>

<p>新旧共存并非一种妥协，而是迁移过程中必须存在的中间状态。Jez Humble介绍了ThoughtWorks产品<a href="http://www.thoughtworks-studios.com/go-continuous-delivery">GO</a>的几次技术栈迁移[7]，包括从iBatis迁移到Hibernate，从Velocity和JsTemplate转向JRuby on Rails的案例。文章提出了一种称为Branch By Abstraction（抽象分支）的迁移方法，执行步骤如下图所示：
<img class="center" src="http://agiledon.github.com/images/2013/04/legacy_04.png"></p>

<p>图中的抽象层将客户端（Consumer）与被替换的实现进行了解耦，使得这种替换可以透明地进行。在对抽象层的实现进行替换时，可以规定替换纪律，例如对于新增功能，必须运用新技术提供实现；还可以通过持续集成的验证门自动验证，例如设置旧有技术在系统中的阈值，每次提交都不允许旧有技术的代码量超过这个阈值。整个迁移过程要保证这个阈值是不断减少，绝不能增加。</p>

<h4>理清思路，持续改进</h4>

<p>要完成遗留系统的技术栈迁移，不可避免地需要对代码实现进行修改或重构。这或许是迁移难度最大的一部分内容。我的经验是针对遗留系统进行处理时，不要从一开始就埋首于浩如烟海的代码段中，太多的细节可能会让你迷失其中。若系统是可以运行的，可以首先运行该系统，通过实际操作了解系统的各个功能点、业务流程。这样的直观感受可以最快地帮助你了解该系统：它能够做什么？它能达成什么目标？它的范围是什么？它存在什么问题？</p>

<p>接下来，我们需要从系统架构出发，了解遗留系统的逻辑结构和物理分布，最好能描绘出遗留系统的轮廓图，这可以帮助你从技术的宏观角度剖析遗留系统的结构与组成；然后再结合你对该系统业务的理解，快速地掌握遗留系统。在阅读源代码时，最好能够从主程序入口开始，找到一些主要的模块，了解其大体的设计方式与编码习惯。由于之前对系统架构已有了解，阅读代码时，不应在一开始就去理解代码实现的细节，而应结合架构文档，比对代码实现是否与文档的描述一致，并充分利用自己的技术与经验，找到阅读代码的终南捷径。例如，如果我们知道该系统采用了MVC架构，就可以很容易地根据Url找到对应的Controller对象，并在该对象中寻找业务功能实现的脉络。又例如我们知道系统引入了WCF来支持分布式处理，而我们又非常熟悉WCF，就可以基本忽略系统基础设施的部分，直接了解系统的业务实现。如果系统基于EJB 2.0实现，则完全可以根据EJB提供的Bean的结构，快速地定位到对应的服务接口与实现。这是因为许多框架都规定了一些约束或规范，从这些约束与规范入手，可以做到事半功倍。</p>

<p>在尝试理解代码的过程中，可以通过手工绘制或利用IDE自动生成包图、时序图等可视性强的UML图，帮助我们理解代码结构。Michael Feathers提出可以为遗留代码绘制影响结构图与特征草图[8]，从而帮助我们去梳理程序中各个对象之间的关系，尤其是帮助我们识别依赖，进而利用接缝类型、隐藏依赖等手法去解除依赖。</p>

<p>了解了代码，还需要对代码进行修改。多数情况下，我们需要首先通过重构来改善代码质量。注意，技术栈的迁移并非重构，但重构可以作为迁移工具箱中一件最为重要的工具。例如，我们可以通过Extract Interface，并结合Use Interface Where Possible手法，对一些具体类进行接口提取，并改变对原来具体类对象的依赖。重构时，必须采取“分而治之，小步前进”的策略。可以首先选择实现较为容易，或者独立性较好的模块进行重构。将遗留系统逐步提取为一些可重用的模块与类。其中，对于原有类或模块的调用方，由于在重构时可能会更改接口，因而可以考虑引入Facade模式或Adapter模式，通过引入间接层对接口进行包装或适配，逐渐替换系统，最后演化为一个结构合理的良好系统。需要注意的是，在重构时一定要时刻谨记，我们之所以进行重构，其目的是为了更好地迁移遗留系统的技术栈，而非为了重构而重构，从而偏离我们之前确定的目标。故而，重构与迁移应该是两顶不同的帽子，不能同时进行。</p>

<h3>四. 结束语</h3>

<p>遗留系统的技术栈迁移可能是一个漫长艰苦的过程，它的难度甚至要高于新开发一个系统，这是因为我们常常会挣扎在新旧系统之间，并在不断的妥协、权衡中缓步前行。</p>

<p>它是一个复杂工程，需要参与者了解迁移前后的技术栈知识，掌握或者至少善于分析与理解遗留系统。我们需要审慎地做出技术决策，通过识别迁移过程的风险来驱动整个迁移过程。在决定迁移选择的技术时，要根据这些识别出来的风险对这些候选技术做充分的预研，获得可供参考的度量矩阵。我们还可以引入BDD框架来编写可运行的功能场景，以此来寻找失去的知识，同时兼得验收测试的保护网。</p>

<p>我们可以通过引入持续集成，建立快速反馈环，以避免迁移时做出的改动对原有系统造成破坏。同时，还必须具备技术迁移的能力。我们可以考虑引入一些最佳实践或迁移方法，例如抽象分支、影响结构图、特征草图，运用设计模式和重构手法来改善遗留代码，以利于技术的迁移。当然，团队协作、架构设计、组织管理、进度跟踪等一系列技术与管理实践同样重要，只是这些实践并非技术栈迁移所必须的，而是所有开发过程都必须经历的过程，因而本文不再赘述这些内容。</p>

<p><strong>参考文献：</strong></p>

<p>[1]：<a href="http://en.wikipedia.org/wiki/Legacy_system">http://en.wikipedia.org/wiki/Legacy_system</a>，原文为：“A legacy system is an old method, technology, computer system, or application program.”</p>

<p>[2]：文章<a href="http://highscalability.com/how-rackspace-now-uses-mapreduce-and-hadoop-query-terabytes-data">How Rackspace Now Uses MapReduce And Hadoop To Query Terabytes Of Data</a></p>

<p>[3]：烟囱系统，一种反模式，<a href="http://highscalability.com/how-rackspace-now-uses-mapreduce-and-hadoop-query-terabytes-data">http://sourcemaking.com/antipatterns/stovepipe-system</a>。</p>

<p>[4]：供应商锁定，一种反模式，参见<a href="http://highscalability.com/how-rackspace-now-uses-mapreduce-and-hadoop-query-terabytes-data">http://sourcemaking.com/antipatterns/vendor-lock-in</a>。</p>

<p>[5]：Gorge Fairbanks：<a href="http://www.amazon.com/Just-Enough-Software-Architecture-Risk-Driven/dp/0984618104">Just Enough Software Architecture</a>，参见第3章Risk Driven Model</p>

<p>[6]：以上所述皆为BDD框架或整体工具。</p>

<p>[7]：Jez Humble：<a href="http://continuousdelivery.com/2011/05/make-large-scale-changes-incrementally-with-branch-by-abstraction/">Make Large Scale Changes Incrementally with Branch By Abstraction</a></p>

<p>[8]：Michael Feathers：<a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052">Working Effectively with Legacy Code</a></p>
]]></content>
  </entry>
  
</feed>
