<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[捷道]]></title>
  <link href="http://agiledon.github.com/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2012-12-27T19:51:50+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[案例分析:基于消息的分布式架构]]></title>
    <link href="http://agiledon.github.com/blog/2012/12/27/distributed-architecture-based-on-message/"/>
    <updated>2012-12-27T11:31:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2012/12/27/distributed-architecture-based-on-message</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2012/12/messagearchitecture.jpg" width="600" height="450"></p>

<p>美国计算机科学家，LaTex的作者Leslie Lamport说：“分布式系统就是这样一个系统，系统中一个你甚至都不知道的计算机出了故障，却可能导致你自己的计算机不可用。”一语道破了开发分布式系统的玄机，那就是它的复杂与不可控。所以Martin Fowler强调：分布式调用的第一原则就是不要分布式。这句话看似颇具哲理，然而就企业应用系统而言，只要整个系统在不停地演化，并有多个子系统共同存在时，这条原则就会被迫打破。盖因为在当今的企业应用系统中，很难寻找到完全不需要分布式调用的场景。Martin Fowler提出的这条原则，一方面是希望设计者能够审慎地对待分布式调用，另一方面却也是分布式系统自身存在的缺陷所致。无论是CORBA，还是EJB 2；无论是RPC平台，还是Web Service，都因为驻留在不同进程空间的分布式组件，而引入额外的复杂度，并可能对系统的效率、可靠性、可预测性等诸多方面带来负面的影响。</p>

<p>然而，不可否认的是在企业应用系统领域，我们总是会面对不同系统之间的通信、集成与整合，尤其当面临异构系统时，这种分布式的调用与通信变得越重要，它在架构设计中就更加凸显其价值。并且，从业务分析与架构质量的角度来讲，我们也希望在系统架构中尽可能地形成对服务的重用，通过独立运行在进程中服务的形式，彻底解除客户端与服务端的耦合。这常常是架构演化的必然道路。在我的同事陈金洲发表在InfoQ上的文章《<a href="%E6%9E%B6%E6%9E%84%E8%85%90%E5%8C%96%E4%B9%8B%E8%B0%9C">架构腐化之谜</a>》中，就认为可以通过“将独立的模块放入独立的进程”来解决架构因为代码规模变大而腐化的问题。</p>

<!--more-->


<p>随着网络基础设施的逐步成熟，从RPC进化到Web Service，并在业界开始普遍推行SOA，再到后来的RESTful平台以及云计算中的PaaS与SaaS概念的推广，分布式架构在企业应用中开始呈现出不同的风貌，然而殊途同归，这些分布式架构的目标仍然是希望回到建造巴别塔的时代，系统之间的交流不再为不同语言与平台的隔阂而产生障碍。正如Martin Fowler在《企业集成模式》一书的序中写道：“集成之所以重要是因为相互独立的应用是没有生命力的。我们需要一种技术能将在设计时并未考虑互操作的应用集成起来，打破它们之间的隔阂，获得比单个应用更多的效益”。这或许是分布式架构存在的主要意义。</p>

<h2>1 集成模式中的消息模式</h2>

<p>归根结底，企业应用系统就是对数据的处理，而对于一个拥有多个子系统的企业应用系统而言，它的基础支撑无疑就是对消息的处理。与对象不同，消息本质上是一种数据结构（当然，对象也可以看做是一种特殊的消息），它包含消费者与服务双方都能识别的数据，这些数据需要在不同的进程（机器）之间进行传递，并可能会被多个完全不同的客户端消费。在众多分布式技术中，消息传递相较文件传递与远程过程调用（RPC）而言，似乎更胜一筹，因为它具有更好的平台无关性，并能够很好地支持并发与异步调用。对于Web Service与RESTful而言，则可以看做是消息传递技术的一种衍生或封装。在《面向模式的软件架构（卷四）》一书中，将关于消息传递的模式划归为分布式基础设施的范畴，这是因为诸多消息中间件产品的出现，使得原来需要开发人员自己实现的功能，已经可以直接重用。这极大地降低了包括设计成本、实现成本在内的开发成本。因此，对于架构师的要求也就从原来的设计实现，转变为对业务场景和功能需求的判断，从而能够正确地进行架构决策、技术选型与模式运用。</p>

<h3>常用的消息模式</h3>

<p>在我参与过的所有企业应用系统中，无一例外地都采用（或在某些子系统与模块中部分采用）了基于消息的分布式架构。但是不同之处在于，让我们做出架构决策的证据却迥然而异，这也直接影响我们所要应用的消息模式。</p>

<h4>消息通道（Message Channel）模式</h4>

<p>我们常常运用的消息模式是Message Channel（消息通道）模式，如图1所示。
<img class="center" src="http://agiledon.github.com/images/2012/12/message1.png" width="600" height="264"></p>

<center>图1 Message Channel模式（图片来自[eaipatterns](http://www.eaipatterns.com) ）</center>


<p>消息通道作为在客户端（消费者，Consumer）与服务（生产者，Producer）之间引入的间接层，可以有效地解除二者之间的耦合。只要实现规定双方需要通信的消息格式，以及处理消息的机制与时机，就可以做到消费者对生产者的“无知”。事实上，该模式可以支持多个生产者与消费者。例如，我们可以让多个生产者向消息通道发送消息，因为消费者对生产者的无知性，它不必考虑究竟是哪个生产者发来的消息。</p>

<p>虽然消息通道解除了生产者与消费者之间的耦合，使得我们可以任意地对生产者与消费者进行扩展，但它又同时引入了各自对消息通道的依赖，因为它们必须知道通道资源的位置。要解除这种对通道的依赖，可以考虑引入Lookup服务来查找该通道资源。例如，在JMS中就可以通过JNDI来获取消息通道Queue。若要做到充分的灵活性，可以将与通道相关的信息存储到配置文件中，Lookup服务首先通过读取配置文件来获得通道。</p>

<p>消息通道通常以队列的形式存在，这种先进先出的数据结构无疑最为适合这种处理消息的场景。微软的MSMQ、IBM MQ、JBoss MQ以及开源的<a href="RabbitMQ">RabbitMQ</a>、<a href="http://activemq.apache.org">Apache ActiveMQ</a>都通过队列实现了Message Channel模式。因此，在选择运用Message Channel模式时，更多地是要从质量属性的层面对各种实现了该模式的产品进行全方位的分析与权衡。例如，消息通道对并发的支持以及在性能上的表现；消息通道是否充分地考虑了错误处理；对消息安全的支持；以及关于消息持久化、灾备（fail over）与集群等方面的支持。因为通道传递的消息往往是一些重要的业务数据，一旦通道成为故障点或安全性的突破点，对系统就会造成灾难性的影响。在本文的第二部分，我将给出一个实际案例来阐释在进行架构决策时应该考虑的架构因素，并由此做出正确地决策。</p>

<h4>发布者-订阅者（Publisher-Subscriber）模式</h4>

<p>一旦消息通道需要支持多个消费者时，就可能面临两种模型的选择：拉模型与推模型。拉模型是由消息的消费者发起的，主动权把握在消费者手中，它会根据自己的情况对生产者发起调用。如图2所示：
<img class="center" src="http://agiledon.github.com/images/2012/12/message2.png" width="600" height="207"></p>

<center>图2  拉模型</center>


<p>拉模型的另一种体现则由生产者在状态发生变更时，通知消费者其状态发生了改变。但得到通知的消费者却会以回调方式，通过调用传递过来的消费者对象获取更多细节消息。</p>

<p>在基于消息的分布式系统中，拉模型的消费者通常以Batch Job的形式，根据事先设定的时间间隔，定期侦听通道的情况。一旦发现有消息传递进来，就会转而将消息传递给真正的处理器（也可以看做是消费者）处理消息，执行相关的业务。在本文第二部分介绍的医疗卫生系统，正是通过引入Quartz.NET实现了Batch Job，完成对消息通道中消息的处理。</p>

<p>推模型的主动权常常掌握在生产者手中，消费者被动地等待生产者发出的通知，这就要求生产者必须了解消费者的相关信息。如图3所示：
<img class="center" src="http://agiledon.github.com/images/2012/12/message3.png" width="600" height="187"></p>

<center>图3 推模型</center>


<p>对于推模型而言，消费者无需了解生产者。在生产者通知消费者时，传递的往往是消息（或事件），而非生产者自身。同时，生产者还可以根据不同的情况，注册不同的消费者，又或者在封装的通知逻辑中，根据不同的状态变化，通知不同的消费者。</p>

<p>两种模型各有优势。拉模型的好处在于可以进一步解除消费者对通道的依赖，通过后台任务去定期访问消息通道。坏处是需要引入一个单独的服务进程，以Schedule形式执行。而对于推模型而言，消息通道事实上会作为消费者观察的主体，一旦发现消息进入，就会通知消费者执行对消息的处理。无论推模型，拉模型，对于消息对象而言，都可能采用类似Observer模式的机制，实现消费者对生产者的订阅，因此这种机制通常又被称为Publisher-Subscriber模式，如图4所示：
<img class="center" src="http://agiledon.github.com/images/2012/12/message4.png" width="600" height="393"></p>

<center>图4 Publisher-Subscriber模式（图片来自[eaipatterns](http://www.eaipatterns.com) ）</center>


<p>通常情况下，发布者和订阅者都会被注册到用于传播变更的基础设施（即消息通道）上。发布者会主动地了解消息通道，使其能够将消息发送到通道中；消息通道一旦接收到消息，会主动地调用注册在通道中的订阅者，进而完成对消息内容的消费。</p>

<p>对于订阅者而言，有两种处理消息的方式。一种是广播机制，这时消息通道中的消息在出列的同时，还需要复制消息对象，将消息传递给多个订阅者。例如，有多个子系统都需要获取从CRM系统传来的客户信息，并根据传递过来的客户信息，进行相应的处理。此时的消息通道又被称为Propagation通道。另一种方式则属于抢占机制，它遵循同步方式，在同一时间只能有一个订阅者能够处理该消息。实现Publisher-Subscriber模式的消息通道会选择当前空闲的唯一订阅者，并将消息出列，并传递给订阅者的消息处理方法。</p>

<p>目前，有许多消息中间件都能够很好地支持Publisher-Subscriber模式，例如JMS接口规约中对于Topic对象提供的MessagePublisher与MessageSubscriber接口。RabbitMQ也提供了自己对该模式的实现。微软的MSMQ虽然引入了事件机制，可以在队列收到消息时触发事件，通知订阅者。但它并非严格意义上的Publisher-Subscriber模式实现。由微软MVP <a href="http://www.udidahan.com">Udi Dahan</a>作为主要贡献者的<a href="http://nservicebus.com">NServiceBus</a>，则对MSMQ以及WCF做了进一层包装，并能够很好地实现这一模式。</p>

<h4>消息路由（Message Router）模式</h4>

<p>无论是Message Channel模式，还是Publisher-Subscriber模式，队列在其中都扮演了举足轻重的角色。然而，在企业应用系统中，当系统变得越来越复杂时，对性能的要求也会越来越高，此时对于系统而言，可能就需要支持同时部署多个队列，并可能要求分布式部署不同的队列。这些队列可以根据定义接收不同的消息，例如订单处理的消息，日志信息，查询任务消息等。这时，对于消息的生产者和消费者而言，并不适宜承担决定消息传递路径的职责。事实上，根据S单一职责原则，这种职责分配也是不合理的，它既不利于业务逻辑的重用，也会造成生产者、消费者与消息队列之间的耦合，从而影响系统的扩展。</p>

<p>既然这三种对象（组件）都不宜承担这样的职责，就有必要引入一个新的对象专门负责传递路径选择的功能，这就是所谓的Message Router模式，如图5所示：
<img class="center" src="http://agiledon.github.com/images/2012/12/message5.png" width="600" height="175"></p>

<center>图5 Message Router模式（图片来自eaipatterns ）</center>


<p>通过消息路由，我们可以配置路由规则指定消息传递的路径，以及指定具体的消费者消费对应的生产者。例如指定路由的关键字，并由它来绑定具体的队列与指定的生产者（或消费者）。路由的支持提供了消息传递与处理的灵活性，也有利于提高整个系统的消息处理能力。同时，路由对象有效地封装了寻找与匹配消息路径的逻辑，就好似一个调停者（Meditator），负责协调消息、队列与路径寻址之间关系。</p>

<p>除了以上的模式之外，Messaging模式提供了一个通信基础架构，使得我们可以将独立开发的服务整合到一个完整的系统中。 Message Translator模式则完成对消息的解析，使得不同的消息通道能够接收和识别不同格式的消息。而且通过引入这样的对象，也能够很好地避免出现盘根错节，彼此依赖的多个服务。Message Bus模式可以为企业提供一个面向服务的体系架构。它可以完成对消息的传递，对服务的适配与协调管理，并要求这些服务以统一的方式完成协作。</p>

<h2>2 消息模式的应用场景</h2>

<p>基于消息的分布式架构总是围绕着消息来做文章。例如可以将消息封装为对象，或者指定消息的规范例如SOAP，或者对实体对象的序列化与反序列化。这些方式的目的只有一个，就是将消息设计为生产者和消费者都能够明白的格式，并能通过消息通道进行传递。</p>

<h3>场景一：基于消息的统一服务架构</h3>

<p>在制造工业的CIMS系统中，我们尝试将各种业务以服务的形式公开给客户端的调用者，例如定义这样的接口：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">interface</span> <span class="n">IService</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">IMessage</span> <span class="nf">Execute</span><span class="p">(</span><span class="n">IMessage</span> <span class="n">aMessage</span><span class="p">);</span>
</span><span class='line'>  <span class="k">void</span> <span class="nf">SendRequest</span><span class="p">(</span><span class="n">IMessage</span> <span class="n">aMessage</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>之所以能够设计这样的服务，原因在于我们对业务信息进行了高度的抽象，以消息的形式在服务之间传递。此时的消息其实是生产者与消费者之间的契约或接口，只要遵循这样的契约，按照规定的格式对消息进行转换与抽取，就能很好地支持系统的分布式处理。</p>

<p>在这个CIMS系统中，我们将消息划分为ID，Name和Body，通过定义如下的接口方法，可以获得消息主体的相关属性：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">interface</span> <span class="n">IMessage</span><span class="p">:</span><span class="n">ICloneable</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>     <span class="kt">string</span> <span class="n">MessageID</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>     <span class="kt">string</span> <span class="nf">MessageName</span><span class="p">()</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
</span><span class='line'>     <span class="n">IMessageItemSequence</span> <span class="nf">CreateMessageBody</span><span class="p">();</span>
</span><span class='line'>     <span class="n">IMessageItemSequence</span> <span class="nf">GetMessageBody</span><span class="p">();</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>消息主体类Message实现了IMessage接口。在该类中，消息体Body为IMessageItemSequence类型。这个类型用于获取和设置消息的内容：Value和Item：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">interface</span> <span class="n">IItemValueSetting</span> <span class="p">{</span>
</span><span class='line'>     <span class="kt">string</span> <span class="nf">getSubValue</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">);</span>
</span><span class='line'>     <span class="k">void</span> <span class="nf">setSubValue</span><span class="p">(</span><span class="kt">string</span> <span class="n">name</span><span class="p">,</span> <span class="kt">string</span> <span class="k">value</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">public</span> <span class="k">interface</span> <span class="n">IMessageItemSequence</span><span class="p">:</span><span class="n">IItemValueSetting</span><span class="p">,</span> <span class="n">ICloneable</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>     <span class="n">IMessageItem</span> <span class="nf">GetMessageItem</span><span class="p">(</span><span class="kt">string</span> <span class="n">aName</span><span class="p">);</span>
</span><span class='line'>     <span class="n">IMessageItem</span> <span class="nf">CreateMessageItem</span><span class="p">(</span><span class="kt">string</span> <span class="n">aName</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Value为字符串类型，它利用了HashTable存储Key和Value的键值对。Item则为IMessageItem类型，在IMessageItemSequence的实现类中，同样利用了HashTable存储Key和Item的键值对。</p>

<p>IMessageItem支持消息体的嵌套。它包含了两部分：SubValue和SubItem。实现的方式和IMessageItemSequence相似。通过定义这样的嵌套结构，使得消息的扩展成为可能。一般的消息结构如下所示：</p>

<p>各个消息对象之间的关系如图6所示：
<img class="center" src="http://agiledon.github.com/images/2012/12/message6.png" width="600" height="402"></p>

<center>图6 消息对象之间的关系</center>


<p>在实现服务进程通信之前，我们必须定义好各个服务或各个业务的消息格式。通过消息体的方法在服务的一端设置消息的值，然后发送，并在服务的另一端获得这些值。例如发送消息端定义如下的消息体：
Liquid error: invalid byte sequence in US-ASCII</p>

<p>我们在客户端引入了一个ServiceLocator对象，它通过MessageQueueListener对消息队列进行侦听，一旦接收到消息，就获取该消息中的name去定位它所对应的服务，然后调用服务的Execute(aMessage)方法，执行相关的业务。</p>

<p>ServiceLocator承担的定位职责其实是对存储在ServiceContainer容器中的服务进行查询。ServiceContainer容器可以读取配置文件，在启动服务的时候初始化所有的分布式服务（注意，这些服务都是无状态的），并对这些服务进行管理。它封装了服务的基本信息，诸如服务所在的位置，服务的部署方式等，从而避免服务的调用者直接依赖于服务的细节，既减轻了调用者的负担，还能够较好地实现服务的扩展与迁移。</p>

<p>在这个系统中，我们主要引入了Messaging模式，通过定义的IMessage接口，使得我们更好地对服务进行抽象，并以一种扁平的格式存储数据信息，从而解除服务之间的耦合。只要各个服务就共用的消息格式达成一致，请求者就可以不依赖于接收者的具体接口。通过引入的Message对象，我们就可以建立一种在行业中通用的消息模型与分布式服务模型。事实上，基于这样的一个框架与平台，在对制造行业的业务进行开发时，开发人员最主要的活动是与领域专家就各种业务的消息格式进行讨论，这样一种面向领域的消息语言，很好地扫清了技术人员与业务人员的沟通障碍；同时在各个子系统之间，我们也只需要维护服务间相互传递的消息接口表。每个服务的实现都是完全隔离的，有效地做到了对业务知识与基础设施的合理封装与隔离。</p>

<p>对于消息的格式和内容，我们考虑引入了Message Translator模式，负责对前面定义的消息结构进行翻译和解析。为了进一步减轻开发人员的负担，我们还可以基于该平台搭建一个消息-对象-关系的映射框架，引入实体引擎（Entity Engine）将消息转换为领域实体，使得服务的开发者能够以完全面向对象的思想开发各个服务组件，并通过调用持久层实现消息数据的持久化。同时，利用消息总线（此时的消息总线可以看做是各个服务组件的连接器）连接不同的服务，并允许异步地传递消息，对消息进行编码。这样一个基于消息的分布式架构如图7所示：</p>

<p><img class="center" src="http://agiledon.github.com/images/2012/12/message7.png" width="600" height="449"></p>

<center>图7 基于Message Bus的CIMS分布式架构</center>


<h3>场景二：消息中间件的架构决策</h3>

<p>在一个医疗卫生系统中，我们面临了客户对系统性能/可用性的非功能需求。在我们最初启动该项目时，客户就表达了对性能与可用性的特别关注。客户希望最终用户在进行复杂的替换删除操作时，能够具有很好的用户体验，简言之，就是希望能够快速地得到操作的响应。问题在于这样的替换删除操作需要处理比较复杂的业务逻辑，同时牵涉到的关联数据量非常大，整个操作若需完成，最坏情况下可能需要几分钟的时间。我们可以通过引入缓存、索引、分页等多种方式对数据库操作进行性能调优，但整个操作的耗时始终无法达到客户的要求。由于该系统是在一个遗留系统的基础上开发，如果要引入Map-Reduce来处理这些操作，以满足质量需求，则对架构的影响太大，且不能很好地重用之前系统的某些组件。显然，付出的成本与收益并不成正比。</p>

<p>通过对需求进行分析，我们注意到最终客户并不需要实时获得结果，只要能够保证最终结果的一致性和完整性即可。关键在于就用户体验而言，他们不希望经历漫长的等待，然后再通知他们操作究竟是成功还是失败。这是一个典型需要通过后台任务进行异步处理的场景。</p>

<p>在企业应用系统中，我们常常会遭遇这样的场景。我们曾经在一个金融系统中尝试通过自己编写任务的方式来控制后台线程的并发访问，并完成对任务的调度。事实证明，这样的设计并非行之有效。对于这种典型的异步处理来说，基于消息传递的架构模式才是解决这一问题的最佳办法。</p>

<p>因为消息中间件的逐步成熟，对于这一问题的架构设计，已经由原来对设计实现的关注转为如何进行产品选型和技术决策。例如，在.NET平台下，架构师需要重点考虑的是应该选择哪种消息中间件来处理此等问题？这就需要我们必须结合具体的业务场景，来识别这种异步处理方式的风险，然后再根据这些风险去比较各种技术，以求寻找到最适合的方案。</p>

<p>通过分析业务场景以及客户性质，我们发现该业务场景具有如下特征：</p>

<pre><code>在一些特定情形下，可能会集中发生批量的替换删除操作，使得操作的并发量达到高峰；例如FDA要求召回一些违规药品时，就需要删除药品库中该药品的信息；

操作结果不要求实时性，但需要保证操作的可靠性，不能因为异常失败而导致某些操作无法进行；

自动操作的过程是不可逆转的，因此需要记录操作历史；

基于性能考虑，大多数操作需要调用数据库的存储过程；

操作的数据需要具备一定的安全性，避免被非法用户对数据造成破坏；

与操作相关的功能以组件形式封装，保证组件的可重用性、可扩展性与可测试性；

数据量可能随着最终用户的增多而逐渐增大；
</code></pre>

<p>针对如上的业务需求，我们决定从以下几个方面对各种技术方案进行横向的比较与考量。</p>

<pre><code>并发：选择的消息队列一定要很好地支持用户访问的并发性；
安全：消息队列是否提供了足够的安全机制；

性能伸缩：不能让消息队列成为整个系统的单一性能瓶颈；

部署：尽可能让消息队列的部署更为容易；

灾备：不能因为意外的错误、故障或其他因素导致处理数据的丢失；

API易用性：处理消息的API必须足够简单、并能够很好地支持测试与扩展；
我们先后考察了MSMQ、Resque、ActiveMQ和RabbitMQ，通过查询相关资料，以及编写Spike代码验证相关质量，我们最终选择了RabbitMQ。
</code></pre>

<p>我们选择放弃MSMQ，是因为它严重依赖Windows操作系统；它虽然提供了易用的GUI方便管理人员对其进行安装和部署，但若要编写自动化部署脚本，却非常困难。同时，MSMQ的队列容量不能查过4M字节，这也是我们无法接收的。Resque的问题是目前仅支持Ruby的客户端调用，不能很好地与.NET平台集成。此外，Resque对消息持久化的处理方式是写入到Redis中，因而需要在已有RDBMS的前提下，引入新的Storage。我们比较倾心于ActiveMQ与RabbitMQ，但通过编写测试代码，采用循环发送大数据消息以验证消息中间件的性能与稳定性时，我们发现ActiveMQ的表现并不太让人满意。至少，在我们的询证调研过程中，ActiveMQ会因为频繁发送大数据消息而偶尔出现崩溃的情况。相对而言，RabbitMQ在各个方面都比较适合我们的架构要求。</p>

<p>例如在灾备与稳定性方面，RabbitMQ提供了可持久化的队列，能够在队列服务崩溃的时候，将未处理的消息持久化到磁盘上。为了避免因为发送消息到写入消息之间的延迟导致信息丢失，RabbitMQ引入了Publisher Confirm机制以确保消息被真正地写入到磁盘中。它对Cluster的支持提供了Active/Passive与Active/Active两种模式。例如，在Active/Passive模式下，一旦一个节点失败，Passive节点就会马上被激活，并迅速替代失败的Active节点，承担起消息传递的职责。如图8所示：
<img class="center" src="http://agiledon.github.com/images/2012/12/message8.png" width="600" height="430"></p>

<center>图8 Active/Passive Cluster（图片来自RabbitMQ官方网站）</center>


<p>在并发处理方面，RabbitMQ本身是基于erlang编写的消息中间件，作为一门面向并发处理的编程语言，erlang对并发处理的天生优势使得我们对RabbitMQ的并发特性抱有信心。RabbitMQ可以非常容易地部署到Windows、Linux等操作系统下，同时，它也可以很好地部署到服务器集群中。它的队列容量是没有限制的（取决于安装RabbitMQ的磁盘容量），发送与接收信息的性能表现也非常好。RabbitMQ提供了Java、.NET、Erlang以及C语言的客户端API，调用非常简单，并且不会给整个系统引入太多第三方库的依赖。 例如.NET客户端只需要依赖一个程序集。</p>

<p>即使我们选择了RabbitMQ，但仍有必要对系统与具体的消息中间件进行解耦，这就要求我们对消息的生产者与消费者进行抽象，例如定义如下的接口：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'>    <span class="k">public</span> <span class="k">interface</span> <span class="n">IQueueSubscriber</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">void</span> <span class="n">ListenTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kt">string</span> <span class="n">queueName</span><span class="p">,</span> <span class="n">Action</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">action</span><span class="p">);</span>
</span><span class='line'>        <span class="k">void</span> <span class="n">ListenTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kt">string</span> <span class="n">queueName</span><span class="p">,</span> <span class="n">Predicate</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">messageProcessedSuccessfully</span><span class="p">);</span>
</span><span class='line'>        <span class="k">void</span> <span class="n">ListenTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kt">string</span> <span class="n">queueName</span><span class="p">,</span> <span class="n">Predicate</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">messageProcessedSuccessfully</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">requeueFailedMessages</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">public</span> <span class="k">interface</span> <span class="n">IQueueProvider</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="n">T</span> <span class="n">Pop</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kt">string</span> <span class="n">queueName</span><span class="p">);</span>
</span><span class='line'>        <span class="n">T</span> <span class="n">PopAndAwaitAcknowledgement</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kt">string</span> <span class="n">queueName</span><span class="p">,</span> <span class="n">Predicate</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">messageProcessedSuccessfully</span><span class="p">);</span>
</span><span class='line'>        <span class="n">T</span> <span class="n">PopAndAwaitAcknowledgement</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kt">string</span> <span class="n">queueName</span><span class="p">,</span> <span class="n">Predicate</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">messageProcessedSuccessfully</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">requeueFailedMessages</span><span class="p">);</span>
</span><span class='line'>        <span class="k">void</span> <span class="nf">Push</span><span class="p">(</span><span class="n">FunctionalArea</span> <span class="n">functionalArea</span><span class="p">,</span> <span class="kt">string</span> <span class="n">routingKey</span><span class="p">,</span> <span class="kt">object</span> <span class="n">payload</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这两个接口的实现类中，我们封装了RabbitMQ的调用类，例如：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'>    <span class="k">public</span> <span class="k">class</span> <span class="nc">RabbitMQSubscriber</span> <span class="p">:</span> <span class="n">IQueueSubscriber</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>        <span class="k">public</span> <span class="k">void</span> <span class="n">ListenTo</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kt">string</span> <span class="n">queueName</span><span class="p">,</span> <span class="n">Action</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">action</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="k">using</span> <span class="p">(</span><span class="n">IConnection</span> <span class="n">connection</span> <span class="p">=</span> <span class="n">_factory</span><span class="p">.</span><span class="n">OpenConnection</span><span class="p">())</span>
</span><span class='line'>            <span class="k">using</span> <span class="p">(</span><span class="n">IModel</span> <span class="n">channel</span> <span class="p">=</span> <span class="n">connection</span><span class="p">.</span><span class="n">CreateModel</span><span class="p">())</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="kt">var</span> <span class="n">consumer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">QueueingBasicConsumer</span><span class="p">(</span><span class="n">channel</span><span class="p">);</span>
</span><span class='line'>                <span class="kt">string</span> <span class="n">consumerTag</span> <span class="p">=</span> <span class="n">channel</span><span class="p">.</span><span class="n">BasicConsume</span><span class="p">(</span><span class="n">queueName</span><span class="p">,</span> <span class="n">AcknowledgeImmediately</span><span class="p">,</span> <span class="n">consumer</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>                <span class="kt">var</span> <span class="n">response</span> <span class="p">=</span> <span class="p">(</span><span class="n">BasicDeliverEventArgs</span><span class="p">)</span> <span class="n">consumer</span><span class="p">.</span><span class="n">Queue</span><span class="p">.</span><span class="n">Dequeue</span><span class="p">();</span>
</span><span class='line'>                <span class="kt">var</span> <span class="n">serializer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">JavaScriptSerializer</span><span class="p">();</span>
</span><span class='line'>                <span class="kt">string</span> <span class="n">json</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="n">GetString</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">Body</span><span class="p">);</span>
</span><span class='line'>                <span class="kt">var</span> <span class="n">message</span> <span class="p">=</span> <span class="n">serializer</span><span class="p">.</span><span class="n">Deserialize</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">json</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>                <span class="n">action</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">public</span> <span class="k">class</span> <span class="nc">RabbitMQProvider</span> <span class="p">:</span> <span class="n">IQueueProvider</span>
</span><span class='line'>    <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">public</span> <span class="n">T</span> <span class="n">Pop</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="kt">string</span> <span class="n">queueName</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">var</span> <span class="n">returnVal</span> <span class="p">=</span> <span class="k">default</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
</span><span class='line'>            <span class="k">const</span> <span class="kt">bool</span> <span class="n">acknowledgeImmediately</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">connection</span> <span class="p">=</span> <span class="n">_factory</span><span class="p">.</span><span class="n">OpenConnection</span><span class="p">())</span>
</span><span class='line'>            <span class="k">using</span> <span class="p">(</span><span class="kt">var</span> <span class="n">channel</span> <span class="p">=</span> <span class="n">connection</span><span class="p">.</span><span class="n">CreateModel</span><span class="p">())</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="kt">var</span> <span class="n">response</span> <span class="p">=</span> <span class="n">channel</span><span class="p">.</span><span class="n">BasicGet</span><span class="p">(</span><span class="n">queueName</span><span class="p">,</span> <span class="n">acknowledgeImmediately</span><span class="p">);</span>
</span><span class='line'>
</span><span class='line'>                <span class="k">if</span> <span class="p">(</span><span class="n">response</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
</span><span class='line'>                <span class="p">{</span>
</span><span class='line'>                    <span class="kt">var</span> <span class="n">serializer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">JavaScriptSerializer</span><span class="p">();</span>
</span><span class='line'>                    <span class="kt">var</span> <span class="n">json</span> <span class="p">=</span> <span class="n">Encoding</span><span class="p">.</span><span class="n">UTF8</span><span class="p">.</span><span class="n">GetString</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">Body</span><span class="p">);</span>
</span><span class='line'>                    <span class="n">returnVal</span> <span class="p">=</span> <span class="n">serializer</span><span class="p">.</span><span class="n">Deserialize</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">json</span><span class="p">);</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="k">return</span> <span class="n">returnVal</span><span class="p">;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span></code></pre></td></tr></table></div></figure>


<p>我们用Quartz.Net来实现Batch Job。通过定义一个实现了IStatefulJob接口的Job类，在Execute()方法中完成对队列的侦听。Job中RabbitMQSubscriber类的ListenTo()方法会调用Queue的Dequeue()方法，当接收的消息到达队列时，Job会侦听到消息达到的事件，然后以同步的方式使得消息弹出队列，并将消息作为参数传递给Action委托。因此，在Batch Job的Execute()方法中，可以定义消息处理的方法，并调用RabbitMQSubscriber类的ListenTo()方法，如下所示（注意，这里传递的消息事实上是Job的Id）：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='csharp'><span class='line'>        <span class="k">public</span> <span class="k">void</span> <span class="nf">Execute</span><span class="p">(</span><span class="n">JobExecutionContext</span> <span class="n">context</span><span class="p">)</span>
</span><span class='line'>        <span class="p">{</span>
</span><span class='line'>            <span class="kt">string</span> <span class="n">queueName</span> <span class="p">=</span> <span class="n">queueConfigurer</span><span class="p">.</span><span class="n">GetQueueProviders</span><span class="p">().</span><span class="n">Queue</span><span class="p">.</span><span class="n">Name</span><span class="p">;</span>
</span><span class='line'>            <span class="k">try</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">queueSubscriber</span><span class="p">.</span><span class="n">ListenTo</span><span class="p">&lt;</span><span class="n">MyJob</span><span class="p">&gt;(</span>
</span><span class='line'><span class="n">queueName</span><span class="p">,</span>
</span><span class='line'>                      <span class="n">job</span> <span class="p">=&gt;</span> <span class="n">request</span><span class="p">.</span><span class="n">MakeRequest</span><span class="p">(</span><span class="n">job</span><span class="p">.</span><span class="n">Id</span><span class="p">.</span><span class="n">ToString</span><span class="p">()));</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">catch</span><span class="p">(</span><span class="n">Exception</span> <span class="n">err</span><span class="p">)</span>
</span><span class='line'>            <span class="p">{</span>
</span><span class='line'>                <span class="n">Log</span><span class="p">.</span><span class="n">WarnFormat</span><span class="p">(</span><span class="s">&quot;Unexpected exception while processing queue &#39;{0}&#39;, Details: {1}&quot;</span><span class="p">,</span> <span class="n">queueName</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>队列的相关信息例如队列名都存储在配置文件中。Execute()方法调用了request对象的MakeRequest()方法，并将获得的消息（即JobId）传递给该方法。它会根据JobId到数据库中查询该Job对应的信息，并执行真正的业务处理。</p>

<p>在对基于消息处理的架构进行决策时，除了前面提到的考虑因素外，还需要就许多设计细节进行多方位的判断与权衡。例如针对Job的执行以及队列的管理，就需要考虑如下因素：</p>

<pre><code>• 对Queue中Job状态的监控与查询；

• 对Job优先级的管理；

• 能否取消或终止执行时间过长的Job；

• 是否能够设定Job的执行时间；

• 是否能够设定Poll的间隔时间；

• 能否跨机器分布式的放入Job；

• 对失败Job的处理；

• 能否支持多个队列，命名队列；

• 能否允许执行Job的工作进程对应特定的队列；

• 对Dead Message的支持。
</code></pre>

<h2>3 选择的时机</h2>

<p>究竟在什么时候，我们应该选择基于消息处理的分布式架构？根据我参与的多个企业应用系统的经验，窃以为需要满足如下几个条件：</p>

<p>• 对操作的实时性要求不高，而需要执行的任务极为耗时；</p>

<p>• 存在企业内部的异构系统间的整合；</p>

<p>• 服务器资源需要合理分配与利用；</p>

<p>对于第一种情况，我们常常会选择消息队列来处理执行时间较长的任务。此时引入的消息队列就成了消息处理的缓冲区。消息队列引入的异步通信机制，使得发送方和接收方都不用等待对方返回成功消息，就可以继续执行下面的代码，从而提高了数据处理的能力。尤其是当访问量和数据流量较大的情况下，就可以结合消息队列与后台任务，通过避开高峰期对大数据进行处理，就可以有效降低数据库处理数据的负荷。前面提到的医疗卫生系统正是这样一种适用场景。</p>

<p>对于不同系统乃至于异构系统的整合，恰恰是消息模式善于处理的场景。只要规定了消息的格式与传递方式，就可以有效地实现不同系统之间的通信。在为某汽车制造商开发一个大型系统时，分销商作为.NET客户端，需要将数据传递到管理中心。这些数据将被Oracle的EBS（E-Business Suite）使用。分销商管理系统（Dealer Management System，DMS）采用了C/S结构，数据库为SQL Server，汽车制造商管理中心的EBS数据库为Oracle 10g。我们需要解决两种不同数据库间数据的传递。解决方案就是利用MSMQ，将数据转换为与数据库无关的消息数据，并在两端部署MSMQ服务器，建立消息队列以便于存储消息数据。实现架构如图9所示。
<img class="center" src="http://agiledon.github.com/images/2012/12/message9.png" width="600" height="448"></p>

<center>图9 利用MSMQ实现的分布式处理架构</center>


<p>首先，分销商的数据通过MSMQ传递到MSMQ Server，再将数据插入到SQL Server数据库的同时，利用FTP将数据传送到专门的文件服务器上。EBS App Server会将文件服务器中的文件，基于接口规范写入到Oracle数据库，从而实现.NET系统与Oracle系统之间的整合。</p>

<p>分布式系统通常能够缓解单个服务器的压力，通过将不同的业务操作与数据处理以不同的服务形式部署并运行在不同的服务器上，就可以有效地分配与利用服务器资源。在这种情况下，部署在不同服务器上的服务，既可能作为服务端，用以处理客户端调用的请求，也可能作为客户端，在处理完自己的业务后，将其余业务请求委派给其他服务。在早期的CORBA系统中，通过建立统一的Naming Service，用以管理和分派服务，并通过Event Service实现事件的分发与处理。但CORBA系统采用的是RPC的方式，需要将服务设计和部署为远程对象，并建立代理。如果通过消息通道的方式，则既可以解除这种对远程对象的依赖，又可以很好地支持异步调用模型。在前面提到的CIMS系统，就是通过消息总线提供消息传递的基础设施，并建立统一的消息处理服务模型，解除服务见的依赖，使得各个服务能够独立地部署到不同服务器上。</p>

<h2>4 面临的困难</h2>

<p>由于消息模式自身的特殊性，我们在运用消息模式建立基于消息的分布式架构时，常常会面临许多困难。</p>

<p>首先是系统集成的问题。由于系统之间的通信靠消息进行传递，就必须保证消息的一致性，同时，还需要维护系统之间（主要是服务之间）接口的稳定性。一旦接口发生变化，就可能影响到该接口的所有调用者。即使服务通过接口进行了抽象，由于消息持有双方服务规定的业务数据，在一定程度上违背了封装的要义。换言之，生产与消费消息的双方都紧耦合于消息。消息的变化会直接影响到各个服务接口的实现类。然而，为了尽可能保证接口的抽象性，我们所要处理的消息都不是强类型的，这就使得我们在编译期间很难发现因为消息内容发生变更产生的错误。在我之前提到的汽车零售商管理系统就存在这样的问题。当时我负责的CRM模块需要同时与多个子系统进行通信，而每个子系统又是由不同的团队进行开发。团队之间因为沟通原因，常常未能及时地同步接口表。虽然各个子系统的单元测试和功能测试都已通过，但直到对CRM进行集成测试，才发现存在大量消息不匹配的集成问题，这些问题的起因都是因为消息的变更。</p>

<p>解决的方案是引入充分的集成测试，甚至是回归测试，并需要及时运行这些测试，以快速地获得反馈。我们可以将集成测试作为提交代码的验证们，要求每次提交代码都必须运行集成测试与指定的回归测试 。这正是持续集成的体现。通过在本地构建与远程构建运行集成测试与回归测试，有效地保证本地版本与集成后的版本不会因为消息的改变使得功能遭受破坏。一旦遭受破坏，也能够及时获得反馈，发现问题，即刻解决这些问题，而不是等到项目后期集中进行集成测试。</p>

<p>另一个问题是后台任务的非实时性带来的测试困难。由于后台任务是定期对消息队列中的消息进行处理，因而触发的时机是不可预测的 。对于这种情况，我们通常会同时运用两种方案，双管其下地解决问题。首先，我们会为系统引入一个同步实现功能的版本，并通过在配置文件中引入toggle的开关机制，随时可以在同步功能与异步功能之间进行切换。如果我们能够保证消息队列处理与后台任务执行的正确性，就可以设置为同步功能，这样就能快速而准确地对该任务所代表的功能进行测试，并及时收获反馈。同时，我们可以在持续集成服务器上建立一个专门的管道（pipeline），用以运行基于消息处理的异步版本。这个管道对应的任务可以通过手动执行，也可以对管道设置定时器，在指定时间执行（例如在凌晨两点执行一次，这样在第二天开始工作之前可以获得反馈）。我们需要为该管道准备特定的执行环境，并将后台任务的侦听与执行时间修改为可以接受的值。这样既能够及时了解功能是否正确，又能保证基于消息的系统是工作正常的。</p>

<p>当然，分布式系统还存在解析消息、网络传递的性能损耗。对于这些问题，需要架构师审慎地分析业务场景，正确地选择架构方案与架构模式。相比较本地系统而言，分布式系统的维护难度可能成倍递增。这既需要我们在进行架构决策与设计时，充分考虑系统架构的稳定性，同时还需要引入系统日志处理。更好的做法是为日志处理增加错误通知的功能，只要发生消息处理的错误信息，就通过邮件、短信等方式通知系统管理员，及时地处理错误。因为只有在发生错误的当时查询错误日志，才能够更好对问题进行定位。同时，还可以为系统引入Error Message Queue以及Dead Message Queue，以便于处理错误和异常情况。</p>

<p>对于分布式系统而言，还需要考虑服务执行结果的一致性，尤其是当某个业务需要多个服务参与到一个会话中时，一旦某个服务发生故障，就可能导致应用出现状态不一致的情况，因为只有所有参与者都成功执行了任务，才能视为完全成功。这就牵涉到分布式事务的问题，此时任务的执行就变成了事务型的：即任务必须是原子的，结果状态必须保持一致。在任务处理过程中，状态修改是彼此隔离的，成功的状态修改在整个事务执行过程中是持久的。这就是事务的ACID（Atomic，Consistent，Isolated与Durable）属性。</p>

<p>一种方案是引入分布式事务协调器，即DTC（Distributed Transaction Coordinator）,将事务分为两段式甚至三段式提交，要求整个事务的所有参与者以投票形式决定事务是完全成功还是失败。另一种方案是降低对结果一致性的要求。根据eBay的最佳实践，考虑到分布式事务的成本，获得分布式资源即时的一致性是不必要的，也是不现实的。在Randy Shoup的文章《<a href="http://www.infoq.com/cn/articles/ebay-scalability-best-practices">可伸缩性最佳实践：来自eBay的经验</a>》中提到了Eric Brewer的CAP公理：分布式系统的三项重要指标——一致性（Consistency）、可用性（Availability）和 分区耐受性（Partition-tolerance）——在任意时刻，只有两项能同时成立。我们应该根据不同的应用场景，权衡这三个要素。在不必要保证即时的一致性前提下，我们可以考虑合理地划分服务，尽量将可能作用在同一个事务范围的业务操作部署在同一个进程中，以避免分布式部署。如果确实需要多个分布式服务之间保持执行结果的一致，可以考虑引入数据核对，异步恢复事件或集中决算等手段。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress的新浪微博插件]]></title>
    <link href="http://agiledon.github.com/blog/2012/12/26/weibo-plugin-for-octopress/"/>
    <updated>2012-12-26T12:26:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2012/12/26/weibo-plugin-for-octopress</id>
    <content type="html"><![CDATA[<p>在GitHub上搭建了Octopress博客后，我一直在尝试改进或增强一些功能。有一些功能可以在网上找到第三方插件。因为我在GitHub上的博客是刚刚申请，并没有太多人知道我的博客域名。如果希望我自己新写的博客让更多人知道，最好的方式还是能够将链接发到我的新浪微博中。一些插件为octopress提供了新浪微博的share按钮，但这并不是我想要的。也许已经有快速现成的方法支持我想要的功能，但我没有找到。那么何必还去上穷碧落下黄泉的去搜索了，身为一个程序员，这种事情就自己搞定好了。正好可以练手Ruby。经过半天的代码编写和测试，我的这个新浪微博插件就实现了。它主要能够运行rake命令，解析最新博客的标题与URL，再替换weibo-config.yml配置文件中配置的微博模板的内容，并将其发布到新浪微博中。</p>

<!--more-->


<h2>实现</h2>

<p>我最初是在octopress的plugin目录下创建了post_weibo.rb文件。后来发现，当我们执行rake generate时，它事实上会去执行jekyll命令。而该命令则会去遍历plugin目录下的ruby文件，并执行之。这显然不是我希望看到的。我希望在发表的新博客完全就绪时，我再考虑发送通知到新浪微博。于是，我单独建立了一个新的文件夹&#8221;_custom&#8221;，并将post_weibo.rb文件放进去。</p>

<p>post_weibo.rb文件实现了这个插件的所有功能，主要方法为post_weibo()，如下所示：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'>  <span class="k">def</span> <span class="nf">post_weibo</span>
</span><span class='line'>    <span class="n">conn</span> <span class="o">=</span> <span class="no">Faraday</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">:url</span> <span class="o">=&gt;</span> <span class="s2">&quot;https://api.weibo.com&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">result</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">post</span> <span class="s1">&#39;/2/statuses/update.json&#39;</span><span class="p">,</span>
</span><span class='line'>                       <span class="ss">:access_token</span> <span class="o">=&gt;</span> <span class="vi">@weibo_config</span><span class="o">[</span><span class="s1">&#39;access_token&#39;</span><span class="o">]</span><span class="p">,</span>
</span><span class='line'>                       <span class="ss">:status</span> <span class="o">=&gt;</span> <span class="n">generate_post</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;post successful&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>它使用了faraday来发送post请求到新浪api。发送请求时需要获得access_token。该值可以到新浪申请。具体API说明请查阅<a href="http://open.weibo.com/wiki/2/statuses/update">开发文档</a>。</p>

<p>post_weibo.rb文件的其余方法皆是为生成微博内容服务的。具体代码可以通过我在<a href="https://github.com/agiledon/octopress-weibo">github上的repository</a>获得，这里不再赘述。大体思路是通过获得_post目录下创建日期最近的markdown文件，读取该文件，获得title的值。解析文件名，获得博客链接地址的后面部分，至于前面部分（即博客地址），则从_config.yml中获取，然后组装成正确的博客URL。接下来，再从新增的weibo-config.yml中读取配好的template，将title和url替换，并作为status值，交给post请求。</p>

<h2>Rake任务</h2>

<p>我单独加入了一个Rake任务，这样方便我们执行以发送微博。方法是打开octopress根目录下的Rakefile文件，在合适位置加入如下内容：</p>

<pre><code>desc "Post the title and url of latest blog to Sina Weibo"
    task :weibo do
    puts "Post the title and url of latest blog to Sina Weibo"
    system "ruby _custom/post_weibo.rb"
end
</code></pre>

<h2>配置</h2>

<p>要正确的发送微博，就必须在新增的weibo-config.yml中配置好相关信息。主要需要配置你的access_token与微博模板，如下所示：</p>

<pre><code>access_token: Your access token provided by Sina weibo
post_template: 我在agiledon.github.com上发表了最新博客《%{blog_title}》，请访问链接：%{blog_url}
</code></pre>

<p>注意，在配置post_template时，你虽然可以任意修改模板内容，但不能修改我事先留下的两个变量，即%{blog_title}和%{blog_title}。模板内容支持英语、中文和其他语言。</p>

<p>例如，如果你创建了一个新的博客，文件名为2012-12-25-test-demo.markdown，标题为“测试演示&#8221;。那么，你所发表的微博内容就应该为：</p>

<pre><code>我在agiledon.github.com上发表了最新博客《测试演示》，请访问链接：http://agiledon.github.com/2012/12/25/test-demo
</code></pre>

<p>当然，这里的http://agiledon.github.com取决于你在_config.yml中的url配置。</p>

<p>为了保证你的access_token安全，你可以在.gitignore中加入新增配置weibo-config.yml，从而避免对该配置的提交。这也是我为什么要将weibo-config.yml中的配置信息从_config.yml中独立出来的缘故。</p>

<h2>依赖</h2>

<p>因为在post_weibo.rb文件中，我使用了一个第三方库faraday来简化发送post请求的ruby代码。为保证rake命令的正确执行，应该在Gemfile文件中加入如下内容:</p>

<pre><code>gem "faraday", "~&gt; 0.8.4"
</code></pre>

<p>加入后，在转到octopress根目录下，运行如下命令安装faraday：</p>

<pre><code>bundle install
</code></pre>

<h2>使用</h2>

<p>如果一切配置妥当，当你编写了新的博客并发表到博客上之后，只要你认为一切Ok了，就可以执行命令：</p>

<pre><code>rake weibo
</code></pre>

<p>它就会自动将最新博客的标题与URL按照你事先设定的模板内容，发布到你的新浪微博中。一旦发布成功，在控制台下会显示“post successful!”</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopress博客问题解决方案与技巧]]></title>
    <link href="http://agiledon.github.com/blog/2012/12/25/octopress-issues-solution-and-tips/"/>
    <updated>2012-12-25T09:14:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2012/12/25/octopress-issues-solution-and-tips</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://agiledon.github.com/images/2012/12/octopress.jpg" width="259" height="154"></p>

<p>在GitHub上创建了自己的博客后，先后在Jekyll和Octopress之间来回折腾了好一段时间。之前打算直接使用Jekyll提供的博客模板，后来觉得太费神，看到Octopress还不错，且它也是基于Jekyll，并能非常方便地部署到GitHub上。经过最初的安装到对博客的深入改造，目前我的博客需要的功能已经大致完成。在这个过程中，也碰到了许多问题。通过搜索Google以及自己阅读Octopress代码，找到了对应的解决办法。此外，也有一些小技巧的积累。考虑到还有许多正在使用或想要使用Octopress的朋友，因此在这里集中分享一下。</p>

<!--more-->


<p><strong>不能在ZSH中输入命令的问题</strong></p>

<p>Octopress提供了许多Rake任务，可以方便地完成一些操作。常用的命令是rake new_post[&#8220;title&#8221;]。但是在ZSH下，输入这样的命令，会提示错误：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>zsh: no matches found: new_post[...]</span></code></pre></td></tr></table></div></figure>


<p>原因是诸如[]之类的不是正确的命令字符。当然，我们也可以使用转义符来解决这一问题。但每次都需要敲入转义符，实在是太麻烦了。解决方案是在~/.zshrc文件下，加入这样一行内容：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>alias rake="noglob rake"</span></code></pre></td></tr></table></div></figure>


<p><strong>解决中文乱码问题</strong></p>

<p>Octopress要创建一篇博客，可以直接运行rake new_post[&#8220;title&#8221;]，它会在source/_post下创建一个markdown文件。同时，它会将你输入的title作为blog的链接URL。我们可以通过一些工具，例如EMacs或者MouApp（在Mac OS下）打开该文件进行编辑。但是，当我将markdown文件打开，修改title为中文，且输入中文博客时，再运行rake generate生成博客页面时，会报告编码错误。信息为：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>gems/ruby-1.9.2-p290/gems/jekyll-0.11.0/lib/jekyll/convertible.rb:32:in `read_yaml': invalid byte sequence in US-ASCII (ArgumentError)</span></code></pre></td></tr></table></div></figure>


<p>这是因为jekyll代码没有很好地支持多种编码的缘故。解决办法是找到提示信息中的convertible.rb文件，将第29行的如下代码：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">self</span><span class="o">.</span><span class="n">content</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="no">File</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="nb">name</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>修改为：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="nb">self</span><span class="o">.</span><span class="n">content</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="no">File</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="nb">name</span><span class="p">),</span> <span class="ss">:encoding</span> <span class="o">=&gt;</span> <span class="s2">&quot;utf-8&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>有的<a href="http://jokry.com/2012/03/08/octopress/">博客</a>还提到ruby环境的问题。我并没有碰到。我使用的版本是ruby 1.9.3。如果遇到类似问题，根据这篇博客的讲解，可以修改ruby环境下的setup_environment.bat文件，在文件最后加入2行：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>set LC_ALL=en_US.UTF-8
</span><span class='line'>set LANG=en_US.UTF-8</span></code></pre></td></tr></table></div></figure>


<p><strong>中文博客名称的问题</strong></p>

<p>前面已经提到，rake new_post[&#8220;&#8221;]命令会将双引号引起来的标题作为blog链接的一部分。这就必然导致一个问题，就是我们无法在new_post[&#8220;&#8221;]命令中直接使用中文作为博客的标题。带来的问题是，我们每次都需要在创建了博客之后，再打开markdown文件，去修改文件前方的title内容为中文。这无疑增加了工作量。解决的办法很简单，因为new_post就是一个rake任务而已，我们可以参照该任务，创建一个自己的任务，添加一个新的参数alias，将它作为我们需要的中文标题。</p>

<p>打开在octopress根目录下的Rakefile文件，在文件末尾增加如下代码：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>desc "Begin a new post in #{source_dir}/#{posts_dir} with Alias"
</span><span class='line'>task :post, :title, :title_alias do |t, args|
</span><span class='line'>  raise "### You haven't set anything up yet. First run `rake install` to set up an Octopress theme." unless File.directory?(source_dir)
</span><span class='line'>  mkdir_p "#{source_dir}/#{posts_dir}"
</span><span class='line'>  args.with_defaults(:title => 'new-post')
</span><span class='line'>  title = args.title
</span><span class='line'>  title_alias = args.title_alias
</span><span class='line'>  filename = "#{source_dir}/#{posts_dir}/#{Time.now.strftime('%Y-%m-%d')}-#{title.to_url}.#{new_post_ext}"
</span><span class='line'>  if File.exist?(filename)
</span><span class='line'>    abort("rake aborted!") if ask("#{filename} already exists. Do you want to overwrite?", ['y', 'n']) == 'n'
</span><span class='line'>  end
</span><span class='line'>  puts "Creating new post: #{filename}"
</span><span class='line'>  open(filename, 'w') do |post|
</span><span class='line'>    post.puts "---"
</span><span class='line'>    post.puts "layout: post"
</span><span class='line'>    post.puts "title: \"#{title_alias}\""
</span><span class='line'>    post.puts "date: #{Time.now.strftime('%Y-%m-%d %H:%M')}"
</span><span class='line'>    post.puts "comments: true"
</span><span class='line'>    post.puts "categories: "
</span><span class='line'>    post.puts "---"
</span><span class='line'>  end
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>新的post任务接收两个参数，第一个参数与之前的new_post任务需要的参数完全相同，第二个参数alias就可以设置到markdown文件的title:中。例如我们要建立一个博客，标题为“如何建立Octopress博客”，则可以输入命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>rake post["How to create octopress blog","如何建立Octopress博客"]</span></code></pre></td></tr></table></div></figure>


<p><strong>注意，除了第二个参数引号内的内容可以用中文外，其他字符包括双引号、逗号和中括号都应该是Utf-8字符。此外，Title和Alias之间用“,”隔开，“,”后不能加空格。</strong></p>

<p><strong>图片问题</strong></p>

<p>加入图片在Octopress中，支持的Markdown语法为[使用时，请去掉%前面的空格]：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{ % img [position] [url] [width] [height] %}</span></code></pre></td></tr></table></div></figure>


<p>position可以设置为left，right或center。url可以是网上的图片url。如果是自己博客的图片，通常建议放在source/images目录下。为了将来更好地维护，建议按照年和月建立两层目录，如2012/12。因为rake generate命令会自动生成博客，放在source/images目录下的图片也会被复制过去。因而在markdown的img语法中，图片的url应该是/images/2012/12/picture.jpg。</p>

<p><strong>代码问题</strong></p>

<p>Octopress支持的代码高亮有很多。我个人还是比较喜欢直接用codeblock标签。虽然每次敲入这个codeblock不太方便，但它胜在灵活见解。例如，粘贴的代码为ruby语言，就可以在代码片段前后分别加上[使用时，请去掉%前面的空格]：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>{ % codeblock lang:ruby %}
</span><span class='line'># Here is ruby source code
</span><span class='line'>{ % endcodeblock %}</span></code></pre></td></tr></table></div></figure>


<p><strong>摘要问题</strong></p>

<p>如果希望在首页只显示一部分内容，例如摘要，也非常简单。只需要在你希望首页显示的内容最后，输入：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;!--more--></span></code></pre></td></tr></table></div></figure>


<p><strong>插件</strong></p>

<p>在<a href="http://octopress.org/docs/">Octopress官方网站</a>提供了一些插件说明和相关链接，但还有一些第三方的插件是放在这个<a href="https://github.com/imathis/octopress/wiki/3rd-party-plugins">网站链接</a>下的。我自己也写了一个针对新浪微博的插件，会在下一篇博客中详细介绍。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[文学与软件]]></title>
    <link href="http://agiledon.github.com/blog/2012/12/21/literature-and-software/"/>
    <updated>2012-12-21T18:59:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2012/12/21/literature-and-software</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://agiledon.github.com/images/2012/12/dafenqi.jpg" width="182" height="276"></p>

<p> 卡尔维诺在哈佛大学的文学讲座（即诺顿论坛，是为纪念美国著名学者诺顿开设的，每年邀请世界文化名人作讲座，艾略特、博尔赫斯也曾获邀参加诺顿讲座）被他的妻子编成了一本独立的书《美国讲稿》。这本书展现了卡尔维诺的文学精神，体现了他的文学态度和气质。不过，我在阅读该书时，却发现了一些与编程有关的内容。</p>

<p>1、文学中的重构</p>

<p> 达芬奇在《大西洋草图》中记述了他幻想中海怪的形象，进行了前后三次重构。最初的描述是：</p>

<p><strong>啊，人们多次在波浪翻滚的广阔海洋之中看到你，看到你那长满鬃毛的黑色背脊，你像一座大山，傲慢地徐徐前进！</strong></p>

<!--more-->


<p>然后，他试图使海怪的行动生动些，加了个动词“翻转”：</p>

<p><strong>啊，人们多次在波浪翻滚的广阔海洋之中看到你，看到你在海水中傲慢地徐徐翻转身躯，看见你那长满鬃毛的黑色背脊。你像一座大山屹立在海浪之上！</strong></p>

<p>然而，他觉得“翻转”这个词削弱了他想留给人们的那种雄伟与庄严的印象，于是选择了“分开”这个动词，并改变了句子结构，使句子变得更紧凑，更有节奏。</p>

<p><strong>啊，人们多次在波浪翻滚的广阔海洋中看到你！你像一座山屹立在海浪之上。你傲慢地徐徐前进，用那长满鬃毛的黑色背脊把海水分成两半!</strong></p>

<p>在文学创作中，重构其实会经常发生，这源于作家对文学作品高质量追求的精益求精，他们常常通过修改句式，修辞手法或改变词语来改善文字，使之体现恰如其分的美。编码艺术同样如此，即使是代码的结构，以及变量、方法和类的命名，排版样式，只要给予足够的重视，锤炼这方面的技能，坚持重构，就能改善编码质量。</p>

<p>2、封装与接口</p>

<p>卡尔维诺在“精确”一章中引述了哲学家们对语言和外部世界关系的思考：</p>

<p><strong>使用语言是对事物的不断追求，不是渐渐接近事物的本质而是接近事物那无休止的变化，接近事物那多种多样的、无穷无尽的表面。正如霍夫曼斯塔尔所说：“深层应该掩盖起来。掩盖在哪里？掩盖在表层下面。” 维特根斯坦走得更远，他说：“凡被掩盖的东西，我们都没有兴趣。”</strong></p>

<p>在软件开发中，我们常常运用封装来隐藏内部的实现细节。它带来的好处是使得调用变得简单，重用成为可能，很好地隔离了内部实现的变化。当然，文学更善于挖掘内部的玄奥，却常常使用抽象的语言描述出一种晦涩，试图掩盖这种玄奥，以此追求一种寻找“高山流水”知音般心灵激荡的玄妙与浃肌沦髓。</p>

<p>文学也尝试用变化去处理变化，这似乎矛盾，却恰好是文学艺术让人着迷的地方。软件又何尝不是如此。卡尔维诺看到了两种变与不变的模式：</p>

<p>最近我偶然读到生物形成过程的模式：“一边是晶体（象征表面结构稳定而规则），一边是火焰（虽然它的内部在不停地激荡，但外部形式不变）。”……火焰与晶体这两种形象代表了生物学上的两种选择。</p>

<p>皮亚杰观点的哲学蕴含是“从噪音到有序”，即火焰；乔姆斯基观点的哲学蕴含是“自我编制系统”，即晶体。</p>

<p><img class="right" src="http://agiledon.github.com/images/2012/12/america.jpg" width="189" height="266"></p>

<p>这仿佛让我洞悉了面向对象设计的玄机。火焰代表了接口，无论如何变化，其外部形式总是不变。接口的引入使得软件设计可以从混沌（即皮亚杰所说的“噪音”）走向有序。至于晶体，则是遵循了信息专家模式的对象，因为它封装了数据以及操作该数据的行为，使得它具有了自我判断的意识。它的表面结构仍然是稳定的，却有一套自我约束的规则。晶体看起来是宁静的，而火焰却如此的灵活。融合晶体与火焰的系统，是否代表了对变化的封装，以及对不变概念的抽象呢？</p>

<p>3、纠缠的细节</p>

<p>薄伽丘在一篇故事中（《十日谈》第六天第一个故事）谈到讲故事的艺术，正好回顾了这种感觉。</p>

<p>**“奥丽达太太，要是你不讨厌的话，我想讲一个世界上最大的故事给你听，叫你听得津津有味，就像骑了一匹马一样，往了路途的遥远。”</p>

<p>“啊，再好没有了，先生，”那位太太说，“请你快给我讲一个故事吧。”</p>

<p>于是绅士开始讲故事给她听。故事倒很精彩，可惜他讲故事的本领，只抵得上他使用他身边那把佩剑的工夫，实在太不高明，时常把一句话颠来倒去的说了又说，甚至说上六七遍，过了一会，忽然又倒过头来说道：“哎呀，我说错啦！”对于故事中的人名地名常常纠缠不清，张冠李戴，弄得别人莫名奇妙。他那说话的声气又跟故事里的人物、情景一点都配不上，真是听得奥丽达太太头晕目眩，冷汗一身，只觉得大祸临头，连命都快要保不住了。到最后，她忍无可忍，又看见那位绅士正愈说愈糊涂，已经迷了路，失了方向，只是在那儿团团打转，再也跑不出来了，就和悦地对他说：“先生，你那匹马跑得太野，请你还是让我下了马吧。”**</p>

<p>在软件设计过程中，最要紧的是思路要清晰，既不能迷失在需求分析中，也不能迷失在复杂的实现细节中。最好能够结合实际的场景，列出我们要达到的目标，需要完成的任务，有序地进行分析和设计。编写代码时，切忌功能之间互相纠缠，虽然体现了对象的协作，但由于职责分配混乱，使得对象之间的协作变得无规律可循，颠三倒四，最后让人忍无可忍，也只能翻身下马了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[geek pictures in Brisbane]]></title>
    <link href="http://agiledon.github.com/blog/2012/12/21/geek-pictures-in-brisbane/"/>
    <updated>2012-12-21T17:01:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2012/12/21/geek-pictures-in-brisbane</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2012/12/spring.jpg" width="567" height="340">
这是我在今年四月到澳洲Brisbane街头拍到的一组照片，Geek们，看到这些名称，是否有些熟悉的感觉呢？</p>

<!--more-->


<p><img class="center" src="http://agiledon.github.com/images/2012/12/fitness.jpg" width="567" height="340"></p>

<p><img class="center" src="http://agiledon.github.com/images/2012/12/hudson.jpg" width="567" height="340"></p>

<p><img class="center" src="http://agiledon.github.com/images/2012/12/groovy.jpg" width="425" height="709"></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件系统的稳定性]]></title>
    <link href="http://agiledon.github.com/blog/2012/12/20/stability-of-software-system/"/>
    <updated>2012-12-20T19:59:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2012/12/20/stability-of-software-system</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2012/12/stability.jpg" width="290" height="387"></p>

<p>软件系统的稳定性，主要决定于整体的系统架构设计，然而也不可忽略编程的细节，正所谓“千里之堤，溃于蚁穴”，一旦考虑不周，看似无关紧要的代码片段可能会带来整体软件系统的崩溃。这正是我阅读Release It!的直接感受。究其原因，一方面是程序员对代码质量的追求不够，在项目进度的压力下，只考虑了功能实现，而不用过多的追求质量属性；第二则是对编程语言的正确编码方式不够了解，不知如何有效而正确的编码；第三则是知识量的不足，在编程时没有意识到实现会对哪些因素造成影响。</p>

<!--more-->


<p>例如在Release It!一书中，给出了如下的Java代码片段：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kn">package</span> <span class="n">com</span><span class="o">.</span><span class="na">example</span><span class="o">.</span><span class="na">cf</span><span class="o">.</span><span class="na">flightsearch</span><span class="o">;</span>
</span><span class='line'><span class="c1">//...</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">FlightSearch</span> <span class="kd">implements</span> <span class="n">SessionBean</span> <span class="o">{</span>
</span><span class='line'>   <span class="kd">private</span> <span class="n">MonitoredDataSource</span> <span class="n">connectionPool</span><span class="o">;</span>
</span><span class='line'>   <span class="kd">public</span> <span class="n">List</span> <span class="nf">lookupByCity</span><span class="o">(.</span> <span class="o">.</span> <span class="o">.)</span> <span class="kd">throws</span> <span class="n">SQLException</span><span class="o">,</span> <span class="n">RemoteException</span> <span class="o">{</span>
</span><span class='line'>       <span class="n">Connection</span> <span class="n">conn</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>       <span class="n">Statement</span> <span class="n">stmt</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>       <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>           <span class="n">conn</span> <span class="o">=</span> <span class="n">connectionPool</span><span class="o">.</span><span class="na">getConnection</span><span class="o">();</span>
</span><span class='line'>           <span class="n">stmt</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="na">createStatement</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>           <span class="c1">// Do the lookup logic</span>
</span><span class='line'>           <span class="c1">// return a list of results</span>
</span><span class='line'>       <span class="o">}</span> <span class="k">finally</span> <span class="o">{</span>
</span><span class='line'>           <span class="k">if</span> <span class="o">(</span><span class="n">stmt</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>               <span class="n">stmt</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span><span class='line'>           <span class="o">}</span>
</span><span class='line'>           <span class="k">if</span> <span class="o">(</span><span class="n">conn</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>               <span class="n">conn</span><span class="o">.</span><span class="na">close</span><span class="o">();</span>
</span><span class='line'>           <span class="o">}</span>
</span><span class='line'>       <span class="o">}</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>正是这一小段代码，是造成Airline系统崩溃的罪魁祸首。程序员充分地考虑了资源的释放，但在这段代码中他却没有对多个资源的释放给予足够的重视，而是以释放单资源的做法去处理多资源。在finally语句块中，如果释放Statement资源的操作失败了，就可能抛出异常，因为在finally中并没有捕获这种异常，就会导致后面的conn.close()语句没有执行，从而导致Connection资源未能及时释放。最终导致连接池中存放了大量未能及时释放的Connection资源，却不能得到使用，直到连接池满。当后续请求lookupByCity()时，就会在调用connectionPool.getConnection()方法时被阻塞。这些被阻塞的请求会越来越多，最后导致资源耗尽，整个系统崩溃。</p>

<p><img class="center" src="http://agiledon.github.com/images/2012/12/releaseIt.jpg" width="333" height="399"></p>

<p>Release It!的作者对Java中同步方法的使用也提出了警告。同步方法虽然可以较好地解决并发问题，在一定程度上可以避免出现资源抢占、竟态条件和死锁的情况。但它的一个副作用同步锁可能导致线程阻塞。这就要求同步方法的执行时间不能太长。此外，Java的接口方法是不能标记synchronized关键字。当我们在调用封装好的第三方API时，基于“面向接口设计”的原理，可能调用者只知道公开的接口方法，却不知道实现类事实上将其实现为同步方法，这种未知性就可能存在隐患。</p>

<p>假设有这样的一个接口：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">GlobalObjectCache</span> <span class="o">{</span>
</span><span class='line'>   <span class="kd">public</span> <span class="n">Object</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">id</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果接口方法get()的实现如下：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">synchronized</span> <span class="n">Object</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">id</span><span class="o">){</span>
</span><span class='line'>   <span class="n">Object</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
</span><span class='line'>   <span class="k">if</span><span class="o">(</span><span class="n">obj</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>       <span class="n">obj</span> <span class="o">=</span> <span class="n">create</span><span class="o">(</span><span class="n">id</span><span class="o">);</span>
</span><span class='line'>       <span class="n">items</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">id</span><span class="o">,</span> <span class="n">obj</span><span class="o">);</span>
</span><span class='line'>   <span class="o">}</span>
</span><span class='line'>   <span class="k">return</span> <span class="n">obj</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="kd">protected</span> <span class="n">Object</span> <span class="nf">create</span><span class="o">(</span><span class="n">String</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>   <span class="c1">//...</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这段代码很简单，当调用者试图根据id获得目标对象时，首先会在Cache中寻找，如果有就直接返回；否则通过create()方法获得目标对象，然后再将它存储到Cache中。create()方法是该类定义的一个非final方法，它执行了DB的查询功能。现在，假设使用该类的用户对它进行了扩展，例如定义RemoteAvailabilityCache类派生该类，并重写create()方法，将原来的本地调用改为远程调用。问题出现了。由于采用create()方法是远程调用，当服务端比较繁忙时，发出的远程调用请求可能会被阻塞。由于get()方法是同步方法，在方法体内，每次只能有一个线程访问它，直到方法执行完毕释放锁。现在create()方法被阻塞，就会导致其他试图调用RemoteAvailabilityCache对象的get()方法的线程随之而被阻塞。进而可能导致系统崩溃。</p>

<p>当然，我们可以认为这种扩展本身是不合理的。但从设计的角度来看，它并没有违背Liskove替换原则。从接口的角度看，它的行为也没有发生任何改变，仅仅是实现发生了变化。如果不是同步方法，则一个调用线程的阻塞并不会影响到其他调用线程，问题就可以避免了。当然，这里的同步方法本身是合理的，因为只有采取同步的方式才能保证对Cache的读取是支持并发的。书中给出这个例子，无非是要说明同步方法潜在的危险，提示我们在编写代码时，需要考虑周全。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NoSQL走向成熟]]></title>
    <link href="http://agiledon.github.com/blog/2012/12/18/nosql-is-growing-up/"/>
    <updated>2012-12-18T17:49:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2012/12/18/nosql-is-growing-up</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://agiledon.github.com/images/2012/12/architect201212.jpg" width="283" height="400"></p>

<p><strong>本文是InfoQ中文站2012年12月《架构师》刊首语。</strong></p>

<p>在玛雅预言中的末世之年，整个IT业界却似乎可以用“波澜不惊”四个字来概括。没有惊天动地的大新闻来攫取眼球，对于媒体人而言，或许是一种不幸；但对于程序员，却可以减少太多技术选择带来的茫然。没有你方唱罢我登场的喧嚣，没有概念经济的浮夸与炒作，许多技术于是从绚烂归于平淡。</p>

<p>技术由绚烂归于平淡，并不意味着它将落伍于时代，退出历史舞台，而是大浪淘沙炼出真金，乃返璞归真的升华。业界颇有几种技术正是沿着这样的发展脉络不屈地前进，例如本期《架构师》专题讨论的技术NoSQL。</p>

<!--more-->


<p>编者认为，NoSQL在褪去浮华之后，已经逐渐迈向了成熟。一个标志是用户群的增加。虽然，Martin Fowler在去年<a href="http://www.infoq.com/cn/articles/nosql-distilled-book-review">接受InfoQ的采访</a>时，认为：“关系数据库仍然是大多数情况下的选择，至少未来几年是这样的。毕竟，关系数据库产品很成熟，有丰富的支持工具，而且相对来说人们对它们已经有很好地理解了。”但他同样对采用NoSQL技术的项目表示信心满满。</p>

<p>可以看到，许多NoSQL技术已经在互联网应用以及大数据处理方面露出峥嵘，即使是在企业应用领域，它们也逐渐崭露头角。以文档数据库为例，作为个中翘楚的MongoDB，就被SoureForge、MTV等互联网站广泛使用。而作为全球排名第一的ERP软件开放商SAP，也将MongoDB作为其PaaS平台的核心组件，用以支持企业内容管理（Enterprise Content Management）。Neo4j作为图形数据库的领跑者，目前已有许多财富500强的企业如Adobe，Cisco成为了Neo4j的客户。</p>

<p>提及NoSQL技术，就不能不提到它与关系型数据库之间的关系，尤其是我们在实际运用中，会面临一个棘手的问题，那就是如何实现关系数据库到NoSQL的平滑迁移。很显然，只要支持这一特性，就能更好地将NoSQL运用到遗留系统的技术栈迁移场景，拓宽NoSQL技术的应用范围。MongoDB很好地做到了这一点，例如<a href="http://www.serverdensity.com/">Server Density</a>就选择了从MySQL迁移到MongoDB。</p>

<p>不仅是MongoDB支持这种迁移，Couchbase支持的特性也不让MongoDB专美于前。本期《架构师》的专题文章《<a href="http://www.infoq.com/cn/articles/Transition-RDBMS-NoSQL">从关系数据库向NoSQL迁移：采访Couchbase的产品管理主管Dipti Borkar</a>》介绍了使用Couchbase进行这种迁移的时机、步骤、困难以及选择NoSQL的优点。</p>

<p>NoSQL产品之间的良性竞争也可以从另一个侧面证明NoSQL技术的成熟。例如CouchDB与MongoDB之间的竞争。事实上，CouchDB这种使用JSON作为文档，运用JavaScript完成MapReduce查询的方式，以及侧重于Availability（可用性）与Partition-Tolerance（分区容忍度）的表现（相对而言，MongoDB更侧重于一致性与分区容忍度），使得它迅速成为了诸多互联网站的新宠。本期专题文章《<a href="http://www.infoq.com/cn/articles/warner-couchdb">CouchDB是什么？为什么我们要关注它？</a>》非常详细地介绍了CouchDB。</p>

<p>或许，我们还可以从各种NoSQL产品的版本来判断NoSQL的成熟度，例如MongoDB的版本已经发展到2.2.2，Neo4j的版本发展到了1.9。不过，这种判断未免有些草率。判断成熟度的另一个佐证则是该技术是否产生了大量相关的衍伸产品。Martin Fowler在展望 NoSQL数据库市场的发展趋势时，就认为“现在的一切都是在添加工具和成熟度，使这些数据库更容易很好地使用。”对于 NoSQL技术，我们确实看到了这种趋势，如Apache GORA与Spring Data的出现。Spring Data提供了访问数据库的统一API，因为它既能支持关系型数据库，又能支持REST、大数据以及主流的NoSQL数据库，如MongoDB、Neo4j等。Apache GORA则是NoSQL数据库的ORM框架，提供了各种NoSQL数据存储之上的统一前端。专题文章《<a href="http://www.infoq.com/cn/articles/nioche-apache-nutch2">Julien Nioche谈Apache Nutch 2的特性及产品路线图</a>》在介绍Web搜索框架Nutch时，谈到了它与NoSQL以及ORM框架GORA之间的关系。</p>

<p>此外，还有许多创新的NoSQL产品的出现，让人眼睛一亮。例如提供不可变数据库服务器的<a href="http://www.datomic.com/">Datomic</a>，具备事务管理和部署的特性，并能在云中将数据库作为服务提供给用户。还有<a href="https://voltdb.com/">VoltDB</a>，它尝试在提供可伸缩性的同时使用SQL范型。或许它们不能完全划归到NoSQL类别中，而应该称之为NewSQL，甚至是MoreSQL。<a href="https://451research.com/">451 Group</a>的高级分析师Matthew Aslett就将NoSQL定义为“旨在满足分布式体系结构的可扩展性需求和/或无模式数据管理需求”，NewSQL则被定义为“旨在满足分布式体系结构的需求，或提高性能以便不必再进行横向扩展”。Alexander Tatiyants撰写的文章《<a href="http://tatiyants.com/nosql-no-more-lets-double-down-with-moresql">NoSQL No More: Let’s double down with MoreSQL</a>》，则掀起了MoreSQL的热潮。个人认为，这些技术事实上还是NoSQL技术的一种发展。</p>

<p>我们还可以预见，在很长一段时间内，会存在关系数据库与NoSQL并存的状态，甚至在同一个系统中出现，这正是Martin Fowler所谓的<a href="http://martinfowler.com/bliki/PolyglotPersistence.html">Polyglot Persistence</a>。这显然是由这两种不同类型的数据库，甚至是不同类别的NoSQL数据库各自适应的场景不同导致的必然结果。无论如何，种种迹象证明，NoSQL技术已经走向成熟，是到了该收获果实的季节了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在MAC的IntelliJ下使用SBT与ScalaTest]]></title>
    <link href="http://agiledon.github.com/blog/2012/10/11/use-sbt-in-intellij/"/>
    <updated>2012-10-11T12:34:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2012/10/11/use-sbt-in-intellij</id>
    <content type="html"><![CDATA[<p>正如我们在Java项目中会使用Maven或Gradle作为构建工具一样，在Scala中，最为流行的构建非SBT莫属。在Mac下安装SBT其实很容易，你可以用Macports或者homebrew来安装，只需要敲一条命令即可。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>port install sbt</span></code></pre></td></tr></table></div></figure>


<p>或者：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>brew install sbt</span></code></pre></td></tr></table></div></figure>


<p>要在IntelliJ Idea下要使用SBT似乎也很简单，因为你可以直接在Idea中下载安装sbt的插件。这一点都不费功夫。但我现在希望sbt对依赖的管理，要能很好地集成到Idea中。就像gradle一样，我只需要在build.gradle脚本中添加：apply plugin: &#8216;idea&#8217;，就可以在命令行中运行gradle idea，然后就能更新IntelliJ中项目的依赖了。例如，我要在IntelliJ中的Scala项目中使用ScalaTest来写单元测试。为了获得该ScalaTest Repository，就可以在build.sbt中添加：</p>

<!--more-->




<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">libraryDependencies</span> <span class="o">+=</span> <span class="s">&quot;org.scalatest&quot;</span> <span class="o">%</span> <span class="s">&quot;scalatest_2.9.1&quot;</span> <span class="o">%</span> <span class="s">&quot;1.8&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，在sbt文件中一定要有一条空行哦，不然就会报错。现在，转到项目主目录下，运行sbt的命令，就能自动下载scalatest的包了。可惜这样还不够，因为即使下载了scalatest，IntelliJ仍然拒绝认识它，然后很恼人地给出红色错误提示。例如在test目录下写一个scalatest的单元测试：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">org.junit.runner.RunWith</span>
</span><span class='line'><span class="k">import</span> <span class="nn">org.scalatest.junit.JUnitRunner</span>
</span><span class='line'><span class="k">import</span> <span class="nn">org.scalatest.Suite</span>
</span><span class='line'>
</span><span class='line'><span class="nd">@RunWith</span><span class="o">(</span><span class="n">classOf</span><span class="o">[</span><span class="kt">JUnitRunner</span><span class="o">])</span>
</span><span class='line'><span class="k">class</span> <span class="nc">MySuiteTest</span> <span class="k">extends</span> <span class="nc">Suite</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="n">testAddition</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">val</span> <span class="n">sum</span> <span class="k">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="n">sum</span> <span class="o">===</span> <span class="mi">2</span><span class="o">)</span>
</span><span class='line'>    <span class="n">assert</span><span class="o">(</span><span class="n">sum</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">===</span> <span class="mi">4</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>它根本就不认识JUnit和ScalaTest，所以类似Suite，@RunWith之类的东西皆为红色，看着让人闹心。当然，我在这里还用了JUnit，所以还需要在build.sbt中添加JUnit的依赖。</p>

<p>要想能够在IntelliJ Idea中更新项目，就像Gradle一样，也需要专门为idea服务的插件，sbt中即为sbt-idea。方法是在mac的用户主目录下，找到.sbt/plugins目录，然后看看有没有build.sbt文件。如果没有，就创建一个。事实上，要是连.sbt/plugins目录也没有找到，没关系，同样可以自己创建。接下来，在build.sbt文件中写入：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">resolvers</span> <span class="o">+=</span> <span class="s">&quot;sbt-idea-repo&quot;</span> <span class="n">at</span> <span class="s">&quot;http://mpeltonen.github.com/maven/&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">addSbtPlugin</span><span class="o">(</span><span class="s">&quot;com.github.mpeltonen&quot;</span> <span class="o">%%</span> <span class="s">&quot;sbt-idea&quot;</span> <span class="o">%</span> <span class="s">&quot;1.1.0&quot;</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>添加了这个插件后，就可以回到自己项目的目录下，运行sbt gen-idea，就可以更新IntelliJ Idea中的项目了。再看看Idea中的代码，之前那些恼人的红色应该就会消失了。</p>

<p>在使用ScalaTest时，还碰到一个小问题。我在搜寻scalatest的repository时（在Maven Repository），直接打开了第一个搜索结果，最新的版本是1.4 RC2。它的sbt repository为：libraryDependencies += &#8220;org.scalatest&#8221; % &#8220;scalatest&#8221; % &#8220;1.4.RC2&#8221;</p>

<p>结果就悲剧了，跑测试怎么样也跑不过，抛出的异常为：java.lang.ClassCastException: scala.collection.immutable.Set$EmptySet$ cannot be cast to scala.collection.generic.Addable</p>

<p>最初，我没有想到是scala与scalatest版本不匹配的问题，还以为自己的单元测试语法不对。几经搜寻，在搜到的这个帖子（http://www.scala-lang.org/node/11466）上看到版本不兼容问题，我才如大梦初醒般，想着去查询各自的版本。我使用的scala为最新版本2.9.2，而scalatest的1.4 RC2依赖的是scala 2.8.0版本。而就在这篇帖子中，则提到scala是向前兼容，却不支持向后兼容。我在Maven Repository中又做了一次搜索，结果发现scalatest的第二条搜索结果，才是我需要的，它的最新版本是2.0 M4，最新稳定版本则为1.8，都依赖于Scala 2.9.1。这就是说，与我使用的scala仅有最小版本的区别。在build.sbt中更改为该版本的repository（即前面给出的内容），测试就可以通过了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tasking in TDD]]></title>
    <link href="http://agiledon.github.com/blog/2012/08/25/tasking-in-tdd/"/>
    <updated>2012-08-25T12:59:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2012/08/25/tasking-in-tdd</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://agiledon.github.com/images/2012/12/tdd.jpg" width="240" height="293">
我和同事李彦辉今天结对实现了一个User Story，这个故事的需求在昨天已经讨论得比较清楚，其中一部分工作因为数据安全以及部署基础设施的原因，由澳洲的客户来实现完成。因此，我们的工作就变成为将消息propogate到指定的external queue。这事实上可以理解为两部分工作，第一是生成或组装Queue希望获得的消息，第二才是消息的propogation。</p>

<p>消息的获得大约要经历如下步骤。首先是通过GlobalCustomer的Id，获得对应的指定产品的ProductCustomer（可能包含多个）。由于GlobalCustomer与ProductCustomer之间存在多对多的关系，我们还需要根据获得的每个ProductCustomer，逆向反推出它所对应的GlobalCustomer（可能包含多个）。在得到ProductCustomer对应的GlobalCustomer后，再调用GetConsent的Web Service，获得每个GlobalCustomer对应的Consent信息。之后，再根据Consent信息中包含的某些Indicator值，运用业务规则，获得最终external queue需要的由indicator值以及客户的基本信息组成的消息。</p>

<!--more-->


<p>在分解任务时，我的直觉告诉我可以通过这个分析出来的执行步骤来划分任务，而且我们事先已经获知，查询GlobalCustomer与ProductCustomer之间的信息可以通过调用系统已有的EjbBean来实现。根据这样的任务分解，我们进行测试驱动，似乎可以编写的第一个测试用例为：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Test</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_retieve_associate_product_customers_by_global_customer_id</span><span class="o">(){</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然而，在开始测试驱动时，我首先想到的是我们自己的Service如何与已有的CustomerDao(其内部又调用了FindProfile的EjbBean）进行交互，所以我打算先写一个基础的测试用例，表现这种对象的协作关系，例如：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Test</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_invoke_CustomerDao</span><span class="o">(){</span>
</span><span class='line'>  <span class="n">CustomerDao</span> <span class="n">dao</span> <span class="o">=</span> <span class="n">createMock</span><span class="o">(</span><span class="n">CustomerDao</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>  <span class="n">expect</span><span class="o">(</span><span class="n">dao</span><span class="o">.</span><span class="na">findProductCustomersBy</span><span class="o">(</span><span class="n">customerId</span><span class="o">).</span><span class="na">andReturn</span><span class="o">(</span><span class="n">productCustomers</span><span class="o">);</span>
</span><span class='line'>  <span class="n">replay</span><span class="o">(</span><span class="n">dao</span><span class="o">);</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">retrieveService</span> <span class="o">=</span> <span class="k">new</span> <span class="n">RetrieveCustomerService</span><span class="o">(</span><span class="n">dao</span><span class="o">);</span>
</span><span class='line'>  <span class="n">retrieveService</span><span class="o">.</span><span class="na">retrieve</span><span class="o">(</span><span class="n">customerId</span><span class="o">);</span>
</span><span class='line'>  
</span><span class='line'>  <span class="n">verify</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然而，这似乎只是一个简单的职责委派，编写这样的一个测试用例并没有任何价值。同事认为，我们在分解任务时，应该从功能上分析，即根据指定的GlobalCustomer的id获得一个具有ProductCustomer与GlobalCustomer映射关系的最终对象，这个映射关系需要一个概念来表示。经过分析，这个概念其实就是最终我们要得到的GlobalCustomer，区别在于这个retrieve的行为，它需要表现领域特征。这个行为的输入是GlobalCustomerId，输出则是List<GlobalCustomer>。这样分解的好处是可以直接寻找到我们需要的接口，再通过这个测试用例去驱动我们的设计。例如，我们编写出这样的测试用例：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Test</span>
</span><span class='line'><span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_retrieve_associate_global_customers_which_have_same_product_customer</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">List</span><span class="o">&lt;</span><span class="n">GlobalCustomer</span><span class="o">&gt;</span> <span class="n">gCustomers</span> <span class="o">=</span> <span class="n">service</span><span class="o">.</span><span class="na">retrieve</span><span class="o">(</span><span class="n">gCustomerId</span><span class="o">);</span>
</span><span class='line'>  <span class="n">assertThat</span><span class="o">(</span><span class="n">gCustomers</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="mi">5</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们对retrieve()这个名称并不满意，但目前我们没有找到合适的行为概念，所以就保留了这一定义。因为我们有测试保证，一旦找到正确的行为特征，我们可以及时重构。在这个测试用例中，我们对返回结果进行的断言是不合理的，因为这个断言断定了返回的结果数目。这可能是不稳定的。为了保证测试的稳定性，我们需要为其准备数据。我们分别为GlobalCustomer与ProductCustomer定义了Builder来构建测试数据。而随着对这个测试用例的逐渐完善，我们发现了在CustomerDao中还需要提供一个方法findGlobalCustomerBy(productId, productCustomerId)。我们可以继续对CustomerDao提供Mock实现，但最好的方式是转移阵地，先为CustomerDao编写单元测试。</p>

<p>我忠实地记录了今天结对时，进行任务分解的过程。然而我一直在思考，可否通过我建立的职责模型来帮助我们进行业务分解呢？这个职责模型如下图所示：</p>

<p><img class="center" src="http://agiledon.github.com/images/2012/12/responsibility.png" width="191" height="181"></p>

<p>我在这个模型中将职责分为三个层次：业务价值、业务功能与业务实现。这里有个前提，就是在划分职责时，需要基于某个特定的场景。就好像我们在识别用例时，需要识别用例的边界一般。通常意义上，业务价值就是在实现这个需求时，你的消费者（可以是UI的视图、控制器，又或者是领域层，或者客户端）所希望调用的接口。这个消费者可以理解为角色，它是参与这个场景的入口，识别职责就是从角色的视角出发，理解需求。</p>

<p>在编写User Story时，我们有一个固定的模板，即as……，I want to……，So that……。这里的as子句就是要我们寻找的角色。注意，这里的角色不一定是具体映射到现实世界中的人，而应该是参与者，可能是人，也可能是系统的某个对象。So that就是这个User Story所要体现的价值。这与User Story的INVEST原则中的V是完全一致的。</p>

<p>当我们识别出业务价值后，它就成为了我们需要识别的最外部接口，我们就可以按照这个业务价值来进行测试驱动。当然，谨慎的做法是再继续细分，在识别价值后，分析实现这些价值应该由哪些业务功能组成。我的同事李彦辉认为这就是寻找解决方案的过程。不同的解决方案可能导致不同的测试驱动方向。他提到的一个例子是消息转换。一种解决方案是通过jaxb将消息转换为Java对象，然后再定义转换映射的Transformer，通过硬编码或者反射的方式将其转换为相关的领域对象。在执行了业务操作后，再将返回的结果转换为另一个Jaxb对象。而另一种解决方案则是通过引入模板，例如StringTemplate或者Velocity，定义转换的模板，然后进行替换实现。这两种解决方案的区别，直接影响了我们划分任务的方式。</p>

<p>因此，我们可以将这个识别功能的过程，看做是寻找解决方案的过程。在这个过程中，若有对技术不了解的环节，则需要做一定程度的Spike。Spike的过程仍然可以通过TDD来完成。在《测试驱动开发的艺术（Test Driven-Practical TDD and Acceptance TDD for Java Developers）》一书中，将其称之为学习测试（Learning Test）。此外，Spike需要设定一个TimeBox，以避免陷入无休止的探索中。</p>

<p>我们识别的这些业务功能，组成了实现整个业务价值的每个环节。多个业务功能可能体现的是一个业务流程，也可能随着角色的场景变换（因为场景也可以是嵌套的，即在大的场景中为业务功能的内容，放在小的场景中其实是业务价值），体现不同的设计意图。举例来说，从业务价值看，我们需要提供邮件转发的业务；而在分析邮件转发的业务价值时，又可以得到发送邮件的业务功能。站在实现者角度看，所谓邮件的转发就是发送邮件，但二者在业务概念上还是存在层次上的差别。站在最外层场景的角度来看，转发才是场景消费者真正关心的业务目标。</p>

<p>模型中最里面的一圈为业务实现，它往往关注的是在实现每个功能时，需要通过什么方式来实现，这就可能牵涉到对基础设施的访问，例如对xml文件、数据库、网络方面的调用。分析到这里时，基本上我们已经可以编码实现了。</p>

<p>借助这个模型，我们可以从业务价值这一层开始测试驱动。不过最佳方式应该是在充分地理解需求后，通过探索解决方案以获得业务功能后，再根据功能划分任务。注意，这个模型是有层次的，场景也是可以嵌套的，因而这个过程是一个渐进的过程，是一个层层递进的过程，可以由外及内，也需要在合适的时候，先跳到模型的内层，在对其实现进行测试驱动时，再回到外部一层，关注这个业务价值中各个业务功能对象之间的协作。注意，这种协作本身也可能体现一种业务逻辑。倘若仅仅是单纯的职责委派，就没有编写测试的必要了。</p>

<p>让我们采用这个模型来识别我们要实现的User Story的职责，列举如下：</p>

<pre><code>传播处理后的Consent消息给指定Queue 
    组装并生成需要的Consent消息； 
        根据GlobalCustomerId获得对应的ProductCustomers以及它们所对应的GlobalCustomers； 
            调用FindProfileEjb根据GlobalCustomerId获得对应的ProductCustomers对象； 
            遍历ProductCustomer对象，并调用FindProfileEjb获得对应的GlobalCustomer对象；
        调用WebService获得GlobalCustomer对应的Consent信息； 
        根据业务规则获得该GlobalCustomer正确的Indicator值； 
        根据Indicator值与GlobalCustomer信息组装消息；
    传播消息给指定Queue
</code></pre>

<p>整体看来，这是一个嵌套四层的任务分解列表。最外层的任务就是我们的业务价值，它又被分解为两个业务功能，相当于业务价值实现的两个部分，但却分别承担了两个不同的职责。如果从封装职责的角度来看，这里识别出来的第二个功能所承担的主要职责为消息的propagation，从职责上看，它与承担业务价值的对象（可以命名为PropagateConsentService）有着非常紧密的关系，因而可以直接将该功能分配给它。除非单独的消息传播功能还有其他重用的必要。根据业务价值的第一个功能的描述，其实我们可以定义一个ConsentMessageAssembler，并根据识别出来的下一级功能，得到RetrieveCustomerService。依此类推，这里不再赘述。通过这种业务职责分析模型，在一定程度上也可以帮助我们进行任务分解。最重要的一点还是在于我们要深入地分析需求，理清思路，并通过探寻获得合理的解决方案。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重构-勿以善小而不为]]></title>
    <link href="http://agiledon.github.com/blog/2012/06/28/refactoring-from-beginning/"/>
    <updated>2012-06-28T16:36:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2012/06/28/refactoring-from-beginning</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://agiledon.github.com/images/2012/12/refactoring.jpg" width="400" height="200">
重构最大的敌人不是技巧与能力，而是懒惰，或者说是态度。许多细小的重构看似无足轻重，例如方法重命名，提取方法，即使重构了，似乎对代码的结构也没有太大的影响，于是就决定淡然处之，心里想“事情还未到不可挽回的地步，实现功能要紧，至于重构，还是以后再做吧！”这样一想，于是就会滋生得过且过的想法，等到代码开始变得一团糟时，重构已经变得无比困难了。此时需要的重构技巧，将百倍难于发现坏味道之初。</p>

<p>在我参加的前一个项目中，我们定义了一个处理OrderSet的Controller。刚刚开始开发时，对于OrderSet的操作并不多，主要是Search与Count操作。OrderSet分为WithDetails与WithoutDetail两种类型。为了实现的简单，我们将这两种类型的操作都放在一个Controller中。随着操作的逐渐增多，这个Controller就变得越来越庞大，逐渐变得臃肿起来。每当我需要调用或者修改Controller时，我都在想：“嗯，这个代码太糟糕了，什么时候给它重构一下。”想是这么想，却一直扮演着说话的巨人，行动的矮子。即使兴起这样的念头，又因为其他的工作将此念头浇灭。直到有一天，这个Controller的代码已经到了忍无可忍的地步，我和我的Pair终于达成一致意见，决定对此代码进行手术。我们花费了近一天的时间对Controller以及相关的Repository进行了彻底的重构。重构前后的代码天差地别，我终于可以不用像吃了苍蝇那般看着代码恶心了。这种重构后体验到的愉悦简直无与伦比，最关键是结果令人满意，重构后的代码变得更可读，更简单，也更容易增加新的功能。</p>

<!--more-->


<p>如今工作的项目，需要对遗留系统进行迁移。首要的任务是为此系统编写BDD测试，以期搭建迁移的测试保护网，并能够形成可读与可工作的测试用例文档。在开始接触这个任务时，客户方的开发人员已经基本搭建好了初步的框架。当我们在面对不良代码时，第一个浮现在脑海中的念头是“重构”，然而考虑到时间因素，随之又强迫自己灭了这个念头，因为我们需要考虑项目的进度。我们总是在这样的取舍之中艰难前进，终于，在系统需要增加一个新消息的测试时，我强烈地感受到重构的迫在眉睫。即使代码有诸多破窗，修补了一扇，总强过听之任之。经过接近一天多的重构（当然还包括run tests以及build花费的时间），结果令人满意。回顾这个过程，我发现在发现坏味道时，如果能及时地对代码进行重构，并保证重构的小步前进，并不会阻碍开发进度，相反还能够在一定程度改善代码质量，提高代码的可读性、可重用性以及可扩展性。所谓“勿以善小而不为”，千万不要因为小重构对代码质量的影响微乎其微而轻视她，或者忽略她，又或者推迟到忍无可忍再想到重构。重构并非最后的救命稻草，而是随时保持我们正确前进的一把尺子。</p>

<p>说完了重构的重要性，让我再来粗略地介绍这个重构过程。</p>

<p>我们的测试程序主要针对Message的发送、接收与验证。业务的处理则由部署在JBoss上的应用来处理。我们需要设定期望的Message，在发送请求到远程系统后，接收返回的消息，并验证消息以及数据库是否符合我们的期望。重构的起因在于我们需要编写新的测试覆盖之前从未测试过的消息，其类型为SO08。如果沿用之前的实现，我们就需要在测试步骤中增加MessageType的分支，根据消息类型对返回的消息进行检查。</p>

<p>检查的逻辑事实上已经被抽象为MessageChecker接口，并为各种类型的消息建立了不同的MessageChecker子类。MessageCheckFactory则这些子类的工厂，负责根据类型创建对应的子类对象。这样的设计是完全合理的。然而，问题出现在MessageReceiver，它提供了接收消息的方法，通过传入的消息类型、队列名称等参数，返回消息。这个返回值被定义为MessageReader。</p>

<p>MessageReader正是问题的症结。我一直强调的面向对象设计中一个重要概念就是所谓”对象的自治“，即对象的职责是自我完备的，它能够对自己拥有的数据负责，具备了“智能”处理的行为特征。MessageReader违背了这一原则，它是愚笨的对象，仿佛“坐拥宝山而不知”的笨伯，虽然拥有消息的值，却不知道该如何处理这些消息。简而言之，它提供的方法只能对XML格式的消息进行读取，却不具有真正的业务行为。于是在测试步骤中，就产生了这样的代码（省略了部分实现代码）：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">checkPropagationQueueByName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Queue</span> <span class="n">queue</span><span class="o">,</span> <span class="n">MessageType</span> <span class="n">messageType</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">MessageReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">messageReceiver</span><span class="o">.</span><span class="na">getMessageFor</span><span class="o">(</span><span class="n">messageType</span><span class="o">,</span> <span class="n">identifier</span><span class="o">,</span> <span class="n">queue</span><span class="o">);</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">messageText</span> <span class="o">=</span> <span class="n">reader</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">messageType</span> <span class="o">==</span> <span class="n">SO05</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">messageCheckFactory</span><span class="o">.</span><span class="na">checkerFor</span><span class="o">(</span><span class="n">messageType</span><span class="o">,</span> <span class="n">getExpectedSO05ResponseFor</span><span class="o">(</span><span class="n">name</span><span class="o">),</span> <span class="n">messageText</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">messageType</span> <span class="o">==</span> <span class="n">SO07</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">checkSO07Response</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">messageType</span><span class="o">,</span> <span class="n">messageText</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">messageType</span> <span class="o">==</span> <span class="n">SO08</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">messageCheckFactory</span><span class="o">.</span><span class="na">checkerFor</span><span class="o">(</span><span class="n">messageType</span><span class="o">,</span> <span class="n">getExpectedSO08ResponseFor</span><span class="o">(</span><span class="n">name</span><span class="o">),</span> <span class="n">messageText</span><span class="o">)</span>
</span><span class='line'>      <span class="o">.</span><span class="na">checkResponse</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>不幸的是，这样的逻辑处理在其他测试步骤中同样存在。我注意到，之所以要处理分支，是因为系统需要判断返回的消息是否符合期望，以实现测试目标。这个检查的逻辑根据不同的消息类型会有不同的处理逻辑（其中，主要逻辑则委派给由MessageCheckFactory创建的MessageChecker对象）。从接口来看，它们都需要接收返回的消息与期望的消息。以SO05为例，它需要返回的消息messageText，以及由getExpectedSO05ResponseFor(name)方法返回的期望的消息。对于SO07而言，实现方法稍显复杂，所以提取了一个私有方法checkSO07Response()来处理。</p>

<p>毫无疑问，我清楚地嗅到了代码的坏味道。重构势在必行。一方面，这个分支的处理是不合理的，随着消息类型的增多，这条分支语句会越来越长。关键是这种处理接收消息的逻辑不止存在这一处，这种没有封装的实现方式可能导致出现重复代码，违背了DRY原则。另一方面，则是对ExpectedMessage的处理。它分散在多个测试步骤中，有的放在AddUpdateCustomerSteps，有的则被提取到AbstractSteps类。从职责分配的角度看，测试步骤本身并不应该承担创建或获取ExpectedMessage的职责。</p>

<p>重构的目标就是MessageReceiver接口。我首先查看了MessageReceiver的实现类与调用者，发现其实现类只有一个，即DefaultMessageReceiver。调用者则非常多，调用的方法为getMessageFor()。事实上，这个方法正是我要操刀手术的目标方法。我希望它能够返回ResponseMessage自治对象，而非MessageReader。这意味着我们既需要修改方法的签名，同时还需要修改实现。修改方法签名会影响到调用的依赖点。在依赖点较多的情况下，这种重构需要谨慎处理。</p>

<p>我以为，在重构时首先需要明确重构的目的是什么，然后还需要理清楚整个重构的步骤，最后有条不紊地实施重构。显然，我们的目的是希望消除分支语句，并以统一的方式对各种类型的返回消息进行处理。根据对自治对象的分析，这意味着需要赋予ResponseMessage以行为，使得它自身就能够处理对ExpectedMessage的验证。由于创建ExpectedMessage的逻辑是分散的，因此，我们需要首先对这部分功能进行重构。以getExpectedSO05ResponseFor(name)方法的重构为例。该方法的实现如下所示：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="n">MessageReader</span> <span class="nf">getExpectedSO05ResponseFor</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">MessageWriter</span> <span class="n">writer</span><span class="o">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">scenarioContext</span><span class="o">.</span><span class="na">hasExpectedMessage</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>          <span class="n">scenarioContext</span><span class="o">.</span><span class="na">getExpectedMessage</span><span class="o">().</span><span class="na">getMessageType</span><span class="o">()</span> <span class="o">==</span> <span class="n">SO05</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">writer</span> <span class="o">=</span> <span class="n">scenarioContext</span><span class="o">.</span><span class="na">getExpectedMessage</span><span class="o">();</span>           
</span><span class='line'>  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">writer</span> <span class="o">=</span> <span class="n">transformerFactory</span><span class="o">.</span><span class="na">transformerFor</span><span class="o">(</span><span class="n">scenarioContext</span><span class="o">.</span><span class="na">getRequestMessage</span><span class="o">(),</span> <span class="n">SO05</span><span class="o">)</span>
</span><span class='line'>              <span class="o">.</span><span class="na">forCustomer</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>
</span><span class='line'>              <span class="o">.</span><span class="na">transform</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">writer</span><span class="o">.</span><span class="na">selectBlock</span><span class="o">(</span><span class="n">SO05_MESSAGE_HEADER</span><span class="o">);</span>
</span><span class='line'>  <span class="n">writer</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">MESSAGE_HEADER</span><span class="o">.</span><span class="na">USER_ID</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span><span class='line'>  <span class="n">writer</span><span class="o">.</span><span class="na">selectBlock</span><span class="o">(</span><span class="n">SO05_PROFILE</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">String</span> <span class="n">identifier</span> <span class="o">=</span> <span class="n">storyContext</span><span class="o">.</span><span class="na">getCustomerIdentifier</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span><span class='line'>  <span class="n">writer</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">PROFILE</span><span class="o">.</span><span class="na">PROFILE_ID</span><span class="o">,</span> <span class="n">identifier</span><span class="o">);</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">customerVersion</span> <span class="o">=</span> <span class="n">scenarioContext</span><span class="o">.</span><span class="na">getCustomerVersion</span><span class="o">();</span>
</span><span class='line'>  <span class="n">writer</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">PROFILE</span><span class="o">.</span><span class="na">USER_COUNT</span><span class="o">,</span> <span class="n">customerVersion</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">writer</span><span class="o">.</span><span class="na">selectBlockIfExists</span><span class="o">(</span><span class="n">SO05_INDIVIDUAL</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">writer</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">INDIVIDUAL_CUSTOMER_TYPE</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">messageFactory</span><span class="o">.</span><span class="na">readFor</span><span class="o">(</span><span class="n">SO05</span><span class="o">,</span> <span class="n">writer</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我们需要定义一个专门的对象来承担这一职责，因此，我引入了一个新对象ExpectedMessageFactory。通过采用Move Method手法（快捷键为F6，指IntelliJ下的快捷键，下同）可以完成这一重构。若要通过IDE自动帮助我们完成这一重构，就首先需要将该方法定义为static方法。然而，观察该方法的实现，它调用了许多字段值，例如scenarioContext，transformFactory等。由于这些字段并非static的，一旦将方法设置为static，使用这些字段就会提示错误。因此，在进行Move Method重构之前，需要首先将该方法调用的字段提取为参数，即运用Extract Parameter重构手法（快捷键为Ctrl+Alt+P）。如果该方法还调用了其他方法，则需要分析了解这些方法存在多少依赖，从职责上看是否也需要转移？如果只有重构的目标方法调用了它，则可以将方法内联（快捷键位Ctrl+ALT+N）。</p>

<p>做好这些准备工作后，就可以移动方法了。所有的这些手法，IDE都提供了自动重构的工具，所以并不须要担心这样的重构会引入新的问题。转移了方法后，原来的依赖点就自动改为对静态方法的调用。由于我们还需要再将其修改为非静态方法，此时，我们需要手动地修改所有原来对静态方法的调用。同时，对于当初为了移动方便而提取出来的参数，在移动到新类后，还需要恢复其原有地位，即将这些参数再提取为字段（快捷键为Ctrl+ALT+F）。之所以要这样做，一方面可以减少方法的参数，使得方法变得更为简洁，另一方面也可以提高类的内聚性。在转移了方法后，我还对原方法进行了Extract Method重构（快捷键为Ctrl+ALT+M）：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="n">MessageReader</span> <span class="nf">getExpectedSO05ResponseFor</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">MessageWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="n">initializeExpectedMessage</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">SO05</span><span class="o">);</span>
</span><span class='line'>  <span class="n">setSO05MessageHeader</span><span class="o">(</span><span class="n">writer</span><span class="o">);</span>
</span><span class='line'>  <span class="n">setSO05Profile</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">writer</span><span class="o">);</span>
</span><span class='line'>  <span class="n">setSO05Individual</span><span class="o">(</span><span class="n">writer</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">messageFactory</span><span class="o">.</span><span class="na">readFor</span><span class="o">(</span><span class="n">SO05</span><span class="o">,</span> <span class="n">writer</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="n">MessageWriter</span> <span class="nf">initializeExpectedMessage</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">MessageType</span> <span class="n">messageType</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">MessageWriter</span> <span class="n">messageWriter</span><span class="o">;</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">scenarioContext</span><span class="o">.</span><span class="na">hasExpectedMessage</span><span class="o">()</span> <span class="o">&amp;&amp;</span>
</span><span class='line'>          <span class="n">scenarioContext</span><span class="o">.</span><span class="na">getExpectedMessage</span><span class="o">().</span><span class="na">getMessageType</span><span class="o">()</span> <span class="o">==</span> <span class="n">messageType</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">writer</span> <span class="o">=</span> <span class="n">scenarioContext</span><span class="o">.</span><span class="na">getExpectedMessage</span><span class="o">();</span>           
</span><span class='line'>  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">writer</span> <span class="o">=</span> <span class="n">transformerFactory</span><span class="o">.</span><span class="na">transformerFor</span><span class="o">(</span><span class="n">scenarioContext</span><span class="o">.</span><span class="na">getRequestMessage</span><span class="o">(),</span> <span class="n">messageType</span><span class="o">)</span>
</span><span class='line'>              <span class="o">.</span><span class="na">forCustomer</span><span class="o">(</span><span class="n">name</span><span class="o">)</span>
</span><span class='line'>              <span class="o">.</span><span class="na">transform</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">return</span> <span class="n">messageWriter</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">setSO05MessageHeader</span><span class="o">(</span><span class="n">MessageWriter</span> <span class="n">writer</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">writer</span><span class="o">.</span><span class="na">selectBlock</span><span class="o">(</span><span class="n">SO05_MESSAGE_HEADER</span><span class="o">);</span>
</span><span class='line'>  <span class="n">writer</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">MESSAGE_HEADER</span><span class="o">.</span><span class="na">USER_ID</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">setSO05Profile</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">MessageWriter</span> <span class="n">writer</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">writer</span><span class="o">.</span><span class="na">selectBlock</span><span class="o">(</span><span class="n">SO05_PROFILE</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">String</span> <span class="n">identifier</span> <span class="o">=</span> <span class="n">storyContext</span><span class="o">.</span><span class="na">getCustomerIdentifier</span><span class="o">(</span><span class="n">name</span><span class="o">);</span>
</span><span class='line'>  <span class="n">writer</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">PROFILE</span><span class="o">.</span><span class="na">PROFILE_ID</span><span class="o">,</span> <span class="n">identifier</span><span class="o">);</span>
</span><span class='line'>  <span class="n">String</span> <span class="n">customerVersion</span> <span class="o">=</span> <span class="n">scenarioContext</span><span class="o">.</span><span class="na">getCustomerVersion</span><span class="o">();</span>
</span><span class='line'>  <span class="n">writer</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">PROFILE</span><span class="o">.</span><span class="na">USER_COUNT</span><span class="o">,</span> <span class="n">customerVersion</span><span class="o">);</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">private</span> <span class="kt">void</span> <span class="nf">setSO05Individual</span><span class="o">(</span><span class="n">MessageWriter</span> <span class="n">writer</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">if</span> <span class="o">(</span><span class="n">writer</span><span class="o">.</span><span class="na">selectBlockIfExists</span><span class="o">(</span><span class="n">SO05_INDIVIDUAL</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">writer</span><span class="o">.</span><span class="na">setFieldValue</span><span class="o">(</span><span class="n">INDIVIDUAL_CUSTOMER_TYPE</span><span class="o">,</span> <span class="kc">null</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过对方法的提取，一方面以能表达功能意图的方法名提高代码的可读性，另一方面还能通过这种重构发现可能重用的方法，例如上面代码片段中的initializeExpectedMessage()，就是在经过提取方法的重构后，才发现其实对于SO07消息而言，同样存在相同的初始化逻辑。</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">private</span> <span class="n">MessageWriter</span> <span class="nf">getExpectedSO07WriterFor</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">MessageWriter</span> <span class="n">writer</span> <span class="o">=</span> <span class="n">initializeExpectedMessage</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">SO07</span><span class="o">);</span>
</span><span class='line'>  <span class="n">setSO07Details</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">writer</span><span class="o">);</span>
</span><span class='line'>  <span class="n">setSO07Blocks</span><span class="o">(</span><span class="n">name</span><span class="o">,</span> <span class="n">writer</span><span class="o">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">writer</span><span class="o">;</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在完成对ExpectedMessage创建功能的重构后，接下来就可以考虑处理MessageReceiver了。看起来，我们必须修改getMessageFor()方法的签名。一种稳妥的做法是暂时保留该方法，然后引入一个新方法，并在新方法中调用getMessageFor()方法。不过，这种方式需要我们手动地去修改所有依赖点；另一种做法则是先通过提取方法的方式，将原有getMessageFor()的所有实现提取到一个私有方法中，然后再直接利用修改方法签名的重构手法（快捷键为Ctrl+F6），直接修改getMessageFor()。这样做的好处是IDE工具可以直接帮助你修改所有的依赖点，同时还能够保留原有的实现。为了更好地表达方法的意图，我还对该方法进行了更名重构（快捷键为Shift+F6），将其重命名为getResponseMessage()。由于方法的返回值发生了变化，所以依赖该方法的地方都会出现返回值类型不吻合的提示。在IntelliJ中，我们可以很容易地找到这些提示位置，并直接通过Alt+Enter根据工具给出的提示，来改变返回值类型。</p>

<p>改变了返回值类型并不意味着完事大吉，因为后面对该返回类型的调用，即前面提到的那段分支语句，仍然是不一致的。原来使用的是MessageReader对象，现在变成ResponseMessage对象了。这就需要我们手动地修改这些调用。当然，也有一种取巧的办法，就是将这些代码结合Extract Method与Move Method重构手法，再转移到我们引入的ResponseMessage中，因为在我们之前的分析中，已经明确这些分支判断逻辑应该封装到ResponseMessage对象。最终的重构结果为：</p>

<figure class='code'> <div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">abstract</span> <span class="kd">class</span> <span class="nc">ResponseMessage</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">ResponseMessage</span><span class="o">(</span><span class="n">MessageReader</span> <span class="n">messageReader</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">this</span><span class="o">.</span><span class="na">messageReader</span> <span class="o">=</span> <span class="n">messageReader</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">check</span><span class="o">(</span><span class="n">MessageReader</span> <span class="n">expectedMessage</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">messageCheckFactory</span><span class="o">.</span><span class="na">checkerFor</span><span class="o">(</span><span class="n">getMessageType</span><span class="o">(),</span> <span class="n">expectedMessage</span><span class="o">,</span> <span class="n">getMessageText</span><span class="o">()).</span><span class="na">checkResponse</span><span class="o">();</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">protected</span> <span class="kd">abstract</span> <span class="n">MessageType</span> <span class="nf">getMessageType</span><span class="o">();</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">SO05ResponseMessage</span> <span class="kd">extends</span> <span class="n">ResponseMessage</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="nf">SO05ResponseMessage</span><span class="o">(</span><span class="n">MessageReader</span> <span class="n">messageReader</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="kd">super</span><span class="o">(</span><span class="n">messageReader</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="nd">@Override</span>
</span><span class='line'>  <span class="kd">protected</span> <span class="n">MessageType</span> <span class="nf">getMessageType</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">MessageType</span><span class="o">.</span><span class="na">SO05</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">DefaultMessageReceiver</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="n">ResponseMessage</span> <span class="nf">getResponseMessage</span><span class="o">(</span><span class="n">MessageType</span> <span class="n">type</span><span class="o">,</span> <span class="n">String</span> <span class="n">identifier</span><span class="o">,</span> <span class="n">GCISQueue</span> <span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">MessageReader</span> <span class="n">messageReader</span> <span class="o">=</span> <span class="n">getMessageFor</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">identifier</span><span class="o">,</span> <span class="n">queue</span><span class="o">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="nf">createResponseMessage</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">messageReader</span><span class="o">,</span> <span class="n">identifer</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">private</span> <span class="n">MessageReader</span> <span class="nf">getMessageFor</span><span class="o">(</span><span class="n">MessageType</span> <span class="n">type</span><span class="o">,</span> <span class="n">String</span> <span class="n">identifier</span><span class="o">,</span> <span class="n">GCISQueue</span> <span class="n">queue</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">MessageReader</span> <span class="n">reader</span> <span class="o">=</span> <span class="n">getCachedMessageFor</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">identifier</span><span class="o">,</span> <span class="n">queue</span><span class="o">);</span>
</span><span class='line'>      <span class="k">while</span> <span class="o">(</span><span class="n">reader</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">reader</span> <span class="o">=</span> <span class="n">getMessageFromQueueFor</span><span class="o">(</span><span class="n">type</span><span class="o">,</span> <span class="n">identifer</span><span class="o">,</span> <span class="n">queue</span><span class="o">);</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">reader</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>  <span class="kd">private</span> <span class="n">ResponseMessage</span> <span class="nf">createResponseMessage</span><span class="o">(</span><span class="n">MessageType</span> <span class="n">messageType</span><span class="o">,</span> <span class="n">MessageReader</span> <span class="n">messageReader</span><span class="o">,</span> <span class="n">String</span> <span class="n">identifer</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">ResponseMessage</span> <span class="n">message</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>      <span class="k">switch</span> <span class="o">(</span><span class="n">messageType</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">case</span> <span class="nl">SO05:</span>
</span><span class='line'>              <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SO05ResponseMessage</span><span class="o">(</span><span class="n">messageReader</span><span class="o">);</span>
</span><span class='line'>              <span class="k">break</span><span class="o">;</span>
</span><span class='line'>          <span class="k">case</span> <span class="nl">SO07:</span>
</span><span class='line'>              <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SO07ResponseMessage</span><span class="o">(</span><span class="n">messageReader</span><span class="o">);</span>
</span><span class='line'>              <span class="k">break</span><span class="o">;</span>
</span><span class='line'>          <span class="k">case</span> <span class="nl">SO08:</span>
</span><span class='line'>              <span class="n">message</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SO08ResponseMessage</span><span class="o">(</span><span class="n">messageReader</span><span class="o">);</span>
</span><span class='line'>              <span class="k">break</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">message</span><span class="o">.</span><span class="na">setMessageCheckFactory</span><span class="o">(</span><span class="n">messageCheckFactory</span><span class="o">);</span>
</span><span class='line'>      <span class="k">return</span> <span class="n">message</span><span class="o">;</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//invoker</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AddUpdateProductSystemCustomerSteps</span> <span class="kd">extends</span> <span class="n">AbstractCustomerExpectationSteps</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">checkPropagationQueueByName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="n">Queue</span> <span class="n">queue</span><span class="o">,</span> <span class="n">MessageType</span> <span class="n">messageType</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">ResponseMessage</span> <span class="n">responseMessage</span> <span class="o">=</span> <span class="n">messageReceiver</span><span class="o">.</span><span class="na">getMessageFor</span><span class="o">(</span><span class="n">messageType</span><span class="o">,</span> <span class="n">identifier</span><span class="o">,</span> <span class="n">queue</span><span class="o">);</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>掌握重构的技巧并不难，关于在于你必须要有好的嗅觉，能够及时发现代码的坏味道。然而，即使你拥有高超的重构技艺，如果未能养成随时重构的好习惯，又能如何？换言之，重构能力体现的是你的专业技能，而重构习惯体现的则是你的职业素养。你是否愿意为追求高质量的卓越代码而为之付出时间和精力呢？你能否以好的结果来说服客户尊重你的重构成果呢？我觉得，对卓越软件的追求，不仅限于自己，同时也需要将此理念灌输给客户，并使得客户愿意为之付费。从软件成本来看，这种对高质量软件的追求或许违背了短期利益，但绝对符合软件开发的长期利益。</p>

<p>所以，在下决心打磨代码质量之前，还是先找好重构这块磨刀石，并放到自己随时伸手可及的工具箱中吧。</p>
]]></content>
  </entry>
  
</feed>
