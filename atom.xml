<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[简单文本]]></title>
  <link href="http://agiledon.github.com/atom.xml" rel="self"/>
  <link href="http://agiledon.github.com/"/>
  <updated>2013-11-21T22:41:08+08:00</updated>
  <id>http://agiledon.github.com/</id>
  <author>
    <name><![CDATA[张逸]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[玩花招的PowerMock]]></title>
    <link href="http://agiledon.github.com/blog/2013/11/21/play-trick-with-powermock/"/>
    <updated>2013-11-21T12:42:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/11/21/play-trick-with-powermock</id>
    <content type="html"><![CDATA[<p>当我们面对一个遗留系统时，常见的问题是没有测试。正如Michael Feathers在Working Effectively with Legacy Code一书中对“遗留代码”的定义。他将其简单归纳为“没有测试的代码”。真是太贴切了！正是因为没有测试，使得我们对遗留代码的任何重构都有些战战兢兢，甚至成为开发人员抵制重构的借口。从收益与成本的比例来看，对于这样的系统，我一贯认为不要盲目进行重构。因为重构的真正适用场景其实是发生在开发期间，而非维护期间。当然，提升自己的重构能力，尤其学会运用IDE提供的自动重构工具，可以在一定程度上保障重构的质量。然而，安全的做法，还是需要为其编写测试。</p>

<p>测试是分层的，即使是针对自动化测试。面对遗留系统，成本相对较低的是针对功能特性编写的功能测试（或者说是验收测试），这可以运用一些BDD框架如Cucumber、JBehave等。由于它的测试粒度较粗，可以以较少的测试用例覆盖系统的主要功能。然而，它的缺点同样存在，那就是反馈周期相对较长。这就好像你置身一个陌生的城市，在找不到路的情况下，只是跟着感觉走。走了数十公里之后，方才幡然醒悟，想起要翻一翻带在手上的地图。倘若发现方向走错，再要回转就已经晚了。反馈周期最短的自然是单元测试。同样根据Michael Feather的定义，单元测试一定要快，一定要不依赖于外部资源。单元测试的粒度自然是最小的，但不要直观地认为单元测试就是针对方法。若只是针对方法来编写单元测试，就会陷入为测试而测试的怪圈。即使是位于技术象限的单元测试，我们仍然要按照业务规则来编写。一个测试方法应该对应一个粒度最小的原子功能。</p>

<!-- more -->


<p>要让单元测试跑得快，还要不吃草（依赖外部资源），应该怎么办？答案呼之欲出，那就是Mock。Mock当然不是万能的，记得胡凯写过一篇文章，提及Mock不是银弹。我知道他仅仅是为了强调这个观点，避免太多人过于依赖Mock，因为Brooks早就发表过论断，在软件行业，其实根本就“没有银弹”。关于Mock的争论由来已久，对此，我准备避而不谈。至少在我看来，如下几点基本已成定论：</p>

<p>1、是Mock行为，而非Mock数据；如果是针对数据，则应该属于Stub的范畴；</p>

<p>2、Mock通常发生在三种情况（让我们假设被测试对象为消费者，它要协作的对象为服务，此时需要Mock服务）：服务的行为只有定义，还未实现；服务需要访问外部资源（这意味着它可能很慢，也意味着它需要依赖外部资源）；服务的行为结果不确定（例如天气服务，股票服务）。</p>

<p>自然，我们不需要自己写Mock，有许多现成的好用框架，例如Java平台下的Mockito与EasyMock，.NET平台下的Moq，以及C++下的Google Mock和MockCpp。</p>

<p>然而，问题依然存在。考虑这样两种情况：</p>

<p>1、当我们要Mock的服务，其实是Utils的静态方法时，应该怎么办？</p>

<p>2、当我们要测试的方法内部直接实例化了协作的服务对象，又该怎么办？</p>

<p>显然，这是设计和代码的坏味道，它明显违背了DIP原则，即它不应该依赖于细节，而应该依赖于抽象。换言之，它产生了对服务对象的具体依赖。若要遵循DIP，就应该在被测对象的外部来注入依赖。这种紧耦合酿成了我们设计的类不具备良好的可测试性。</p>

<p>一个蠢蠢欲动的声音在说：让我们重构吧！且住，先让我们把这苛求的眼光放柔和一点。当你视所有丑陋的代码为“蝼蚁”时，那是因为你站在了足够的高度。可是站得太高，往往摔得更惨。现在，还是脚踏实地，先设身处地地考虑这样的场景：这是一个代码行数超过1000万行的软件系统，一共有十余个开发团队，一百多名开发人员在这个团队中工作。这个系统几乎没有测试，而系统的Jar包则达到上千个。这些Utils的静态方法被数十乃至上百个类调用，牵涉到的模块也有多个甚至十余个。而且，这个系统并没有引入任何一个IoC容器。有了这样一个背景，让我们再把柔和的眼光变得锐利一点，分析分析重构的可行性。要消除前面提到的坏味道，就需要将这些静态方法修改为实例方法，并通过依赖注入的方式注入。这个变化带来的是对整个系统的全局影响，即使我们有一些自动化重构的手段，仍然不认为这种重构一定就是可行的。</p>

<p>这就是我要谈PowerMock的前提！</p>

<p>现在，轮到玩花招的PowerMock出场了。有了它，什么静态方法，方法内部实例，乃至私有方法，统统都是浮云。而且，它对Mockito与EasyMock的扩展，使得我们更容易熟悉它的语法。要使用它很简单，需先设置对它的依赖。我选择了PowerMock针对Mockito的扩展：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='xml'><span class='line'>        <span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>            <span class="nt">&lt;groupId&gt;</span>org.powermock<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;artifactId&gt;</span>powermock-api-mockito<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;version&gt;</span>1.5.1<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/dependency&gt;</span>
</span><span class='line'>        <span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>            <span class="nt">&lt;groupId&gt;</span>org.powermock<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;artifactId&gt;</span>powermock-module-junit4<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;version&gt;</span>1.5.1<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/dependency&gt;</span>
</span><span class='line'>        <span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>            <span class="nt">&lt;groupId&gt;</span>org.mockito<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;artifactId&gt;</span>mockito-all<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;version&gt;</span>1.9.5<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/dependency&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>让我先给出如下的一份奇奇怪怪的设计，它主要是为了迎合之前提到的代码臭味。</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeTableUtil</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">findAll</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">insert</span><span class="o">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">existed</span><span class="o">(</span><span class="n">employee</span><span class="o">.</span><span class="na">getId</span><span class="o">()))</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">ExistedEmployeeException</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">//insert employee</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">employee</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">NullEmployeeException</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">delete</span><span class="o">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">existed</span><span class="o">(</span><span class="n">employee</span><span class="o">.</span><span class="na">getId</span><span class="o">()))</span> <span class="o">{</span>
</span><span class='line'>            <span class="c1">//delete employee</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">boolean</span> <span class="nf">existed</span><span class="o">(</span><span class="n">String</span> <span class="n">id</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeRepository</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">EmployeeTableUtil</span> <span class="n">tableUtil</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="nf">EmployeeTableUtil</span><span class="o">().</span><span class="na">count</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">findAll</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">findAll</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">insert</span><span class="o">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">tableUtil</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">employee</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">ExistedEmployeeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">update</span><span class="o">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">employee</span><span class="o">);</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">NullEmployeeException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">delete</span><span class="o">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">tableUtil</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">employee</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">double</span> <span class="nf">bonus</span><span class="o">(</span><span class="n">Employee</span> <span class="n">employee</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">employee</span><span class="o">.</span><span class="na">getSalary</span><span class="o">()</span> <span class="o">*</span> <span class="mf">0.1d</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTableUtil</span><span class="o">(</span><span class="n">EmployeeTableUtil</span> <span class="n">tableUtil</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">tableUtil</span> <span class="o">=</span> <span class="n">tableUtil</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在，我要针对EmployeeRepository编写测试，它协作的服务类为EmployeTableUtil，主要承担了访问数据库的职责。在测试EmployeeRepository时，我们需要去Mock协作对象EmployeeTableUtil的行为。</p>

<p>在使用PowerMock编写测试时，首先需要在测试类上运用框架提供的Annotation：@PrepareForTest，以及一个Runner：PowerMockRunner。因为我们要Mock的对象为EmployeeTableUtil，故而测试类的定义为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@RunWith</span><span class="o">(</span><span class="n">PowerMockRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="nd">@PrepareForTest</span><span class="o">(</span><span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeRepositoryTest</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">EmployeeRepository</span> <span class="n">repository</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Before</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUp</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">repository</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EmployRepository</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>现在我要使用PowerMock去Mock静态方法，如EmployeeTableUtil的findAll()方法，至于要测试的方法则为EmployeeRepository的findAll()方法。则编写的单元测试为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_mock_static_method</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">List</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">employee</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">employee</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Employee</span><span class="o">(</span><span class="s">&quot;1&quot;</span><span class="o">));</span>
</span><span class='line'>        <span class="n">employee</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">Employee</span><span class="o">(</span><span class="s">&quot;2&quot;</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">PowerMockito</span><span class="o">.</span><span class="na">mockStatic</span><span class="o">(</span><span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>        <span class="n">when</span><span class="o">(</span><span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">findAll</span><span class="o">()).</span><span class="na">thenReturn</span><span class="o">(</span><span class="n">employee</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">List</span><span class="o">&lt;</span><span class="n">Employee</span><span class="o">&gt;</span> <span class="n">employees</span> <span class="o">=</span> <span class="n">repository</span><span class="o">.</span><span class="na">findAll</span><span class="o">();</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">employees</span><span class="o">.</span><span class="na">size</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="mi">2</span><span class="o">));</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">employees</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">).</span><span class="na">getId</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="s">&quot;1&quot;</span><span class="o">));</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">employees</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">1</span><span class="o">).</span><span class="na">getId</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="s">&quot;2&quot;</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">PowerMockito</span><span class="o">.</span><span class="na">verifyStatic</span><span class="o">();</span>
</span><span class='line'>        <span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">findAll</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Mock静态方法的关键是先要调用框架定义的PowerMockito类的mockStatic()方法（针对EasyMock有相似的类）。方法接收的参数就是我们要Mock的类的类型。接下来就可以调用Mockito框架的方法，对我们要模拟的方法findAll()进行模拟，这里主要的工作是为模拟方法的返回值设置一个stub。之后就是单元测试的验证逻辑。如果需要验证被Mock的方法是否被调用，则需要调用PowerMockito.verifyStatic()方法，紧随其后的是被mock的方法。</p>

<p>如果要Mock的方法是一个命令方法（即没有返回值的方法），做法又有不同。倘若熟悉Mockito，可以看出PowerMock完全沿袭了Mockito的风格（当然，针对EasyMock的扩展则会沿袭EasyMock的风格，这是PowerMock体贴人的地方）：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_mock_exception_for_command_method_in_mock_object</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Employee</span> <span class="n">employee</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Employee</span><span class="o">(</span><span class="s">&quot;1&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">PowerMockito</span><span class="o">.</span><span class="na">mockStatic</span><span class="o">(</span><span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>        <span class="n">PowerMockito</span><span class="o">.</span><span class="na">doThrow</span><span class="o">(</span><span class="k">new</span> <span class="n">NullEmployeeException</span><span class="o">()).</span><span class="na">when</span><span class="o">(</span><span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>        <span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">employee</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">repository</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">employee</span><span class="o">),</span> <span class="n">is</span><span class="o">(</span><span class="kc">false</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>PowerMock还可以Mock私有方法，当然只能是实例的私有方法。这主要发生在当我们不希望Mock服务的公开方法时（例如，公开方法的逻辑没有Mock的必要），但这些公开方法的内部又调用了自己的私有方法，而私有方法却需要Mock。例如，EmployeeTableUtil的insert()和delete()方法调用了私有的existed()方法。假设insert()和delete()方法不需要我们Mock，此时就需要对私有方法existed()进行Mock。因为是实例方法，所以下面的测试方法通过调用setTableUtil()方法将被模拟的对象注入到EmployeeRepository对象中：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_mock_private_method</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Employee</span> <span class="n">employee</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Employee</span><span class="o">(</span><span class="s">&quot;1&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">EmployeeTableUtil</span> <span class="n">util</span> <span class="o">=</span> <span class="n">PowerMockito</span><span class="o">.</span><span class="na">spy</span><span class="o">(</span><span class="k">new</span> <span class="n">EmployeeTableUtil</span><span class="o">());</span>
</span><span class='line'>        <span class="n">PowerMockito</span><span class="o">.</span><span class="na">when</span><span class="o">(</span><span class="n">util</span><span class="o">,</span><span class="s">&quot;existed&quot;</span><span class="o">,</span> <span class="n">anyString</span><span class="o">())</span>
</span><span class='line'>                <span class="o">.</span><span class="na">thenReturn</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">repository</span><span class="o">.</span><span class="na">setTableUtil</span><span class="o">(</span><span class="n">util</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">repository</span><span class="o">.</span><span class="na">insert</span><span class="o">(</span><span class="n">employee</span><span class="o">),</span> <span class="n">is</span><span class="o">(</span><span class="kc">false</span><span class="o">));</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">repository</span><span class="o">.</span><span class="na">delete</span><span class="o">(</span><span class="n">employee</span><span class="o">),</span> <span class="n">is</span><span class="o">(</span><span class="kc">true</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>PowerMock顺带还提供了测试私有方法的便捷办法（注意是测试，而不是Mock）。例如，测试EmployeeReployee类的私有方法bonus()：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_test_private_method</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">Employee</span> <span class="n">employee</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Employee</span><span class="o">(</span><span class="s">&quot;1&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="n">employee</span><span class="o">.</span><span class="na">setSalary</span><span class="o">(</span><span class="mi">8000</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="n">Whitebox</span><span class="o">.&lt;</span><span class="n">Double</span><span class="o">&gt;</span><span class="n">invokeMethod</span><span class="o">(</span><span class="n">repository</span><span class="o">,</span> <span class="s">&quot;bonus&quot;</span><span class="o">,</span> <span class="n">employee</span><span class="o">);</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">result</span><span class="o">,</span> <span class="n">is</span><span class="o">(</span><span class="mi">800</span><span class="n">d</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>最后再来看看另外一种诡异的手段。假设我们要测试的方法其内部调用了协作对象的方法，而该协作对象不是在外部注入的，而是在方法中直接实例化。例如在前面例子中，EmployeeRepository的count()方法：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">EmployeeRepository</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">EmployeeTableUtil</span> <span class="n">tableUtil</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">count</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="k">new</span> <span class="nf">EmployeeTableUtil</span><span class="o">().</span><span class="na">count</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>要针对这样一种情形进行Mock，做法有所不同。因为它实际针对的是待测类——即这里的EmployeeRepository——执行count()方法，这就需要在count()方法内部形成一个拦截点。因此，需要在@PrepareForTest标记中指向EmployeeRepository类的类型，而非我们要Mock的EmployeeTableUtil。故而，我们需要为这个测试定义一个新的测试类：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@RunWith</span><span class="o">(</span><span class="n">PowerMockRunner</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="nd">@PrepareForTest</span><span class="o">(</span><span class="n">EmployeeRepository</span><span class="o">.</span><span class="na">class</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ConstructionEmployeeRepositoryTest</span> <span class="o">{</span>
</span><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_mock_construction_object</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">EmployeeTableUtil</span> <span class="n">util</span> <span class="o">=</span> <span class="n">mock</span><span class="o">(</span><span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>        <span class="n">when</span><span class="o">(</span><span class="n">util</span><span class="o">.</span><span class="na">count</span><span class="o">()).</span><span class="na">thenReturn</span><span class="o">(</span><span class="mi">100</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">PowerMockito</span><span class="o">.</span><span class="na">whenNew</span><span class="o">(</span><span class="n">EmployeeTableUtil</span><span class="o">.</span><span class="na">class</span><span class="o">).</span><span class="na">withNoArguments</span><span class="o">().</span><span class="na">thenReturn</span><span class="o">(</span><span class="n">util</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">EmployeeRepository</span> <span class="n">repository</span> <span class="o">=</span> <span class="k">new</span> <span class="n">EmployeeRepository</span><span class="o">();</span>
</span><span class='line'>        <span class="n">assertThat</span><span class="o">(</span><span class="n">repository</span><span class="o">.</span><span class="na">count</span><span class="o">(),</span> <span class="n">is</span><span class="o">(</span><span class="mi">100</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，测试方法的前两行代码调用的mock()与when()方法都是Mockito提供的方法，与PowerMock无关。</p>

<p>或许我已经变得像祥林嫂一般的唠叨，但我还是必须再次申明，以上Mock方式所针对的情形皆为设计与代码的坏味道。优先情况下，我们应该重构，使得它遵循DIP原则，解除对服务类的耦合，使其具有良好的可测试性；而不能因为有了强大的PowerMock而“姑息养奸”。换言之，让我们仅仅将PowerMock耍弄的种种花招，看做是压箱底的手段。实在走投无路了，再祭出你的杀手锏吧！</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Maven为一个项目生成多个Jar包]]></title>
    <link href="http://agiledon.github.com/blog/2013/11/10/create-two-jars-from-one-project-using-maven/"/>
    <updated>2013-11-10T22:43:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/11/10/create-two-jars-from-one-project-using-maven</id>
    <content type="html"><![CDATA[<p>虽然在Java平台下，各种构建工具如Maven、Gradle、SBT已经得到了较为广泛地运用，同时Maven约定的模块目录结构也得到了业界的认可，成为了Java平台下项目结构的事实标准。但我们总无法避免与各种遗留系统或老系统打交道。在没有Maven的时代，是Ant统治的时代，它因为提供了较为灵活的编写Task的功能，而忽略了制定一套看似呆板，实则有效的标准模板。于是，在不同的企业，不同的Java项目，出现了各种各样奇怪的目录结构与打包要求。拖着这些沉重的历史包袱，我们自然希望彻底革命，把那些看不顺眼的东西全部改造，让整个项目焕然一新。这是好事儿，所谓长痛不如短痛，一下子把问题肿瘤给割了，痛快！可是现实总有那么一些阻力会让我们缩手缩脚，我们不能挥起革命的利刃一阵乱砍，这弄不好会砍伤自己的手。于是乎，我们需要做战略性的撤退。退一步海阔天空嘛。</p>

<p>我面对的就是这样一个软件系统。这个Java开发的软件系统一直没有依赖管理，仅仅编写了Ant任务用于发布打包。我们的任务是渐进地引入Maven，并在从Build到deploy的整个生命周期中，逐步替换Ant，与持续集成搭配起来。这个系统的多数模块都划分了服务端与客户端。然而不巧的是，各个模块的服务端和客户端都集中在一个模块中。同时，这个项目的目录结构并非标准的Maven结构，如下图所示。因此，还需要自定义Source与TestSource的目录结构。在原来的Ant任务中，是将它们打包成了两个Jar包。现在，我们需要在Maven中同样做到这一点。</p>

<!-- more -->


<p><img class="left" src="http://agiledon.github.com/images/2013/folder-structure.png"></p>

<p>分析这个目录结构，无非是在打包时，对文件进行include或exclude。我查阅到Maven的一位开发者Tim O&#8217;Brien写的一篇博客<a href="http://blog.sonatype.com/people/2010/01/how-to-create-two-jars-from-one-project-and-why-you-shouldnt/#.Un9DKpTN_Gp">Sonatype的博客</a>，详细介绍了具体的做法。当然，在博客中，他一再强调了这种做法的不可取，建议在项目模块上做出好的分解，保证一个Module对应一个Jar包。这篇博客介绍了两种做法，一个是在Profile中定义，一个则是在build中定义，使用的插件皆为maven-jar-plugin。对于我要解决的问题，可以考虑选择使用第二种做法，因为它只需要执行一条mvn package命令就能同时得到Server和Client的Jar包。具体的做法就是在插件的配置中，include各自的文件夹即可。配置如下：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='xml'><span class='line'>    <span class="nt">&lt;groupId&gt;</span>com.test.maven<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>testmaven<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;version&gt;</span>1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;build&gt;</span>
</span><span class='line'>        <span class="nt">&lt;sourceDirectory&gt;</span>src<span class="nt">&lt;/sourceDirectory&gt;</span>
</span><span class='line'>        <span class="nt">&lt;testSourceDirectory&gt;</span>testSrc<span class="nt">&lt;/testSourceDirectory&gt;</span>
</span><span class='line'>
</span><span class='line'>        <span class="nt">&lt;plugins&gt;</span>
</span><span class='line'>            <span class="nt">&lt;plugin&gt;</span>
</span><span class='line'>                <span class="nt">&lt;artifactId&gt;</span>maven-jar-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>                <span class="nt">&lt;executions&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;execution&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;id&gt;</span>server<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;goals&gt;&lt;goal&gt;</span>jar<span class="nt">&lt;/goal&gt;&lt;/goals&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;phase&gt;</span>package<span class="nt">&lt;/phase&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;configuration&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;classifier&gt;</span>server<span class="nt">&lt;/classifier&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;includes&gt;</span>
</span><span class='line'>                                <span class="nt">&lt;include&gt;</span>**/server/**<span class="nt">&lt;/include&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;/includes&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;/configuration&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;/execution&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;execution&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;id&gt;</span>client<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;goals&gt;&lt;goal&gt;</span>jar<span class="nt">&lt;/goal&gt;&lt;/goals&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;phase&gt;</span>package<span class="nt">&lt;/phase&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;configuration&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;classifier&gt;</span>client<span class="nt">&lt;/classifier&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;includes&gt;</span>
</span><span class='line'>                                <span class="nt">&lt;include&gt;</span>**/client/**<span class="nt">&lt;/include&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;/includes&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;/configuration&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;/execution&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/executions&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/plugin&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/plugins&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/build&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>通过这样的配置，运行mvn package可以生成三个包，其中testmaven-1.0-SNAPSHOT.jar同时包含了服务端和客户端的类；而服务端和客户端对应的Jar则为testmaven-1.0-SNAPSHOT-server.jar和testmaven-1.0-SNAPSHOT-client.jar。</p>

<p>在前面的配置中，我们并没有为server和client包定义自己的坐标，而是沿用了统一的一个。这就意味着依赖这个包的其他Module，可能无法通过Dependency来精确定位Server或Client。这对于部署来说，是没有问题的，但却无法进行依赖管理；除非在依赖的时候，去依赖整个大的模块。</p>

<p>要保证依赖管理，就意味着需要为server和client分别指定各自的坐标。看来需要另辟蹊径。其实，Maven是支持在一个项目中建立多个子模块的。我们可以考虑在项目中引入两个子模块，分别对应server和client，并在这两个子模块中建立自己的pom.xml文件。这在本质上是与Maven多模块支持是相同的，唯一不同的是代码结构。而且这种新建模块并没有影响原有的目录结构，对于遗留系统而言，还是可以接受的。因此，我们建立了如下图所示的模块结构：
<img class="center" src="http://agiledon.github.com/images/2013/module-structure.png"></p>

<p>在新的结构中，除了原有模块外，我还引入了另外两个新的模块server和client，它们除了拥有自己的pom.xml文件，没有其他任何内容。而在原有模块下，同样定义了一个pom.xml文件，它将作为整个项目的parent。定义如下：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='xml'><span class='line'>    <span class="nt">&lt;groupId&gt;</span>com.test.maven<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>testmaven<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>    <span class="nt">&lt;version&gt;</span>1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>    <span class="nt">&lt;packaging&gt;</span>pom<span class="nt">&lt;/packaging&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;modules&gt;</span>
</span><span class='line'>        <span class="nt">&lt;module&gt;</span>server<span class="nt">&lt;/module&gt;</span>
</span><span class='line'>        <span class="nt">&lt;module&gt;</span>client<span class="nt">&lt;/module&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/modules&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里定义的坐标是整个项目的坐标，同时指定了packaging的类型为pom。在这个pom.xml文件中还包括了两个子模块，其中的值应该与模块的名称对应。接下来配置server模块的pom.xml：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='xml'><span class='line'>    <span class="nt">&lt;parent&gt;</span>
</span><span class='line'>        <span class="nt">&lt;groupId&gt;</span>com.test.maven<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>        <span class="nt">&lt;artifactId&gt;</span>testmaven<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>        <span class="nt">&lt;version&gt;</span>1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/parent&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>testmaven-server<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;build&gt;</span>
</span><span class='line'>        <span class="nt">&lt;sourceDirectory&gt;</span>../src<span class="nt">&lt;/sourceDirectory&gt;</span>
</span><span class='line'>        <span class="nt">&lt;testSourceDirectory&gt;</span>../testSrc<span class="nt">&lt;/testSourceDirectory&gt;</span>
</span><span class='line'>
</span><span class='line'>        <span class="nt">&lt;plugins&gt;</span>
</span><span class='line'>            <span class="nt">&lt;plugin&gt;</span>
</span><span class='line'>                <span class="nt">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>                <span class="nt">&lt;version&gt;</span>3.1<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>                <span class="nt">&lt;configuration&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;includes&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;include&gt;</span>**/server/**<span class="nt">&lt;/include&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;/includes&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/configuration&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/plugin&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/plugins&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/build&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先声明了parent指向了主模块的坐标。接下来，声明当前模块的artifact id为testmaven-server。这就为server指定了独立的坐标。一旦部署后，在maven的Repository中会得到这样的文件：com/test/maven/testmaven-server/1.0-SNAPSHOT/testmaven-server-1.0-SNAPSHOT.jar。我们就可以在依赖中这样声明：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='xml'><span class='line'>    <span class="nt">&lt;dependencies&gt;</span>
</span><span class='line'>        <span class="nt">&lt;dependency&gt;</span>
</span><span class='line'>            <span class="nt">&lt;groupId&gt;</span>com.test.maven<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;artifactId&gt;</span>testmaven-server<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>            <span class="nt">&lt;version&gt;</span>1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/dependency&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/dependencies&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>运行mvn package，oops……竟然出现问题了。什么问题呢？单元测试无法通过。报告的错误为：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:testCompile (default-testCompile) on project testmaven-server: Compilation failure: Compilation failure:
</span><span class='line'>[ERROR] /Users/twer/learn/testmaven/testSrc/com/test/maven/client/HelloMavenTest.java:[11,9] cannot find symbol
</span><span class='line'>[ERROR] symbol  : class HelloMaven
</span><span class='line'>[ERROR] location: class com.test.maven.client.HelloMavenTest</span></code></pre></td></tr></table></div></figure>


<p>仔细分析，原来是在执行编译server包时，报告无法编译client包对应的测试类。怎么会在编译server包时，去编译client包对应的测试呢？仔细观察我们的pom.xml文件，在maven-compiler-plugin插件中，我们配置了对server文件的引入，这就意味着在编译server包时，不会引入client文件夹下的所有文件（当然在这里就是Java类文件）。但是，我们并没有在test-compile阶段排除client对应的测试文件。这就导致client的测试无法找到对应的实现类。找到根源，问题就好解决了，显然我们需要在test-compile阶段排除client文件夹。所以，server模块下正确的pom.xml配置为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='xml'><span class='line'>    <span class="nt">&lt;parent&gt;</span>
</span><span class='line'>        <span class="nt">&lt;groupId&gt;</span>com.test.maven<span class="nt">&lt;/groupId&gt;</span>
</span><span class='line'>        <span class="nt">&lt;artifactId&gt;</span>testmaven<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>        <span class="nt">&lt;version&gt;</span>1.0-SNAPSHOT<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/parent&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;artifactId&gt;</span>testmaven-server<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nt">&lt;build&gt;</span>
</span><span class='line'>        <span class="nt">&lt;sourceDirectory&gt;</span>../src<span class="nt">&lt;/sourceDirectory&gt;</span>
</span><span class='line'>        <span class="nt">&lt;testSourceDirectory&gt;</span>../testSrc<span class="nt">&lt;/testSourceDirectory&gt;</span>
</span><span class='line'>
</span><span class='line'>        <span class="nt">&lt;plugins&gt;</span>
</span><span class='line'>            <span class="nt">&lt;plugin&gt;</span>
</span><span class='line'>                <span class="nt">&lt;artifactId&gt;</span>maven-compiler-plugin<span class="nt">&lt;/artifactId&gt;</span>
</span><span class='line'>                <span class="nt">&lt;version&gt;</span>3.1<span class="nt">&lt;/version&gt;</span>
</span><span class='line'>                <span class="nt">&lt;configuration&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;includes&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;include&gt;</span>**/server/**<span class="nt">&lt;/include&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;/includes&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/configuration&gt;</span>
</span><span class='line'>                <span class="nt">&lt;executions&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;execution&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;id&gt;</span>default-testCompile<span class="nt">&lt;/id&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;phase&gt;</span>test-compile<span class="nt">&lt;/phase&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;configuration&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;testExcludes&gt;</span>
</span><span class='line'>                                <span class="nt">&lt;exclude&gt;</span>**/client/**<span class="nt">&lt;/exclude&gt;</span>
</span><span class='line'>                            <span class="nt">&lt;/testExcludes&gt;</span>
</span><span class='line'>                        <span class="nt">&lt;/configuration&gt;</span>
</span><span class='line'>                    <span class="nt">&lt;/execution&gt;</span>
</span><span class='line'>                <span class="nt">&lt;/executions&gt;</span>
</span><span class='line'>            <span class="nt">&lt;/plugin&gt;</span>
</span><span class='line'>        <span class="nt">&lt;/plugins&gt;</span>
</span><span class='line'>    <span class="nt">&lt;/build&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意：我在IntelliJ配置execution下的configuration节时，碰到一个问题，那就是针对testExcludes配置节没有智能提示。由于其他maven配置节在正确情况下都有智能提示，因而让我产生错误，认为这个配置项不支持testExcludes，这让我纠结了好半天。</p>

<p>对于client模块而言，如法炮制，只是包含以及过滤的文件夹反转了一个个儿而已。当我们进行install甚至deploy时，在repository下的test/maven文件夹中，看到了三个文件夹，如图所示：
<img class="center" src="http://agiledon.github.com/images/2013/maven-repository.png"></p>

<p>其中的testmaven/1.0-SNAPSHOT文件夹下并没有jar包，因为它对应的配置为主模块的配置，也就是parent配置。在这个配置中，我们将packaging的类型设置为pom了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Guava提供的Preconditions]]></title>
    <link href="http://agiledon.github.com/blog/2013/10/09/using-preconditions-of-guava/"/>
    <updated>2013-10-09T22:57:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/10/09/using-preconditions-of-guava</id>
    <content type="html"><![CDATA[<p>我看到这么一段Java代码，主要逻辑是对传入的数据对象进行分析和处理。方法除了长了一点，本身没有什么问题，但一个不好的味道是方法中充斥了一部分对对象非空的处理，以及写日志的信息。这些语句本身不属于方法的主干实现，却很讨厌地干扰了方法的主要逻辑，影响了程序的可读性。</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Processor</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">ProcessData</span> <span class="n">processData</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">processData</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">processData</span><span class="o">.</span><span class="na">getInput</span><span class="o">()</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;processData is error&quot;</span><span class="o">);</span>
</span><span class='line'>          <span class="k">return</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">List</span><span class="o">&lt;</span><span class="n">FavoratePolicy</span><span class="o">&gt;</span> <span class="n">policies</span> <span class="o">=</span> <span class="n">fetchPolicies</span><span class="o">(</span><span class="n">processData</span><span class="o">);</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">(</span><span class="n">policies</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">policies</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">&quot;can not fetch favorate policies&quot;</span><span class="o">);</span>
</span><span class='line'>          <span class="k">return</span><span class="o">;</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">for</span> <span class="o">(</span><span class="n">FavoratePolicy</span> <span class="n">policy</span> <span class="o">:</span> <span class="n">policies</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="c1">//handle policy</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>我最初想要尝试使用Guava提供的Optional。经过仔细分析，发现这里的场景并不适合Optional。Optional确实可以用于处理null object，甚至可以将其看做是Null Object模式的实现。但它为Java语言带来的好处，无非是提高了代码可读性，同时可以有效地防止程序员忘记对null的判断。它不能带来代码量的减少，用在这里，也无法消除非空判断以及日志的噪音。所幸，Guava还提供了Preconditions，它拥有更好而简洁的断言方式，可以处理程序的一些异常分支。它主要定义的方法包括checkArgument(), checkNotNull()以及checkState()等，可以通过抛指定异常的方式，将程序的主分支与异常分支有效地隔离开。通过引入checkArgument()方法，前面的代码可以调整为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Processor</span> <span class="o">{</span>
</span><span class='line'>  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">execute</span><span class="o">(</span><span class="n">ProcessData</span> <span class="n">processData</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">checkArgument</span><span class="o">(</span><span class="n">processData</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="n">processData</span><span class="o">.</span><span class="na">getInput</span><span class="o">()</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">,</span> <span class="s">&quot;processData is error&quot;</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>          <span class="n">List</span><span class="o">&lt;</span><span class="n">FavoratePolicy</span><span class="o">&gt;</span> <span class="n">policies</span> <span class="o">=</span> <span class="n">fetchPolicies</span><span class="o">(</span><span class="n">processData</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>          <span class="n">checkArgument</span><span class="o">(</span><span class="n">policies</span> <span class="o">!=</span> <span class="kc">null</span> <span class="o">&amp;&amp;</span> <span class="o">(!</span><span class="n">policies</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">()),</span> <span class="s">&quot;can not fetch favorate policies&quot;</span><span class="o">);</span>
</span><span class='line'>      
</span><span class='line'>          <span class="k">for</span> <span class="o">(</span><span class="n">FavoratePolicy</span> <span class="n">policy</span> <span class="o">:</span> <span class="n">policies</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="c1">//handle policy</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>      <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">IllegalArgumentException</span> <span class="n">ex</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">logger</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="n">ex</span><span class="o">.</span><span class="na">getMessage</span><span class="o">());</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>经过这样的处理，程序的主体逻辑变得清晰了许多，而且也能够有效地避免日志方法的重复。当然，这里也可以使用checkNotNull()方法来处理ProcessData与List<FavoratePolicy>的null情形。但由于它抛出的异常为NullPointerException，用在这里会增加一个异常捕获（因为它无法处理isEmpty()的情况），所以就一致地选择了checkArgument()方法。不过，在使用这一方法时，要注意它传入的条件表达式与原有实现的表达式是相反的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[关于《恰如其分的软件架构》]]></title>
    <link href="http://agiledon.github.com/blog/2013/08/29/about-just-enough-software-architecuture/"/>
    <updated>2013-08-29T10:39:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/08/29/about-just-enough-software-architecuture</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2013/justenough_cn.jpg">
华中科技大学出版社的徐定翔问我意见，了解我对Just Enough Software Architecture这本书的观感，看是否值得引进。时间是在2010年。从一开始，我就被书名中的Just Enough理念所吸引。它让我想起宋玉的东家姑娘，“增之一分则太长，减之一分则太短”那种不可言说的美丽。我在心里说，架构设计就需要这样。我当时并没有看到本书，只是到Amazon上找到了几篇英文原版样章。犹记得我在读到第一章介绍的RackSpace案例时那种兴奋之情。于是，我迫切地向徐定翔强烈推荐引进这本书，而我则毛遂自荐，希望能作为本书的译者。之后，我在InfoQ上看到对本书的《<a href="http://www.infoq.com/cn/articles/fairbanks-jesa">访谈和书摘</a>》，进一步加强了我翻译本书的信念。于是，出版社开始与作者Fairbanks联系，然而从此音讯如石沉大海。时针指向2011年，我对于本书是否被引进，是否由我翻译，一切未知。我觉得我可能错过了它，思之仍觉怅然。谁知到了九月，消息突然确定，而徐大编辑就不容分说地直接把原书给我寄来了。</p>

<p>拿到沉甸甸的书，第一面就为本书的装帧而惊喜。心里想，我这一辈子若能写出这样一本书，绝对值得生命走过的这一遭了。我并没有迫不及待地开始翻译，这就好似遇到珍馐美味，需得先赏其色，闻其香，然后再品其味。我每天抱着这本书饶有兴味地开始阅读之旅。阅读之旅确乎如行山阴道，沿途之美，目不暇接；可一想到翻译，这种美景就成了一种折磨，因为我害怕辜负这一美景。翻译之初我就举步维艰，那些词语放在那里，我却无法解开“封印”将它们取出来，即使取出来，却又找不到存放的合适位置。一些翻译隐隐约约浮现着，当我竭力去揭开这些词语的真面目时，无论如何用力，总也不能够着。翻译就好像那些年我们一起追过的女孩——追不到，痛苦；追到了，销魂。翻译进度像蜗牛一样的爬着，我终于决定求助了。辗转寻找了好多朋友，都以各种理由拒绝或者放弃了。翻译讲解软件架构的书，确乎不是一件轻松的事儿。那个时候，我的Buddy肖鹏正从翻译《面向模式的软件架构》第五卷的泥潭中爬了出来。每一提及他的这段翻译经历，脸上就会浮现出不堪回首的表情，如看了恐怖片。终于，事情得到转机，最开始是倪健的雪中送炭，再有高翌翔的锦上添花，随着我们这个三人组的建立，翻译才算开始走向正规，我才有了交稿的信心。</p>

<p>自从开始翻译这本书后，我与人谈架构，动辄就会提及“Just Enough，恰如其分”。我像祥林嫂一般地推介着Fairbanks提出的风险驱动模型，并认真地实践着这一模型。我开始对演进的架构有了更深入的理解。我写了《<a href="http://localhost:4000/blog/2011/10/10/design-just-enough-architecture/">设计恰如其分的架构</a>》这篇博客来详细阐述我对演进式架构的理解。在2011年我参加的技术会议上，我也反复讲解了如何遵循简单之美的原则，运用风险驱动模型设计恰如其分的架构。2012年，在我参加的一个项目中需要针对遗留系统进行技术栈迁移。我撰写了文章《<a href="http://www.infoq.com/cn/articles/legacy-system-migration">遗留系统的技术栈迁移</a>》，提到了“风险驱动模型”，并在2013年的Scrum Gathering会议上分享了我的一些想法。当然，这个模型并不是锤子，更不是银弹。它更近似于质量属性驱动的架构设计，我们要满足的质量属性，可能就是我们在做架构时需要面对的风险；而在Roy Fielding的那篇关于REST的著名论文中，也提到了对约束的识别，并演示了如何从一个空约束，通过逐步添加约束演化为REST风格的架构。从某种程度上，架构的约束可能是一种风险，也可能成为设计的驱动力。</p>

<p>前几天，我参加Agile China 2013，与我新认识的一位朋友范钢聊到了关于架构重构的问题。事实上，面向对象软件开发到现在，已有十余年之久；各种经验、模式与原则甚嚣尘上并得到较好的推广。然而新的方法、新的语言乃至新的思想仍然层出不穷，尤其是在互联网开发、大数据处理以及移动开发的冲击下，传统软件开发似乎已经开始走向末路。“只见新人笑，不见旧人哭”！？？是，也不是。实际上，在传统的企业开发领域，各种大型系统仍然像一艘庞大如巨型海兽一般的船舰在海面缓缓行驶，它或许就是沉没之前的泰坦尼克，一切还都安然无恙，你甚至可以听到船头甲板传来的悠扬的小提琴声；然而，冰川就在远处出没，船长还未察觉。我们该怎么办？这样的巨型船舰，自然不可能如艨艟快艇那般的敏捷，即使是360度的转身，也可以玩得如此漂亮、优雅。这些大型的企业级软件系统已经走过了漫长的历程，它们如此巨大以至于我们只能看到它的一角，它们的零部件如此复杂以至于没有人能够彻底弄懂。我们必须认识到，这些系统是最有权力的系统，它们很有可能掌握了人类生活的根本命脉——金融管理、股市交易、生命健康、医疗管理、机械制造、国防安全、航空、航天……它们就像政治界、金融界的那些巨头，要是患了病咳嗽两声，也许世界都要抖一抖。它们可以轻易改变吗？不能！然而若是不寻求改变，这些系统会宿命地走向衰亡。若我们无法承受重写的成本，唯一的办法或许就是架构的重构。我们必须清晰地认识到这一点。而我认为，风险驱动模型恰恰可以作为架构重构的指导原则。在进行重构之前，我们需要充分评估重构的价值，回答“为什么我们需要重构”的问题；然后去识别风险。在开始重构之前，我们需要尽可能做到万无一失。风险自然是不可避免的，但如果我们能事先识别出这些风险，就能有的放矢地选择正确的技术。风险驱动模型的第三步，则是评估风险是否得到有效缓解。不要轻视这一步！重构往往意味着还债。可是，我们该用什么来说服管理者们付出成本去做一些看似没有产生直接利益的任务呢？答案就是用数据来说话，通过比较重构前后的系统健康指标，可以加重说服老板的砝码。当然，毫无疑问，这个过程一定是迭代的。</p>

<p>我想，通过这次交谈，我进一步找到了“风险驱动模型”适用的场景。而这正是我翻译并推荐本书的根本意义。本书可以在<a href="http://product.dangdang.com/product.aspx?product_id=23320387">当当网</a>购买。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ThoughtWorks读书雷达-方法学篇]]></title>
    <link href="http://agiledon.github.com/blog/2013/08/06/methodologies-of-reading-radar/"/>
    <updated>2013-08-06T10:41:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/08/06/methodologies-of-reading-radar</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2013/readingradar03.png"></p>

<p>方法学（Methodology）看似与开发技能无关，常为程序员忽略。忽略意味着未曾察觉，却不等于它的无关紧要。我们每时每刻呼吸的空气同样会被我们忽略，但空气不重要么？不要等到我们开始戴上口罩，每日关心PM 2.5指数时，方才察觉原来空气的质量已经积重难返了。在我们的读书雷达中，方法学象限囊括的书籍多与开发过程相关。如果说开发技能是程序员修炼过程中必须加强的显式的力，则开发过程的这些思想与实践，就是隐藏的推手。你若不动，它会推你前行，然而缓慢；若你后退，则推动的阻力就大，暗流汹涌。只有自愿向前，这种助力才能如鱼得水，使你能够优游地前行。</p>

<p>软件开发说通了，不是技术问题，而是人的问题。</p>

<p>由于我们所处的领域，敏捷方法才是我们的擅长，因而在这个象限中，我们推荐的书籍主要与敏捷相关。首先推荐的是一本祖师级的经典大作，Kent Beck的Extreme Programming Explained《<a href="http://book.douban.com/subject/1099376/">解析极限编程</a>》。一切关于极限编程的思想、原则与实践，都能追本溯源到本书，寻找到这些内容的出处。如果你从未曾了解或接触过XP，通过本书，可以给你最正确的引导；若你已经在项目中运用了XP，却又心存疑虑，阅读本书一定能为你答疑解惑。</p>

<p>相较于《解析极限编程》更偏重理论，Henrik Kniberg的著作Scrum and XP from the Trenches《<a href="http://book.douban.com/subject/5501718/">硝烟中的Scrum和XP</a>》会带给你不同的感受。我们喜欢它的短小，简单，实用，书的气质分外地符合敏捷的精神。该书是Henrik Kniberg真实项目经验的提炼，讲述了成功敏捷团队的工作过程，没有理论、没有引用、没有脚注、没有废话。它可以作为基础实践的入门指南，帮助团队正确实施Scrum与XP——但不能模仿。你需要了解自己所处的环境，进而对具体实践做出取舍，创造出属于自己的过程。</p>

<p>如今，精益思想已经被许多不同的行业所广泛采用，该思想在软件行业的影响尤为显著。现代化的软件开发思想和实践方法，早就开始从精益思想里学习和借鉴，包括迭代开发，质量内建，一人多技，一岗多能，全功能团队，看板管理，持续改善等等。精益思想背后的想法可以追溯到上个世纪40年代后期，丰田公司的一群工程师发现了在连续流动中进行少量生产的方法，这种方法可以像传统的大量生产者批量生产大量产品的方法一样有效率。对于初次接触精益思想的读者来说，这种&#8221;少量生产和批量生产一样有效率&#8221;的思想，未免有些反直觉和难以理解，因为我们从小接触到的观念就是”只有大批量生产才是有效率的“。Freddy Balle等人的著作The Golden Mine《<a href="http://book.douban.com/subject/1852682/">金矿</a>》就是为初次接触精益思想的读者准备的。本书采用小说的形式，描述了一家濒临破产的企业如何采用精益的方式，扭亏为盈，让人读起来非常轻松有趣。</p>

<!--more-->


<p>在我们推荐的初学读物中，基本上覆盖了XP、Scrum与精益等主流的敏捷软件开发方法与思想。但是，我们还单独挑出了Mike Cohn的著作User Stories Applied《<a href="http://book.douban.com/subject/4743056/">用户故事与敏捷方法</a>》。因为——需求的重要性无论怎么强调都不为过，只有真正理解了用户需求，才能谈得上软件开发的成功。软件的需求说明不一定要是冷冰冰的，也未必需要庞大复杂的方法理论。用户故事对需求的描述更为柔和，预留了讨论和想象的空间，又能借助此作为项目评估的依据，需求分析和确认的基础。本书是描述用户故事的经典之作，几乎涵盖了编写用户故事的方方面面，同时又结合了敏捷开发思想的精髓，以加深你对敏捷开发的理解。</p>

<p>若要更上一层楼，我们还需要进一步了解更多的实践方法，当然，也包括理论的升华。许多方法大都源于实践，然而若无更高抽象层次的思想体系，则方法仅能作用于一事一物，场景一变，就只能偃息旗鼓了。正如你看一花的开放与衰败，并不能知春来与秋逝；只有把握内在的自然运行规律，四季的变换才可以被知悉。因而就精益思想而言，我想，阅读《金矿》不过是让你有了登堂入室的资格，若要走得更深，吃得更透，更好的阅读选择还是James P. Womack等人的经典之作Lean Thinking《<a href="http://book.douban.com/subject/1424857/">精益思想</a>》。该书阐述了精益思想的五大基本原则，并阐明了一些用于所有行业，并能创造永久价值的简单而有效之原理。同时，为了更好地说明这些原理，并阐释该如何应用它们，给出了大量包括应用步骤和从大企业到小企业的应用实例。本书的视角非常的高远，它将精益思想传播到了产品生产的整个价值流，关注于精益企业的打造。这种精益思想的全局观，可以让我们跳出软件行业的狭窄领域，观察更加广阔的天地。</p>

<p>Paul Duvall等人的Continuous Integration《<a href="http://book.douban.com/subject/2580604/">持续集成</a>》和Jez Humble的《<a href="http://book.douban.com/subject/6862062/">持续交付</a>》，加上Martin Fowler的<a href="http://www.martinfowler.com/articles/continuousIntegration.html">Continuous Integration</a>，可以看做是软件构建的三部曲。你以为持续集成亦然达到了目标，可是距离交付又还差了最后一公里。然而，没有持续集成，所谓持续交付又成了一句空话。便宜的阅读方法是快速浏览Martin Fowler的这篇文章后，直接步入Jez Humble建造的持续交付殿堂。这个殿堂没有售票员拦着你查看你手持的行程票；但是，在跨入这扇门之前，先去敲开Paul那扇门，会让你的步伐走得更坦然。持续集成和持续交付到底有多重要？在我连续经历了具有持续集成与持续交付能力的项目后，要让我再回到以前的项目开发状态，我会以为自己被遣送到软件宇宙的太初，一片混沌。</p>

<p>我们的读书雷达面向程序员，可是我们仍然毫不犹豫地推荐了诸多与测试相关的著作。这一认识完全符合精益的“一人多技”原则。团队成员一起战斗，程序员对测试说：“我把后背交给你！”然后，义无反顾地冲上前去战斗。可你冲得越猛越快越发的犀利，后背的测试就越撑不住。换言之，你理解为你支撑后背的测试人员吗？当团队需要你的测试技能时，你能挺身而出吗？阅读Lisa Crispin的Agile Testing《<a href="http://product.china-pub.com/53665">敏捷软件测试</a>》，可以让你切换到测试视角，观察我们该如何在敏捷项目中执行测试行为以保障软件的质量。作者在测试领域浸淫了丰富的项目经验，因而能够完整全面地勾勒出敏捷测试的全景，且又能深入到测试的细节，可谓敏捷测试的集大成者。因此，Robert Martin推荐本书，认为它“实用、智慧、反对教条。本书意义重大，每一位软件专业人员都应该阅读”。</p>

<p>James A. Whittaker等撰写的著作<a href="http://book.douban.com/subject/7065508/">How Google Tests Software</a>揭秘了作为本世纪最成功的软件企业之一的Google，是如何应对和处理软件测试的复杂性的。Google通过对自身软件特征的定位，自我演化出一种非同寻常的测试文化。这种特立独行并非刻意为之，而是从工程实用性的角度量体裁衣。Google的测试开发工程师（SET）角色正是这种工程实用文化的凸显。Google的高级工程总监Patrick Copeland认为：“最好的办法是让测试人员有能力把测试作为产品的真实的功能写到代码库里，测试作为产品的一个功能应该和真实用户可以看到的其他功能一模一样。”这种测试工程文化未必能够照搬照学，但其中内涵的一些测试策略与原则，仍旧值得我们学习和借鉴。</p>

<p>如果是在5年或者8年之前，我们推荐阅读Matt Stephens与Doug Rosenberg的著作Extreme Programming Refactored《<a href="http://book.douban.com/subject/1400341/">重构极限编程</a>》，是希望读者能够冷静地思考极限编程，不为各种吹捧而着迷。然而，时至今日，那种膨胀以及夸大地吹捧已经烟消云散，使得我们多数人已经能够正确地对待敏捷方法，对待极限编程。那么，为何我们还要推荐本书？这是因为，我们希望转动一下极限编程的水晶球，观察它不同的棱面，即便是面对暮色折射出的幽暗光芒，同样有其诱人之处。反面地或者说批判地审视极限编程，并不会彻底的否定极限编程推崇的实践与原则，只是予我们以警示，要求我们结合具体场景因地制宜，因人而异地推行这些敏捷实践。本书只不过是完整地拉开了极限编程的帷幕，让我们不只看到了舞台上的精美表演，也看到了角落一隅可能存在的混乱与无序。</p>

<p>工程师其实并不擅长用文字去描述自己所思所想，因此何谈准确描述客户的需求？我们喜欢事实说话，数字说话，因为它不会撒谎，不会虚饰，因而不会误解。这正是Specification By Example《<a href="http://book.douban.com/subject/11611022/">实例化需求</a>》的出发点。该书是作者Gojko Adzic从大量工程项目得来的经验，基于大量的业内研究提炼出来的知识总结。这种实例化需求的方式既能清晰地表述需求，消除客户、需求分析师、开发人员与测试人员在沟通中可能产生的理解分歧；又极为融洽地支持开发人员进行有效地测试驱动，帮助测试人员条理清晰地完成对需求功能的验收和测试。实例化需求不仅仅是一种方法，更是一种对软件开发方法学的革命，我如此认为。</p>

<p>注：本文由张逸与刘龙军共同完成。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Spray的模块结构]]></title>
    <link href="http://agiledon.github.com/blog/2013/08/02/analysis-sourcecode-of-spray-1/"/>
    <updated>2013-08-02T22:07:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/08/02/analysis-sourcecode-of-spray-1</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://agiledon.github.com/images/2013/spray_logo.png">
Spray是基于Akka之上的轻量级Scala库，提供对客户端与服务端REST/HTTP的支持。在使用上，大概可以将其视为Java平台下的Jersey；虽然它们的特性并不尽相同。从Scala语言来看，它提供的Future与Promise可以较好地支持并发；而Akka的Actor模型无疑助推了Spray的并发处理性能。根据<a href="http://spray.io/">Spray官方网站</a>的描述，它拥有如下的特性：</p>

<blockquote><p>完全异步的，无阻塞的APIs<br/>基于Actor与Future<br/>高性能<br/>轻量级<br/>模块化<br/>可测试性</p></blockquote>


<p>之所以称其为库（library）而非框架（Framework），源于Spray的设计哲学。似乎在Spray的设计者眼中，只要沾上了“框架”这个名词，就显得不够轻量，耦合也会随之而来。虽然框架并非容器，无需管理诸多对象的生命周期，但它总会为应用添加一些框架级别的约束。框架更像是一个骨架（Skeleton），应用所要做的是将自己的内容填充到这个骨架中。应用能否运行良好，取决于框架的支撑作用。以我之浅见，大约可以如此简单分辨：框架之于应用，是一种白盒式的调用，你须得了解一些框架细节，遵循规定的约束或规范，才能更好地发挥框架的威力；而类库之于应用，则是职责向黑盒传递的委派，若要调用库，只需明晓其接口即可。</p>

<p>正如Spray的官方网站所说，Spray更像是基于Http搭建的一个集成层（Integration Layer）。因此你不必将自己的应用搭建在Spray之上，仅仅是当需要对Http的集成时，Spray可以成为你的一项选择。这种松散耦合，去除“供应商绑定”的方式，实在招人喜爱。Spray引人驻足的魅力，不仅在于Akka Actor模式对并发的良好支持，Scala语言本身也使其增色不少。Scala的语法较之Java更其灵活而先进，那些支持不变式、函数编程以及闭包等特性，总会让Java程序员垂涎三尺(至少在Java 8之前)。若再遥想不远将来Scala提供的async以及await（一如C# 5.0的语法特性），编写Scala程序应大有可为。当然，或也可能成亦Scala，败亦Scala，毕竟面对数量级庞大的Java程序员，Scala仍属小众。这会成为Spray的阿克琉斯之踝吗？</p>

<!--more-->


<p>诸多因子促使我选择Spray作为一个研究对象。我想，通过使用Spray，并深入挖掘其源码，定能让我受益良多。当然，在剖析其源代码之前，先让我们看看Spray的模块结构吧。
<img class="center" src="http://agiledon.github.com/images/2013/spraymodules.png"></p>

<p>既然Spray号称其具有松散耦合的组件结构，就让我们对这些模块间的依赖来一个先睹为快。要识别模块之间的依赖关系，最直观的方式莫过于绘制一个依赖图：
<img class="center" src="http://agiledon.github.com/images/2013/spraydepencies.png"></p>

<p>整洁的依赖显得清爽，斩钉截铁，绝不拖泥带水。那种如网一般深邃的依赖关系，会让人迷失。这其中的要点，仍然在于职责的分配。借助依赖关系图可以更加直观展现，何处出现多余或繁复的依赖线与环，肉眼即可观察获得。这种图甚至可以通过直觉去感受，只要绘图得当，布局合理，会有平衡之感。</p>

<p>如上图所示，以浅绿标明的三个模块，都处于被依赖的层次，按照“依赖沉淀”的法则，我将其放在整个图的最底层。观其名，我们似乎也可察知这几个模块更倾向于基础设施或公共设施的范畴。值得特别书写的是spray-http，因为该模块除了必须依赖的Scala之外，完全独立，没有任何依赖。它提供了基本的Http数据结构，如Request，Response以及其他公共Header。对于一个支持Http的库而言，可以视其为核心。</p>

<p>spray-caching提供了基本的缓存功能，是一个非常小的模块，仅仅包含cache.scala与LruCache.scala两个类。它引入了Future对象，使其能够更好地满足并发处理的缓存。此外，它还调用了google code上的一个第三方开源库concurrentlinkedhashmap（上图的紫色模块），作为存储Future对象的数据结构。spray-can是整个库的主要模块，提供了高性能的Http Server与Client。在这个模块中，主要的APIs都直接或间接继承了Akka提供的Actor。spray-servlet扮演了适配器的角色，它的主要目的是在Servlet API之上提供spray-can的服务器接口，从而使得spray能够在servlet容器中使用路由功能。因此，该模块除了依赖spray-util与spray-http之外，实则还要依赖于Java的Servlet。注意，上图的虚线依赖说明的是一种可选的关系。单从这一点来看，也部分说明了spray模块间的松散耦合度。一个示例是上图未曾列出的spray-json，就属于可选的用于处理json的模块。</p>

<p>无论是依赖关系，还是模块职责展现的抽象层次，spray-client与spray-routing都属于更加high-level的模块。例如spray-client可以视为对spray-can中提供的Http Client APIs的包装，属于更高层次的抽象。spray-routing则以优雅的DSL形式提供了定义REST服务的接口。</p>

<p>观察Spray的模块分解，非常注重职责的内聚，并以较小的粒度划分模块。由于它的设计目标为库，每个模块展现了自己的关注点，使其能够最大限度地被用户单独使用。例如当我仅需要缓存功能时，完全可以忽略Spray中支持HTTP以及REST的模块。同时，它注重调用视角的区分，为不同的调用者提供不同的抽象层次。在充分满足松耦合、高内聚的架构原则之上，适度地考虑接口的可用性与可读性。我喜欢这样一种轻量级的，尽其可能简单的架构设计。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[AgileChina2003架构演进杂志]]></title>
    <link href="http://agiledon.github.com/blog/2013/07/29/agilechina-magazine/"/>
    <updated>2013-07-29T22:06:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/07/29/agilechina-magazine</id>
    <content type="html"><![CDATA[<h3>“架构演进”介绍</h3>

<p>软件系统的架构从来都不是一蹴而就的，它需要在不断的演化中改进设计，甚至做出重要的架构迁移。尤其对于大型软件系统而言，组织管理、软件过程、需求变化、规模扩张、技术迁移、遗留系统等诸多因素都决定着架构的发展，甚至可能是诸多力量的博弈与权衡。</p>

<h3>技术文章</h3>

<h4>演化架构与紧急设计系列</h4>

<p>本系列文章旨在从全新的视角来介绍经常讨论但是又难以理解的软件架构和设计概念。作者 Neal Ford 将通过介绍一些具体示例来帮助您在演化架构和紧急设计的灵活实践中打下坚实的基础。通过将重要的架构和设计决定推迟到最后责任时刻，您可以防止由于不必要的复杂度而降低软件项目质量的问题。点击<a href="http://www.ibm.com/developerworks/cn/java/j-eaed/">链接</a>。</p>

<h4>遗留系统的技术栈迁移</h4>

<p>遗留系统是一个还在运行和使用，但已步入软件生命周期衰老期的软件系统。它可能会因为无法满足新的质量需求，又或者是出于企业战略决策的考虑等诸多原因，需要对其进行技术栈迁移。然而，在迁移过程中，我们既需要满足迁移后的需求，又必须保证原有的系统功能不会受到破坏，这就为技术栈迁移制造了障碍。本文提出运用“风险驱动模型”来完成这一工作。风险驱动模型就是通过识别风险，对风险排定优先级；然后根据风险选定相关技术，再对风险是否得到缓解进行评估的一种架构方法。点击<a href="http://www.infoq.com/cn/articles/legacy-system-migration">链接</a>。</p>

<h4>注重实效的架构师——大胆行前人未行之路</h4>

<p>是什么让架构师们精通自己的技艺？熟练的架构师是如何进行设计的？一次次，有人问起我这些问题，而我也不止一遍的问我自己。很明显，这并不只是软件工程过程、设计方法、技术或是编程的专业程度所决定的。很多架构师具备令人钦佩且完备的技术知识，这确实是使设计成功的必要条件。但是，还是有很多的软件项目失败了，或是在项目的架构中遭受到了严峻的挑战。掌握此道的关键在于架构师是以什么方式实现设计，他们重视什么，他们关注哪些方面以及在这些方面努力着。点击<a href="http://www.infoq.com/cn/articles/pragmatic-architect">链接</a>。</p>

<!--more-->


<h4>可扩展Web架构与分布式系统</h4>

<p>开放源代码已经成为一些大型网站的基本原则。而在这些网站成长的过程中，一些优秀的实践经验和规则也出现在他们的结构中。本文旨在介绍一些在大型网站结构设计的过程中需要注意的关键问题以及实现目标的基础工作。本文侧重于介绍网络系统，尽管一些准则在其他分布式系统中也是适用的。点击<a href="http://www.oschina.net/translate/scalable-web-architecture-and-distributed-systems">链接</a>。</p>

<h4>架构师</h4>

<p><img class="left" src="http://agiledon.github.com/images/2013/07/nealford.png"></p>

<h5>Neal Ford</h5>

<p>Neal Ford是全球IT咨询公司ThoughtWorks的软件架构师。除了常规工作，他做的事情还包括设计和开发应用程序、教学材料、杂志文章、课件和视频/DVD演示，同时还是各种技术书籍的作者或者编辑，其中包括著作The Productive Programmer。他专注于设计和开发大规模企业应用程序，同时，他也是世界开发人员会议的国际知名演说家。
<img class="right" src="http://agiledon.github.com/images/2013/07/ericevans.png"></p>

<h5>Eric Evans</h5>

<p>大型业务系统方面的领域建模和设计专家。早20世纪90年代，他就参与了很多项目，基于对象（Object）开发出许多大型的业务系统，并致力于将敏捷过程应用到现实项目中。
此外，Eric Evans还是《领域驱动设计——软件核心复杂性应对之道》一书的作者。在书中他总结了构建上述业务系统相关的经验、原则和技术等。并介绍了一个建模和设计技术的系统，成功的团队应用这一系统可以组装有业务需求的复杂软件系统，并使系统在增大时仍然保持敏捷。
Eric现在是“Domain Language”组织的负责人。该组织是一个咨询小组，它指导和训练团队实施领域驱动设计，帮助他们使自己的开发工作对业务而言更有生产力和更有价值。<img class="left" src="http://agiledon.github.com/images/2013/07/buschmann.png"></p>

<h5>FranK Buschmann</h5>

<p>德国慕尼黑西门子技术公司资深技术专家及负责人。Wiley软件设计模式系列图书主编。他的研究领域包括对象技术、软件架构、产品线、模型驱动软件开发和模式。他曾是ANSI C++标准化委员会x3J16的成员，于1996年发起了首届EuroPLoP会议。Frank Buschmann是Pattern-Oriented Software Architecture系列书籍的主要作者。
<img class="right" src="http://agiledon.github.com/images/2013/07/george.png"></p>

<h5>Fred George</h5>

<p>Fred George先生在敏捷开发领域颇有声望，在业界有将近40年的开发经验，是国际敏捷领域大师级专家、咨询师、架构师。早年他在IBM工作。退出IBM之后，以独立咨询师的身份在美国工作了十多年。后来他加盟了ThoughtWorks，成为早期致力于推动敏捷开发的一批开发者。现在他离开了ThoughtWorks，在英国的TrafficBroker公司就任解决方案架构师一职。</p>

<h4>推荐书籍</h4>

<p><img class="left" src="http://agiledon.github.com/images/2013/07/releaseit.png">#####Release It!</p>

<p><strong>推荐理由：</strong>Michael Nygard的Releast It!可以看做是处理软件系统质量属性的治病良方。本书常常会以一个具体的实例开始阐述某一个质量属性的关键性，并列出一系列的反模式作为参照和对比，最后再给出正确的模式列表。这种针对问题的叙事方法，使得读者往往能够照方抓药，又因为模式的叙述如此清晰而规范，所以常常能药到病除。正如本书书名所指，这些内容确乎与软件的发布息息相关。</p>

<p><img class="right" src="http://agiledon.github.com/images/2013/07/beautifularchitecture.png"></p>

<h5>Beautiful Architecture</h5>

<p><strong>推荐理由：</strong>全书涵盖的内容广博而宏大，涵盖了架构基本原则、企业级应用架构、系统架构、最终用户应用架构、语言与架构，分列为本书的五大部分，读之会让人产生目不暇接之感。尤其对于术有专攻的程序员来讲，要彻底吃透本书讲解的内容，无疑是一项艰巨的挑战。然而，如果从架构师所必须具备的技能来看，本书的内容其实并没有超出架构的范畴，因为架构师必须要见识广博，你才能针对不同的需求场景，面对不同的实现技术，选出最适合当前场景的恰如其分的架构方案。</p>

<p><img class="right" src="http://agiledon.github.com/images/2013/07/eip.png"></p>

<h5>Enterprise Integation Patterns</h5>

<p><strong>推荐理由：</strong>本书关注企业级软件系统的本质问题，那就是集成。对于采用异步消息传递的集成方案，本书针对不同场景给出了不同的解决方案，并以模式的方式进行概述与归纳。倘若你在设计软件系统时，需要使用异步消息传递的方式对系统进行集成，本书可以成为你的最佳指南。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[代码是如何腐化的]]></title>
    <link href="http://agiledon.github.com/blog/2013/07/05/corrupt-code/"/>
    <updated>2013-07-05T14:26:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/07/05/corrupt-code</id>
    <content type="html"><![CDATA[<p>代码是如何腐化的？这是一个很大的话题，因为这种腐化的代码样本可能会体现不同的特征，若要彻底总结，可能会又是一本《重构》。我自然没有这个能力和知识。好在有一个简便的说法，即可以诉诸于“破窗理论”的威力。无论多少坏味道识别，重构手法运用，提高代码质量的最佳实践，以及运用诸多甄别代码质量体征的工具，都仅仅限于“术”的运用而已。若未能在开发人员内心树立整洁代码的习惯，时时刻刻对各种代码臭味保持敏感，且具有一颗期待卓越代码之心，那么，随着项目的演进，时间的推移，代码最终还是会慢慢腐烂。</p>

<p>这几日在开发一个User Story时，从诸多测试代码（包括集成测试与验收测试）中，观察到了一些接近腐烂的代码坏味。这些代码虽然不是产品代码，但同样是我们交付工件的一部分。最关键之处在于：它让我察觉到一种危险的趋势，若不能及时扭转，可能会让代码陷入腐烂的泥沼。若能及时解决这些糟糕代码，其实仅仅需要一些简单的重构手法，付出几个小时时间即可。</p>

<p>首先是针对集成测试的数据准备。我们要编写的集成测试针对Spring Batch Job，这些Job需要访问数据库，以验证Job的执行是否符合期望。我们发现在之前已有与Spring Batch Job相关的集成测试存在，并提供了访问数据库，以及启动、访问和停止Ftp服务器的功能。其中，与数据准备有关的功能放到单独定义的Fixture类中。这些Fixture是为特定目的编写的数据准备，可是，随着越来越多的Batch Job出现，有诸多集成测试都需要准备数据，于是开始慢慢产生了测试数据的重叠，逐步浮现出违背DRY原则的征兆了。</p>

<!--more-->


<p>对于多数程序员而言，并非不重视重用，但多数却不愿意为了重用付出一些代价。例如针对一些具备差异性的功能，一些程序员更愿意使用Copy And Paste，然后再针对自己的需求对实现进行修改或调整。观察目前的一些集成测试，正是这样一些陋习导致的。</p>

<p>在这些集成测试中，使用了继承的方式来重用数据准备的功能。如下图所示：
<img class="center" src="http://agiledon.github.com/images/2013/07/datafixture.png"></p>

<p>在CustomerIntegratedDataFixture中，提供了相关方法实现了对Customer数据的创建。由于需要提供访问FtpServer的功能，因此又定义了CustomerIntegratedDataAndFtpPrepareFixture类，使其继承CustomerIntegratedDataFixture。它定义了startFtpServer()和stopFtpServer()方法，并在JUnit中，运用了@BeforeClass与@AfterClass标记，使其避免为每个测试启动和停止专有的FtpServer。现在，我们编写的集成测试同样需要与Customer有关的数据，但并不需要Ftp功能。换言之，我们希望重用CustomerIntegratedDataFixture。现在看来，似乎并没有问题。例如，我们可以让新增的测试直接继承CustomerIntegratedDataFixture。然而，就在同样的集成测试模块中，我们还发现了其他集成测试同样编写了自己的数据准备类。这些数据准备与Spring Batch Job无关，却同样提供了准备Customer数据的功能。存在的差异是它除了提供Customer数据外，还提供了依赖Customer的Consent数据。</p>

<p>我们没有着急去重用CustomerIntegratedDataFixture，因为我们察觉到代码会随着这种继承体系的延伸，会变得越来越难以重用。如上图的继承体系，使得数据准备与Spring Batch Job紧耦合了，同时又在CustomerIntegratedDataAndFtpPrepareFixture子类中引入了与Ftp有关的耦合，明显违背了单一职责原则。我们需要单独剥离出数据准备的类，它即可以作为超类被集成测试类继承，也可以通过组合的方式被继承了JobLauncherTestUtils的测试子类所调用。这符合Bridge模式的设计原则。因此，我们运用了“Replace Inheritance with Delegation”手法，对其进行了简单重构：
<img class="center" src="http://agiledon.github.com/images/2013/07/datafixtureafterrefactor.png"></p>

<p>之后，我们对Customer和Consent对应的数据准备类进行了相应的重构与修改，使得这些数据的准备更为内聚，并去除一些不必要的重复，使之更容易被重用。
<img class="center" src="http://agiledon.github.com/images/2013/07/customerfixture.png"></p>

<p>第二个例子是在JBehave的Story中，我看到了这样的Steps类的组织，如图：
<img class="center" src="http://agiledon.github.com/images/2013/07/steps.png"></p>

<p>我们看到了什么？——一个“扁平组织”的Steps类。显然，促成这样的结果是一个渐进的过程。由于在之前编写相关的Steps类时，还看不到分类的概念，因此，只是简单地将自己的Steps类放到step之下即可。然后，不断有开发人员增加自己的Steps类，他们找到了step位置，却没有仔细思考是否需要更好地对Steps类进行组织。这就使得Steps类略显零乱，没有展现出好的结构。我们重新组织了这些Steps类：
<img class="center" src="http://agiledon.github.com/images/2013/07/stepsafterrefactor.png"></p>

<p>只需要简单地归类，调整结构，整个Steps类就变得更加清晰了。于是，我们发现了可以重用的可能。观察重新组织之后的batch包，这里面包含的UpdateCustomerTypeSteps，ProductSystemLinkLoaderSteps与DeleteOrphanedRecordsSteps，都是与Btach Job有关的Steps类。MaintainProspectsSteps类则是我们新增的类，它同样需要用到启动Batch Job的方法。在之前存在的Steps类中，已经存在相似的代码了。例如在UpdateCustomerTypeSteps类中：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="nf">waitAndGetSatus</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">params</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">status</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">MAX_TRY_TIME</span><span class="o">;</span> <span class="n">index</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">status</span> <span class="o">=</span> <span class="n">getJobStatus</span><span class="o">(</span><span class="n">params</span><span class="o">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="s">&quot;COMPLETED&quot;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">status</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">break</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">WAIT_INTERVAL</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">status</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="nf">getJobStatus</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">params</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">db2JdbcTemplate</span><span class="o">.</span><span class="na">queryForObject</span><span class="o">(</span><span class="s">&quot;select jobExec.STATUS from TCIST_JOB_EXECUTION jobExec &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;inner join TCIST_JOB_PARAMS jobParam on jobExec.JOB_INSTANCE_ID = jobParam.JOB_INSTANCE_ID &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;and jobParam.KEY_NAME = &#39;retry&#39; &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;and jobParam.STRING_VAL = ?&quot;</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">params</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="s">&quot;retry&quot;</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>再看DeleteOrphanedRecordsSteps类：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="nf">waitAndGetSatus</span><span class="o">(</span><span class="n">String</span> <span class="n">currentTime</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">status</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">MAX_TRY_TIME</span><span class="o">;</span> <span class="n">index</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">status</span> <span class="o">=</span> <span class="n">getJobStatus</span><span class="o">(</span><span class="n">currentTime</span><span class="o">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="s">&quot;COMPLETED&quot;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">status</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">break</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">WAIT_INTERVAL</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">status</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="nf">getJobStatus</span><span class="o">(</span><span class="n">String</span> <span class="n">currentTime</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">queryForObject</span><span class="o">(</span><span class="s">&quot;select jobExec.STATUS from TCIST_JOB_EXECUTION jobExec &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;inner join TCIST_JOB_PARAMS jobParam on jobExec.JOB_INSTANCE_ID = jobParam.JOB_INSTANCE_ID &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;and jobParam.KEY_NAME = &#39;time&#39; &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;and jobParam.STRING_VAL = ?&quot;</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">currentTime</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>比较这些方法，除了jobParam的key与value存在细微区别，其余实现完全相同。若按照这样一个态势发展，随着与Batch Job有关的Story逐渐增多，不发现这种代码的臭味并即刻解决，这些代码就会逐渐蔓延，最后变得“无法自拔”。想要修改，已经变得极为困难了。</p>

<p>我们为这些Steps类提供了一个抽象的超类AbstractBatchJobSteps，并将这些可能重用的方法提取到这个超类中：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">AbstractBatchJobSteps</span> <span class="kd">extends</span> <span class="n">AbstractSteps</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">WAIT_INTERVAL</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">final</span> <span class="kt">int</span> <span class="n">MAX_TRY_TIME</span> <span class="o">=</span> <span class="mi">30</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">protected</span> <span class="n">String</span> <span class="nf">waitAndGetSatus</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">params</span><span class="o">,</span> <span class="n">String</span> <span class="n">paraKey</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">status</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">MAX_TRY_TIME</span><span class="o">;</span> <span class="n">index</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">status</span> <span class="o">=</span> <span class="n">getJobStatus</span><span class="o">(</span><span class="n">params</span><span class="o">,</span> <span class="n">paraKey</span><span class="o">);</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="s">&quot;COMPLETED&quot;</span><span class="o">.</span><span class="na">equals</span><span class="o">(</span><span class="n">status</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                <span class="k">break</span><span class="o">;</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="n">WAIT_INTERVAL</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">status</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="nf">getJobStatus</span><span class="o">(</span><span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">params</span><span class="o">,</span> <span class="n">String</span> <span class="n">paraKey</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">queryForObject</span><span class="o">(</span><span class="s">&quot;select jobExec.STATUS from TCIST_JOB_EXECUTION jobExec &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;inner join TCIST_JOB_PARAMS jobParam on jobExec.JOB_INSTANCE_ID = jobParam.JOB_INSTANCE_ID &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;and jobParam.KEY_NAME = &#39;&quot;</span> <span class="o">+</span> <span class="n">paraKey</span> <span class="o">+</span> <span class="s">&quot;&#39; &quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;and jobParam.STRING_VAL = ?&quot;</span><span class="o">,</span> <span class="n">String</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">params</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">paraKey</span><span class="o">));</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如上的例子都可以通过一些细小的重构手法改进代码，使得代码的结构更加清晰，并有利于代码的重用。我深信大多数开发人员都具备这样的技能，且只需要稍加思索，即能发现这些代码的坏味。然而，我们总是因为种种原因，对这种还不太严重的“破窗”风景视而不见。殊不知当我们开始对这种不够整洁的代码采取纵容态度时，就可能会是代码腐化之始。一旦真正腐化，就将积重难返，到了那时，我们就可能真正无能为力了。</p>

<p>你是否遭遇过这样的情形？面对一个承担了无数职责似乎无所不能的上帝类，它被无数多的Client调用，且又没有足够覆盖率的测试，你是否会产生心有余而力不足的感慨。这时的你，是否像一位奋战沙场，出生入死却无力挽回败局的将军，面对那汹涌而来占据压倒性优势的敌军，唯有对天长叹：“某有心杀贼，却无力回天啊！”</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用扩展方法实现重用]]></title>
    <link href="http://agiledon.github.com/blog/2013/06/16/reuse-with-extention-method/"/>
    <updated>2013-06-16T20:06:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/06/16/reuse-with-extention-method</id>
    <content type="html"><![CDATA[<p>我们已经有了一个IRepository接口，它提供了诸如BatchSave()，Insert()之类的方法。其中，BatchSave()方法接收一个由实体类组成的数组，从而完成对实体对象的批量存储。
<img class="center" src="http://agiledon.github.com/images/2013/06/IRepository.png"></p>

<p>对于单个实体对象而言，我们当然也需要有相关的方法来完成存储。它与BatchSave()的区别仅在于它要接收的参数只是一个实体对象。事实上，我们可以调用IRepository接口本身提供的BatchSave()来实现Save()方法。Save()方法的实现对于所有实现了IRepository接口的类而言，完全是一样的。那么，我们该如何为IRepository接口增加一个Save()方法，同时又能避免代码做出太多修改？由于接口自身并不能提供实现，因此唯一可以容纳这个方法实现的就是实现了IRepository接口的类。一个办法是为所有这些实现类定义一个公共的抽象父类，并让它再实现IRepository接口，于是将Save()的实现放到这个抽象父类中，就可以使得所有子类共享Save()方法的实现了。可是，为了这个Save()方法的实现与重用，专门引入一个抽象父类，是否值得呢？除非在现有的Repository继承体系中，已经存在了这样的抽象父类，否则该类的引入会导致整个继承体系发生较大的变化。</p>

<p>在.NET中，我们可以巧妙地借助扩展方法来完成对Save()方法的重用，同时又能保证现有的继承体系不变。方法就是为IRepository接口提供扩展方法：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='csharp'><span class='line'><span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">RepositoryExtensions</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="n">Save</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">this</span> <span class="n">IRepository</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">repository</span><span class="p">,</span> <span class="n">T</span> <span class="n">entity</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">repo</span><span class="p">.</span><span class="n">BatchSave</span><span class="p">(</span><span class="k">new</span><span class="p">[]</span> <span class="p">{</span><span class="n">entity</span><span class="p">});</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[处理文件请求限制]]></title>
    <link href="http://agiledon.github.com/blog/2013/06/13/handle-the-limitation-of-requesting-file/"/>
    <updated>2013-06-13T21:29:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/06/13/handle-the-limitation-of-requesting-file</id>
    <content type="html"><![CDATA[<p>在我参与的一个项目中，遇见了一个结合功能性需求与非功能性需求，并要求同时满足的场景。它的功能其实很简单，就是需要向系统发出处理文件的请求。文件的处理则涉及到多个数据表的查询，对相关数据的解析，并依照事先设定好的模板填充数据，最后生成PDF文件。一旦文件处理完毕，就可以返回处理后的文件。由于该系统的业务特殊性，这一功能需求会在某个特定时间，迎来数以万计的客户请求。同时，文件处理功能是一个相对漫长的处理过程，且生成的文件较大。在系统的最初版本中，经历过数千人次的并发数，在只有一台服务器的情况下，导致了大量请求的阻塞。同时，由于加载文件和文件读写需要耗费内存，在请求较为频繁的情况下，多次抛出OutOfMemory异常。即使在最好的情况下，服务端响应了客户端请求，也可能花费大量的时间，严重影响了用户体验。</p>

<p>我们希望在后续版本中解决这一问题。然而，现实总是这么残酷。真正处理文件并提供下载功能的系统并不在我们的掌控之中。它是第三方Vendor提供的Web Service，我们开发的系统仅仅涉及到请求的转发，完成对该Web Service的调用；并在获得结果后，将响应（包含了文件流数据）返回给客户端。换言之，我们既不能改善文件处理的实现逻辑，以提高处理的速度；也无法对该Web Service进行水平伸缩，例如通过引入多台服务器建立集群和负载均衡的方式。</p>

<p>遭遇如此场景实属无奈，要得出好的设计决策就好似戴着镣铐跳舞，只有在自己的服务端下功夫。我们首先想到的是限流（throttle）的方式，通过引入一个类似Controller角色的对象RequestHandlerPool，对客户端的请求进行控制。我们可以设定一个阈值，一旦超过该阈值，就将后续的请求放入队列进行排队。这个限流可以采用简单地在内存实现请求池全局对象。当然，也可以考虑引入消息队列中间件。改进后的时序图如下所示：
<img class="center" src="http://agiledon.github.com/images/2013/06/filehandling.png"></p>

<p>引入RequestHandlerPool仅仅是对请求进行了限制，从而避免请求过多导致File Cabinet的阻塞，或者导致抛出OutOfMemeory异常。但整体的处理时间并没有得到任何改善。我们首先考虑将该功能分为两阶段。第一阶段是发起对文件的处理请求，第二阶段则是下载处理好的文件。对于耗时较长的文件处理请求，可以考虑使用异步请求，一旦文件处理完毕，就可以通过Callback通知请求者。然而，由于文件处理的时间过长，可能会导致请求者不愿继续等待结果，从而退出系统，形成一次失败的请求。因而，我们考虑系统的Callback可以通过发送邮件的方式通知发出请求的客户，在邮件内容中附带下载地址，以供客户下载。</p>

<p>纵观整个场景，存在太多制肘，我们也没有太多好的解决方案。而且，我们还应该保证这个解决方案足够简单，因为我们需要在尽量短的周期内对原有方案进行改善，以迎接新一期的业务高峰。这些限制不同于架构约束，它常常迫使我们在逼仄的空间中闪转腾挪。我们还必须尽快地实现方案的原型，并营造与真实业务场景相当的数据，对其进行压力测试和性能测试。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ThoughtWorks读书雷达-架构设计篇]]></title>
    <link href="http://agiledon.github.com/blog/2013/05/13/architecture-and-design-of-reading-radar/"/>
    <updated>2013-05-13T20:41:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/05/13/architecture-and-design-of-reading-radar</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2013/04/reading_radar_02.png">
编码的能力与设计的能力，二者均不可偏废。我们认为，编码事实上是设计的一部分，只不过它更多的是以代码的形式来呈现，而设计则主要由模型来组成。这种设计模型有助于知识的传递与分享，同时也可以有效地提高编码质量。至于架构，则是软件系统中重要的事物，它关乎的内容往往是难以更改的。卓越的软件设计一定拥有美的架构，也能够有助于促进架构的演化。在ThoughtWorks，并没有明确的架构师职位。如果有，我们也希望这个角色应该是Martin Folwer认为的Architectus Oryzus，这些架构师与处理最困难部分的其他开发人员合作，积极地向项目贡献代码。显然，我们认为架构师也是程序员。这正是我们要在这个读书雷达中列出Architecture &amp; Design象限的原因。</p>

<p>整体概览本象限列出的书籍，若有相关读书经验的人一定会注意到，这里列出的书籍并没有脱离面向对象设计体系的范畴。我们认为，在当今的企业级软件开发领域中，面向对象的思想体系仍然占据了主要的地位。对于程序员而言，建立面向对象的设计思维仍然至关重要。但是，我们从来都不曾忽略函数式语言对设计领域带来的冲击，以及它可能产生的巨大影响。在<a href="http://www.thoughtworks.com/insights">最新的ThoughtWorks Technology Radar</a>的Languages &amp; Frameworks象限中，ThoughtWorks对Scala，Clojure，F#等函数式语言青睐有加，同时也谈到了在Java中引入高阶函数等函数式特性的Functional Java发展趋势。我们也注意到在2012年的DDD eXchange会议上，函数式语言对设计范式的转变产生的影响。遗憾的是，除了少量介绍具体函数式语言的书籍，我们很少看到如面向对象设计一般专门讲解与深入探讨函数式软件设计的书籍。与其滥竽充数，不如抱残守缺。我们选择了在这期读书雷达图中，让函数式设计范式集体缺席。</p>

<p>架构内容包罗万象，在这个象限中我们关注的书籍主要与架构本质内容相关，包括架构风格、架构模式和重要的架构设计原则。虽然云计算、大数据以及REST服务等相关技术已经成为架构师的必备知识，也诞生了许多优秀的书籍；但我们还是希望让这个象限的内容变得更内聚一些，从而帮助读者能够从中挑选出合适的书籍，组成学习架构与设计技能的读书路线图。或许，在将来我们希望引入Tools、Frameworks以及Platforms等更多的象限来囊括这部分内容。</p>

<!--more-->


<p>在Architecture &amp; Design象限的基础篇中，我们仍然选择设计模式作为面向对象设计能力提高的突破口。因此，我们将浅显易懂的Head First Design Patterns《<a href="http://book.douban.com/subject/1488876/">深入浅出设计模式</a>》作为学习设计模式的入门书。图文并茂以及与生活有关的设计案例可以很容易启发读者的阅读理解，快速地掌握设计模式的精要。我们唯一担心的是这样一本充斥着玩具项目的入门书籍，可能很难让读者将自己学到的设计思想运用到真实项目中。因此，我们强烈推荐Robert Martin的经典著作Agile Software Development《<a href="http://book.douban.com/subject/1140457/">敏捷软件开发</a>》。该书很好地总结了面向对象设计的SOLID原则，在设计理论上做到了高屋建瓴；同时又给出了丰富的更加贴近真实项目的案例来分析设计模式。</p>

<p>我们必须列入GOF的Design Patterns《<a href="http://book.douban.com/subject/1052241/">设计模式</a>》，不仅仅是因为本书对整个设计领域的影响力，还因为本书讲到的设计理念与原则，至今读来，内涵的真知灼见仍然熠熠生辉。我强烈建议读者仔细研读本书的第一章，几乎每一句话都值得我们深思。即使你曾经读过，我仍然建议你再次阅读。本书第二章给出的案例实在太精妙了，仿佛一件艺术品，虽为人工雕刻，你却看不到斧凿的痕迹。如此浓缩的两章内容，抵得上许多讲述设计模式书籍的千言万语。当然，从今天的视角来看，GOF提出的一些设计模式如今已经变得不合时宜；然而我认为，在你没有真正理解设计模式之前，请先闭上质疑的眼光，收回批判的言辞。</p>

<p>在Medium的层级，我们开始将目光投向更高层次的架构模式，这其中尤以Martin Fowler的著作Patterns of Enterprise Application Architecture《<a href="http://book.douban.com/subject/1230559/">企业应用架构模式</a>》为代表。该书围绕着分层架构模式，根据不同层次呈现出的不同特征，提炼出了在企业开发中得到广泛使用的模式。可以认为这是Martin Fowler给出的企业应用开发的最佳实践，以模式的形式告诉你在不同的场景下，你应该选择何种设计方案。书中的多数模式已经如设计模式一般深入人心，在某种程度上甚至可以作为设计人员的交流术语。换言之，倘若你不曾掌握这些模式，或许会失去在许多场景下说话的资格。</p>

<p>Eric Raymond的The Art of UNIX Programming《<a href="http://book.douban.com/subject/1467587/">UNIX编程艺术</a>》则从艺术的角度剖析了UNIX的编程哲学，使得我们明白软件设计其实并没有阵营之分，即使是面向过程的语言，也能做出优雅的设计。而且，面向对象设计中所有精华的设计思想与原则，其实都可以从UNIX的编程哲学中找到，例如使用简洁的接口拼合简单的部件，清晰胜于机巧，策略同机制分离，设计追求简洁，健壮源于透明与简洁。愿本书能够开拓你的设计视野。</p>

<p>Jaroslav Tulach的Practical API Design《<a href="http://book.douban.com/subject/6003832/">软件框架设计的艺术</a>》则从框架的角度讨论了如何针对API进行实效主义的设计。这在一定程度上弥补了软件设计技术书籍在API设计方面的空白。本书对于API与SPI的讨论，对模块化设计的分析，尤其是来自于NetBeans框架产品版本演化的实践经验，都是非常重要的设计知识。</p>

<p>在Architecture &amp; Design象限中，放入Martin Fowler的Domain Specific Languages《<a href="http://book.douban.com/subject/21964984/">领域特定语言</a>》似乎有些突兀，或许它更应该放入Coding Practice象限。然而，我们认为掌握领域特定语言在一定程度上可以改进我们的设计，尤其是API的设计。无论是内部DSL还是外部DSL，必然会涉及到如何合理设计语言，这其中蕴含了精妙的设计思想。看看书中对状态机以DSL风格进行的分析，阐释各种解析表达式树的算法，讨论如何设计分离更有利于重用和测试，这其中又包括了对语义模型的提炼与分析。无疑，这是一本DSL的集大成之作，但如果我们仅仅将其范围局限在语言层面，你可能会错失对Martin Fowler深邃的设计思想领悟的机会。</p>

<p>入选Advanced层级的书籍除了Eric Evans的Domain Driven Design《<a href="http://book.douban.com/subject/1629512/">领域驱动设计</a>》，均与软件架构直接相关。我们尤其尊重《领域驱动设计》一书在设计领域的开创与先驱地位，它提出的以领域为核心，以建模为手段的设计方法学，为设计业务复杂的大型企业级软件提供了具有实践意义的方法体系，进而催生了领域驱动设计。书中提到的诸多概念包括Entity、Value Object、Repository、Aggregation、Bounded Context，已经成为了设计知识的专用术语。我们强烈推荐此书，是因为对于程序员而言，只要你逃避不了对业务领域的分析与建模，就不能绕过领域驱动设计。</p>

<p>以五卷本的系列著作来阐述软件架构模式，可见作者的宏伟决心以及对架构设计驾轻就熟的能力。我们认为，在模式领域里，以Frank Buschmann为主要贡献者的Pattern-Oriented Software Architecture《<a href="http://book.douban.com/subject/4848563/">面向模式的软件架构</a>》系列对软件设计领域带来的影响巨大而深远。这个系列虽然都是讲解架构模式，但各有其特色，关注点也有不同，分别涵盖了通用架构模式、并发模式、资源模式、分布式模式与模式语言。阅读这一系列确实需要读者下定一百万分的决心，若你不愿意通读，那么它也可以成为很不错的架构模式参考书籍。我们相信，你在软件设计中可能会遭遇的大多数设计场景，都能在本系列中找到对应的架构模式，从而作为设计方案的重要输入。</p>

<p>在Pattern-Oriented Software Architecture系列中，虽然介绍了分布式系统的架构模式，但关于系统集成包括消息处理等内容却显得不够深入和详尽，这是因为已有一本优秀著作专美于前，即Gregor Hohpe与Bobby Woolf的Enterprise Integation Patterns《<a href="http://book.douban.com/subject/1766652/">企业集成模式</a>》。本书关注企业级软件系统的本质问题，那就是集成。对于采用异步消息传递的集成方案，本书针对不同场景给出了不同的解决方案，并以模式的方式进行概述与归纳。倘若你在设计软件系统时，需要使用异步消息传递的方式对系统进行集成，本书可以成为你的最佳指南。</p>

<p>如果将《领域驱动设计》视为应对领域复杂性的解决之道，Michael Nygard的<a href="http://book.douban.com/subject/2065284/">Releast It!</a>则可以看做是处理软件系统质量属性的治病良方。本书常常会以一个具体的实例开始阐述某一个质量属性的关键性，并列出一系列的反模式作为参照和对比，最后再给出正确的模式列表。这种针对问题的叙事方法，使得读者往往能够照方抓药，又因为模式的叙述如此清晰而规范，所以常常能药到病除。正如本书书名所指，这些内容确乎与软件的发布息息相关。</p>

<p>最后一本推荐书籍看似有些大杂烩，实则是大家云集的架构师合唱团，可谓架构的盛宴，那就是Till Adam编著的Beatiful Architecture《<a href="http://book.douban.com/subject/4086029/">架构之美</a>》。全书涵盖的内容广博而宏大，涵盖了架构基本原则、企业级应用架构、系统架构、最终用户应用架构、语言与架构，分列为本书的五大部分，读之会让人产生目不暇接之感。尤其对于术有专攻的程序员来讲，要彻底吃透本书讲解的内容，无疑是一项艰巨的挑战。然而，如果从架构师所必须具备的技能来看，本书的内容其实并没有超出架构的范畴，因为架构师必须要见识广博，你才能针对不同的需求场景，面对不同的实现技术，选出最适合当前场景的恰如其分的架构方案。当然，在阅读时，千万不要在太多的技术细节中迷失自己，关键还是要把握美丽架构的基本原则。而这正是本书的主线，使得本书能够在散乱的主题中，还能做到“形散而神不散”。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Struts 1.x一路走好]]></title>
    <link href="http://agiledon.github.com/blog/2013/05/08/farewell-struts-1-dot-x/"/>
    <updated>2013-05-08T22:38:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/05/08/farewell-struts-1-dot-x</id>
    <content type="html"><![CDATA[<p>因为Struts 1.x宣布退出了历史舞台，于是InfoQ组织了一次虚拟访谈。恰好在我现在的项目中，仍然能够看到Struts 1.x的身影，以我这浅薄的Web开发经验，也能有幸被丁雪丰邀请参加了这次虚拟访谈，和李锟、张龙就这一事件畅谈了各自的感受和想法。这篇<a href="http://www.infoq.com/cn/articles/virtual-panel-struts1?utm_source=infoq&amp;utm_medium=popular_links_homepage">虚拟访谈</a>发表在了InfoQ上。这里发布的则是我自己就主持人提出的问题给出的回答。</p>

<p><strong>1. Struts是最早的MVC框架之一，影响了很多人，你是否还记得最早接触到它时，给你留下的印象是什么？</strong></p>

<p><strong>张逸：</strong>从业15年来，我主要参与的开发工作除了早期的Windows Form应用开发外，主要还是集中在后端。用分层的角度来说，即工作在数据层、领域层以及服务层。虽然早已知道Struts的大名，甚至了解到所谓Struts+Spring+Hibernate几乎成为了Java企业开发的标配，却一直没有机会使用Struts。我当时工作的项目主要还是在微软的.NET平台上，经历了从ASP到ASP.NET，再到ASP.NET MVC的过程。在使用ASP时，我很质疑那种业务代码与表现代码混杂在一起的开发方式；而在最初拥抱ASP.NET时，我认为这种Code-Behind会是一种良好的职责分离。然而，ASP.NET在灵活性或扩展性方面带来的约束，使得它越来越不适合富客户端的开发了。于是，才有了借鉴Ruby On Rails思想的ASP.NET MVC出现。或许我的回答偏题了，但我想借ASP的这种发展来看待此次Struts 1.x退出历史舞台的事件，那就是任何产品都会步入晚年的衰落期，跟不上技术的发展，必然会被淘汰，没有什么好奇怪的。</p>

<!--more-->


<p><strong>2. Struts 1.x即将走完最后的历程，对于那些仍在使用它的系统，你有什么建议？如果要升级，有几个备选方案，例如Struts 2.x、Spring MVC等等，你会如何选择？</strong></p>

<p><strong>张逸：</strong>奇怪的是，虽然在早期我不曾有机会使用Struts 1.x，然而我现在正在工作的一个大型项目，因为其漫长的历史，一部分Web前端使用的正好是Struts 1.x。对于这种正在使用它的系统，若要说有何建议，简言之，还是需要在决策时视情况而定。在我们当前项目的一个子系统中，Struts 1.x是与Spring MVC 2.0共存的；而在另一个子系统中，又存在Struts 2.x与Spring MVC 3.x共存的情况。从架构的一致性来看，这是很不合理的；然而就项目的真实情况，我又认为这种现象未尝不可。迁移的成本往往是昂贵的，尤其对于遗留系统而言，若没有覆盖率极高的验收测试，盲目地为了追求架构一致性进行迁移，反而会引入新的问题。这就需要权衡迁移的成本和迁移得到的好处。在Java平台下，可供选择的成熟Web框架并不多，Struts 2.x以及Spring MVC相较于Struts 1.x而言，主要还是体现在模式上的区别，属于侵入性更小、架构更为简单的框架。相对于升级，我更倾向于保留原有框架，对于新增的功能则可以引入更新的框架。若因为种种原因硬要升级，我更倾向于选择Spring MVC，一方面它与Spring框架的集成度更好，学习曲线低；同时它对于Struts 1.x实现方式的固有支持，会使得迁移的成本会降低。最重要的一点是Spring MVC目前还保有一定程度的活力，它的版本还在演化中；相对而言，Struts似乎已经失去活力了。</p>

<p>若抛开这些成熟的Web框架不谈，我的建议是不妨试试Java平台下的其他框架，例如jRails，Spring Roo、Apach Wicket或者Play。若想继续工作在Spring的技术栈下，Spring Roo会是一个有趣的选择。事实上，你可以认为它是Spring所要力推的下一代Web框架，如果你不想重蹈Struts 1.x的覆辙，可以在决策时冒着风险给予提前尝鲜的机会。Play框架是基于Java和Scala开发的Web框架，它似乎更偏重于建造可伸缩性的Web框架。此外，它的安全模块、持久化支持(包括对NoSQL与Big Data的支持)、RESTful以及Mobile的支持，使得它更适合开发当今的Web应用程序。</p>

<p><strong>3. 经常会有框架或软件结束生命周期，不再进行维护，这对使用它的用户多多少少带来了一些困扰，能否聊聊您在项目最初进行选择时的一些经验之谈。</strong></p>

<p><strong>张逸：</strong>对于框架的选择，我比较偏重于框架的简单性和无侵入性这两个特点。简单性可以保证我们快速地理解框架的架构，并能够正确地使用它；无侵入性则使得我们可以避免所谓“供应商锁定”的反模式，在需要迁移框架时，可以尽快摆脱原有框架的约束。当然，这种选择总要结合项目需求，根据风险对各种质量属性进行综合权衡，方能做出合理的设计决策。因此，我会将这两个特点看做是重要的衡量指标，但并非绝对。在一定程度上，我们还可以通过更好的架构设计来规避对框架的依赖，例如通过好的分层设计，或者引入防腐层隔离对框架的依赖。以Struts 1.x而言，只要我们避免在Action中引入业务逻辑，选用新Web框架的成本就会更低一些。同时，保证足够的测试覆盖率是必要的，尤其是足够覆盖率的单元测试与集成测试，它常常可以放缓系统衰老的脚步。对于旧系统的维护或重构而言，测试覆盖率是进行改造的良好基石。</p>

<p><strong>4. 随着像Backbone.js这样的前端MVC框架的流行，Struts这样的服务器端MVC的作用似乎有所减弱，您觉得MVC逻辑“前移”会是今后的发展趋势么？</strong></p>

<p><strong>张逸：</strong>我完全赞同这一点。在我参与的上一个项目中，对于服务端的Web层而言，几乎就成为了一个Controller+JSON+REST的组合，MVC中的M被JSON或资源所替代，V则干脆消失了，由Controller来负责必要的服务端验证，并完成HTTP请求的路由功能，其余的前端逻辑都交由我们当初选择的ExtJS了。</p>

<p>这种设计是完全合理的。但我仍然要说明一点的是，这种设计由于加大了前端的复杂度，因而需要我们更加关注前端的代码质量。传统开发要求的关注点分离、松耦合与高内聚原则同样适用于这样的前端代码。虽然不一定要提倡前端代码的测试驱动开发，但至少要保证这些代码具有足够的测试覆盖率。例如，我们可以为Javascript（或者jQuery)引入Jasmine，QUnit等测试框架。在我的同事曾经参与的一个项目中，由最初只支持一个品牌，增强到支持多个品牌的需求变化，这其中需要涉及到对大量前端代码的复用。由于之前的设计并未考虑到多品牌的支持，因而需要重构前端代码，以达成复用的目的。如果没有足够的测试覆盖率，以及良好的职责分离，要做到这一点的难度不言而喻。</p>

<p>我还提到，前端的许多模式事实上都是从MVC模式衍生而来，例如MVP，MVVM等。此时，MVC可以作为核心模式的一个名词。应该为那些变种的模式命名，并给出最佳实践，从而表达特定的含义。对于这种服务端与客户端结合起来共同协作的模式，可以命名为MC2MVC，或者RC2MVC。有个“2”，就表示从服务端到客户端的意思。至于RC2MVC，则是为了强调服务端提供的“资源”，而非传统意义上的模型。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从Go语言的设计学习设计决策]]></title>
    <link href="http://agiledon.github.com/blog/2013/05/04/design-decision-learning-from-go/"/>
    <updated>2013-05-04T21:12:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/05/04/design-decision-learning-from-go</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2013/05/decision.jpg">
阅读了Rob Pike撰写的《<a href="http://www.oschina.net/translate/go-at-google-language-design-in-the-service-of-software-engineering">Go在谷歌：以软件工程为目的的语言设计</a>》，颇多感触。这些感触并不在于语言层面，或者Go这门语言的语法以及底层实现；而是因为语言设计者们在设计Go这门语言时，做出设计决策的合理性以及基于的事实与根据。正如此文标题所言，显然，Go的创造者们从一开始就树立了准确的愿景与目标，并且清晰地确定了该语言的适用场景，即它需要解决“由多核处理器、系统的网络化、大规模计算机集群和Web编程模型带来的编程问题”，这是理解这门语言，进而明确其设计意图的最根本所在。</p>

<p>刚刚参加了公司八叉大神组织的轮子大赛，我们写了一个轻量级的IoC容器<a href="https://github.com/agiledon/melt">Melt</a>。就这个容器或者说框架本身，和八叉讨论了框架设计的特点。他提到“framework开发和功能开发的一个最大分别就在于，你需要规定在这个framework里那些是支持的，哪些是不支持的。这条线要你自己来划，或者说你的framework要有态度。”这是我非常认同的观点。Framework要有态度，这意味着你在践行并且在引导一种最佳实践。或者我们可以理解为这是一种架构的约束。我们都知道，在软件设计中，如果没有任何约束，带来的问题反而会更大。约束是一种驱动力，例如我们需要可伸缩性的约束，就需要我们设计的服务不应该是有状态的。框架的态度大意如此。</p>

<p>回过头来看这篇文章介绍的Go设计理念，无时无刻不是在体现设计者施加在这门语言身上的态度。必须注意，这种态度或者说设计理念又绝对离不开这门语言的设计愿景。若是脱离这种具体场景来看Go语言，或许有众多不合理之处，但我们并不能依此妄加论断。正如话剧演员在舞台上的表演，总带着几分略带夸张的表情与语气，我们却不能指责这种表演不够生活化。当我们在思考一个设计决策是否合理时，是否参考了当时的场景做出判断呢？进一步讲，当我们自己在进行设计决策时，又是否充分地考虑了具体的场景呢？例如，Go语言之所以采用C语言风格的花括号，其考量并非简单地延续C语言风格那么简单，在前面提及的愿景的大前提下，设计者必须考虑如果使用Python或Haskell风格的空格缩进，对于大规模程序而言，可能会造成太多的问题。如文中所云：“我们的观点是，虽然空格缩进对于小规模的程序来说非常适用，但对大点的程序可不尽然，而且程序规模越大、代码库中的代码语言种类越多，空格缩进造成的问题就会越多。为了安全可靠，舍弃这点便利还是更好一点，因此Go采用了花括号表示的语句块。”</p>

<!--more-->


<p>再看Go语言的依赖处理，它施加了一个看似比较独裁的约束，即“不允许其依赖图中有循环性的包含关系，编译器和链接器都会对此进行检查以确保不存在循环依赖”。设计者并不否认循环依赖存在一定的价值，然而在大规模程序的前提下，它带来的问题远远超过了可能存在的价值。文中提到：</p>

<blockquote><p>循环依赖要求编译器同时处理大量源文件，从而会减慢增量式build的速度。更重要的是，如果允许循环依赖，我们的经验告诉我们，这种依赖最后会形成大片互相纠缠不清的源代码树，从而让树中各部分也变得很大，难以进行独立管理，最后二进制文件会膨胀，使得软件开发中的初始化、测试、重构、发布以及其它一些任务变得过于复杂。</p><p>不支持循环import偶尔会让人感到苦恼，但却能让依赖树保持清晰明了，对package的清晰划分也提了个更高的要求。就象Go中其它许多设计决策一样，这会迫使程序员早早地就对一些大规模程序里的问题提前进行思考（在这种情况下，指的是package的边界），而这些问题一旦留给以后解决往往就会永远得不到满意的解决。</p></blockquote>


<p>显然，Go语言的设计者并不是要设计一门大而全，兼容并包的全能语言，它严格而合理地压制着设计时可能膨胀的欲望，不与设计愿景相悖，并时刻从工程学的角度看待设计。设计一门语言如此，开发一个产品或项目更应如此。例如对于产品而言，当下流行的Lean Startup对于产品的理念，正是这种实效的工程主义。MVP（最小可验证产品）的划分将精简与避免浪费做到了极致，严格避免功能盲目的扩大化。</p>

<p>Rob Pike还提到：“在依赖关系方面保持良好状况要比代码重用重要”，甚至支持“为了使用一个函数，把所需的那一小段代码拷贝过来要比拉进来一个比较大的库强”。虽然我们在设计与开发时，常常会严格遵循DRY原则，同时也尽可能地追求重用，因为我们知道重复其实是一种“恶”。若要最大限度地重用，就必须保证实体的细粒度。从类级别来讲，粒度越细，就意味着类的数量越多，这可能会加大系统的复杂度。Kent Beck提出的简单设计中，第四条即为保证类的数量尽可能少。整体结合来看，实质是指在没有看到重用以及变化的征兆前，应尽可能避免类的数量被无谓地扩大。熊节将其概述为“如无必要，勿增实体”，非常准确。显然，细粒度的类虽然可以在重用上带来好处，但却可能使得系统变得更复杂。细粒度的类还在可控制的范畴，因为我们可以采用一些方式例如Facade或Mediator模式来简化或隐藏多个细小类之间的协作。然而，对于模块（指物理模块）层面来讲，粒度过细的模块会导致对依赖的管理变得复杂。我曾经在一个.NET项目中看到过多达100多个程序集，若尝试在Visual Studio中为其生成依赖图，可能会耗尽内存。而且这些细粒度的程序集，也会导致本地构建时间的增长。关于.NET项目中依赖管理的问题，Patrick Smaccla的文章《<a href="http://www.infoq.com/cn/articles/NDepend">避免在.NET代码中出现不恰当依赖</a>》有详细论述。然而，若是不能保证模块的细粒度，根据Robert Martin提出的共同复用原则，则可能导致即使是对一个细小功能的重用，也需要引入对整个包的依赖。</p>

<p>看来，我们有必要正视依赖与重用之间存在的鱼与熊掌不可兼得的问题。我的意见是当出现此类问题时，我们可以考虑职责分配上是否出现问题。如果模块的分解遵循了“高内聚”原则，可能此类依赖就只会发生在模块的内部。另一种思路是考虑我提出的所谓“依赖的沉淀”，即随时绘制组件图或包图，清晰地标明依赖的关系和方向，并根据权值来判断该模块应该位于纵向的物理分布层级的哪一层。具体细节可参考我写的一篇文章《<a href="http://agiledon.github.io/blog/2013/03/03/assigning-responsibility-between-modules/">模块间的职责分配</a>》。</p>

<p>文中还提到了Go语言故意缺失的一个特性就是不支持缺省参数。设计者认为：</p>

<blockquote><p>缺省参数太容易通过添加更多的参数来给API设计缺陷打补丁，进而导致太多使程序难以理清深圳费解的交互参数。默认参数的缺失要求更多的函数或方法被定义，因为一个函数不能控制整个接口，但这使得一个API更清晰易懂。哪些函数也都需要独立的名字， 使程序更清楚存在哪些组合，同时也鼓励更多地考虑命名&#8211;一个有关清晰性和可读性的关键因素。</p></blockquote>


<p>姑且不谈这一设计的驱动因素是否可取，这里显然教会了我们在软件设计时应该懂得如何去权衡。权衡的能力是架构师必备的技能，就好像老婆和老妈同时落水了，你该去救哪一个，这个命题总是让人不舒服，因而不肯回答。说来简单，在进行设计决策时，如果要权衡多个指标，一定要以最重要的哪个指标为主。问题是当我们不知道哪个指标更重要时，应该怎么办？我想，答案还是应该从愿景中去寻找。根据Go语言的愿景，对于大规模程序而言，清晰易懂的API会降低维护成本，并在一定程度上保障软件的质量，这显然比API的兼容性更为重要。</p>

<p>Go语言对于可见性的设计非常漂亮，“名字自己包含了可见性的信息，而不是使用常见的private,public等关键字来标识可见性：标识符首字母的大小写决定了可见性。如果首字母是大写字母，这个标识符是exported(public); 否则是私有的。”最初看来，这样的约定非常怪异，可是仔细琢磨，你不觉得通过这样一个简单的约定，让程序一下子变得精简了许多吗？其实只要明确了这一约定，代码的可见性仍然是清晰可知的。从某种程度讲，甚至比显式地声明public或private更加清晰。</p>

<p>Go语言对于继承的处理也显得特立独行，因为在Go语言中，没有类型层级（type hierarchy）的概念。它选择了组合而非继承，在于它对继承滥用表达了足够的忧虑和担心。作者认为：“类型层次结构这种模型会促成早期的过度设计，因为程序员要尽力对软件可能需要的各种可能的用法进行预测，不断地为了避免挂一漏万，不断的增加类型和抽象的层次。这种做法有点颠倒了，系统各个部分之间交互的方式本应该随着系统的发展而做出相应的改变，而不应该在一开始就固定下来。”我对此持保留意见，但在支持接口的前提下，这种规避继承的做法，仍有可取之处。因为接口可以支持OO中多态的特性，而组合又能保证逻辑的重用。这意味着，继承给我们带来的好处已经找到了合理的替代品。</p>

<p>Go抛弃了大多数传统语言所支持的异常机制，而转而使用error。这种机制建立在一个前提，即Go语言支持多个返回值。倘若像Java、C#等多数语言那样，仅支持一个返回值，则异常机制就变得完全有必要了。鉴于对多返回值的支持，且Go中的error又是抽象的接口类型，这样的设计就变得合乎情理了。</p>

<p>我们注意到Go语言中一些与众不同的特征，其实皆为设计者设计理念的体现，从中我们可以看到设计者做出设计决策的依据。显然，这些决策皆围绕着最高的设计愿景，并结合实际的工程场景，在通过合理权衡的前提下做出的。这种决策之道，值得软件架构师与设计师借鉴。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ThoughtWorks读书雷达-编码实践篇]]></title>
    <link href="http://agiledon.github.com/blog/2013/04/27/coding-practice-of-reading-radar/"/>
    <updated>2013-04-27T16:03:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/04/27/coding-practice-of-reading-radar</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2013/04/reading_radar_01.png">
期望通过四分之一的读书雷达图就能将与编码实践有关的优秀书籍一网打尽，自然是不现实的打算。因此，我们希望就我们的侧重点来推荐书籍。对于编码实践而言，我们共同认为培养良好的编码习惯，编写整洁简单而又合理的代码，是一名好程序员的基本要求。因此，这里我们更强调与程序员基本编码技能相关的知识。我们并没有给出与算法直接有关的书籍，虽然我们认为算法知识同样属于编码实践的范畴，虽然我们认为诸如《计算机程序设计的艺术》、《编程珠玑》、《算法导论》之类的书籍同样很重要很优秀；然而，我们取舍再三，仍然将它们划出了读书雷达的范围。我们认为：算法知识更应该划定到大学教育的范畴，若工作需要，则又偏向于更为专精的领域，并不适合读书雷达这种普适性的推荐。相对于具体的算法，或许我们更看重程序员的逻辑思维以及抽象建模的能力。</p>

<p>在Coding Practice象限的Fundamental圈中，我们强烈推荐了Robert Martin的Clean Code《<a href="http://book.douban.com/subject/4199741/">代码整洁之道</a>》与<a href="http://book.douban.com/subject/6114900/">The Clean Coder</a>《<a href="http://book.douban.com/subject/11614538/">程序员的职业素养</a>》，以及Martin Fowler的Refactoring《<a href="http://book.douban.com/subject/4262627/">重构：改善既有代码的设计</a>》。我不知道有多少人是阅读了Clean Code之后，才开始自己的整洁代码之旅；至少在我身边，这样的例子不胜枚举。把代码写成像散文那样美好，不仅仅是对美学的追求，更重要的是它能够极大地降低维护成本。在某种程度上讲，代码可以说是软件系统的质量基石。虽然重构的重要性被一直不断地提起，但我们发现真正掌握了重构手法的程序员，仍然屈指可数。通过对Refactoring一书的阅读，弄清楚什么是代码的坏味道，继而运用正确的重构手法，就能保证代码足够的整洁，甚至优雅。Robert Martin的另一本书Clean Coder与Clean Code一字之差，内容却大相径庭。它更多地是对程序员自身修养的关注。我们之所以强烈推荐它，并将其放入Fundamental圈中，是因为它介绍的知识，能够有效地帮助新入职场的程序员从一开始就能建立良好的编码习惯与意识。我们认为，这种好的习惯与意识，甚至比掌握某种开发技能显得更为重要。</p>

<!--more-->


<p>我们仍然要推荐Kent Beck的Test-Driven Development By Example《<a href="http://book.douban.com/subject/1230036/">测试驱动开发</a>》以及Andy Hunt的Pragmatic Unit Testing《<a href="http://book.douban.com/subject/1239651/">单元测试之道</a>》，固然源于我们对测试驱动开发以及提高单元测试覆盖率抱有强烈的热忱，还在于我们认为目前中国软件开发的现状，测试不足仍然是普遍现象。姑且不谈测试驱动开发的优劣，至少我们认为这种测试驱动的理念对于提高开发与设计质量颇有可观之处。我们也看到了太多测试不足的遗留系统，在希望通过重构来改善结构时的举步维艰。我们还选择了Neal Ford的著作The Productive Programmer《<a href="http://book.douban.com/subject/3558788/">卓有成效的程序员</a>》，它与Robert Martin的The Clean Coder颇有相似之处。我们喜欢本书的理由在于，如果我们能践行该书提到的方法与理念，确乎能够提高我们的开发效率，成为一名高效的程序员。我们一直认为中国的读者低估了本书的重要性，是因为该书涵盖的理念，其实可以扩充为好几本高文厚册。对于书中提到的设计原则，我们不是了解得太多，而是太少。选入Dustin Boswell等人的著作The Art of Readable Code《<a href="http://book.douban.com/subject/10797189/">编写可读代码的艺术</a>》，主要因为该书讨论的可读性代码，包含了Clean Code没有涉及的其他语言，例如C++、PHP、Javascript。要写出可读性良好的代码，了解多种语言是有必要的，且不同语言的编码风格总有不同之处。</p>

<p>对于Medium层次的程序员而言，我们希望能开拓程序员的眼界，至少要将编码实践的技能纳入到整个软件开发生命周期中。因此，我们推荐了David Thomas与Andy Hunt的著作The Pragmatic Programmer《<a href="http://book.douban.com/subject/1152111/">程序员修炼之道</a>》以及Steve McConnell的著作Code Complete《<a href="http://book.douban.com/subject/1477390/">代码大全</a>》。这两本书都获得了广泛的赞誉，前者是对程序员综合技能的整体梳理，后者则是对软件开发过程的高度提炼。The Pragmatic Programmer一书既有战略层面的思想与决策，又有战术层面的技巧与招式。整体而言，它提供了程序员修炼的法则，努力遵循这些法则，你就有机会成为编程专家。Code Complet则为我们展示了一幅巨细无靡的软件开发画面，牵涉到了架构、设计、编码、测试、构建等诸多内容，内容全面但并不肤浅。唯一不足之处在于，它实在太厚了。</p>

<p>Kent Beck的Implementation Patterns《<a href="http://book.douban.com/subject/3324516/">实现模式</a>》提到的模式，似乎更近于惯用法与设计模式之间。Kent Beck是真正将Java与设计精髓吃透，并能编写出好代码的大师，他的著作总是显得那么睿智而又简练，内容直指本质，没有多余的废话。我们要强烈推荐本书的理由只是因为它的内容太精彩了，尤其对于Java程序员而言，你需要再三阅读。我们还将Joshua Kerievsky的Refactoring to Patterns《<a href="http://book.douban.com/subject/1917706/">重构与模式</a>》放到了这个象限，是因为我们更愿意从编码以及重构的角度去看待设计。本书填补了Martin Fowler著作的空白，书中介绍的重构手法与设计理念，可以帮助我们更好地理解何谓“简单设计”，时刻警惕“过度设计”的陷阱。</p>

<p>我们之所以将Michael Feathers的著作Working Effectively with Legacy Code《<a href="http://book.douban.com/subject/2248759/">修改代码的艺术</a>》放到Coding Practice的Advanced圈中，是因为我们充分考虑了遗留代码的复杂性。面对这种复杂性，不能仅仅靠纸上谈兵的方式，寄希望于书中介绍的手法就能处理这些纠缠不清的糟糕代码。因此，我们认为阅读本书的前提是具有相当的处理遗留代码的经验，至少曾经经历过那种无从下手的茫然。当然，我们也不能狭隘地根据书名得出结论，认为这本书专为遗留代码服务。书中介绍的诸多解除依赖的技术，事实上也可以作为通用的设计手法。</p>

<p>在Coding Practice象限中，我们唯一推荐了一本似乎与工程实践无直接关联的书籍，即Harold Abelson与Gerald Jay Sussman的著作Structure and Interpretation of Computer Programs《<a href="http://book.douban.com/subject/1148282/">计算机程序的构造和解释</a>》(即SICP)。作为MIT（曾经的）计算机系第一门编程课的教材，这本书没有像诸多基于C或者Java的编程入门教材那样纠结于语法和库——LISP的语法确实也没什么可以纠结的。本书讲的是一些最基本的问题，比如什么是计算、什么是抽象、什么是模块化、乃至什么是时间和什么是自然数。一个以软件开发为业的程序员，或早或晚终归要想透这些问题，然后才能看破各种琳琅满目的编程语言所提供的五花八门的语法糖，以不变应万变地坦然面对一切不涉及并发的程序设计问题。把这本书当做第一本编程教材或许有些激进（MIT也已经不再这样做），但你早晚会遇到它。有人不无夸张但相当在理地说：自SICP以降，【无并发的】编程没有任何新鲜问题；如果你觉得自己有了新发现，要么是SICP已经写过只是你不知道，要么是你想错了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[遗留系统的技术栈迁移]]></title>
    <link href="http://agiledon.github.com/blog/2013/04/24/technical-stack-migration-for-legacy-system/"/>
    <updated>2013-04-24T17:55:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/04/24/technical-stack-migration-for-legacy-system</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2013/04/legacy.png">
什么是遗留系统（Legacy System）？根据维基百科的定义，遗留系统是一种旧的方法、旧的技术、旧的计算机系统或应用程序[1]。这一定义事实上并没有很好地揭露遗留系统的本质。我认为，遗留系统首先是一个还在运行和使用，但已步入软件生命周期衰老期的软件系统。它符合所谓的“奶牛规则”：奶牛逐渐衰老，最终无奶可挤；然而与此同时，饲养成本却在上升。这意味着遗留系统会逐渐随着时间的推移，不断地增加维护成本。</p>

<p>维护一个软件系统，就需要了解该软件系统的知识。若知识缺失，就意味着这会给维护人员带来极大的障碍和困难。从这个角度讲，所谓“遗留系统”，就是缺少了一部分重要知识，使得维护人员“知其然而不知其所以然”的软件系统。</p>

<p>若要让遗留系统焕发青春，最彻底的做法自然是推倒重来，但这样付出的代价太高；而且，即使对系统重新设计和开发，仍然免不了会重蹈遗留系统的覆辙。或者，可以对遗留系统进行重构，在不修改系统功能的情况下改善系统设计。只是这种重构常常是对系统进行重大扩展或修改的前奏，如无绝对必要，并不推荐这种偿还“技术债务（Technical Debt）”的方式。重构应与开发同时进行，而不应将其作为债务推迟到最后，以至于支付高昂的利息。最后，还有一种方式，则是对遗留系统进行技术栈迁移。<!--more--></p>

<h3>一. 决策技术栈迁移的因素</h3>

<p>那么，为何要进行技术栈迁移呢？是否是原有技术无法满足新的业务需求？对于遗留系统而言，这种情况总是存在，即需要扩展旧有系统的功能来满足新的业务。然而，这一原因并不足以支持做出技术栈迁移的决策。因为，从技术实现的角度来看，无论采取何种技术，都可以实现各种业务功能，无非是付出的成本不同而已 。基本上，这种成本一定会低于技术栈迁移的成本。此外，当今的软件开发，常常会将一个软件系统看做是完整的生态系统，在这个生态系统圈中，完全允许有多种技术平台（包括多种语言，甚至多种数据库范式）存在，只要我们能够合理地划定各个功能（或服务）的边界。</p>

<p>牵涉到架构中的任何一个重大决策，都需要综合考量和权衡，只有充分地识别了风险，才能制订有效的设计决策。个人认为，只有在如下几种情形出现时，才值得进行技术栈迁移。</p>

<h4>原有技术不能保证新的质量需求</h4>

<p>在一个系统的完整生命周期内，系统从诞生到发展，衰老和死亡，与人一样，是不可规避的过程。对遗留系统进行技术栈迁移，无非是希望通过新的技术给旧有系统注入活力，就像器官移植一般，对腐朽的部分进行切除与替换。系统之所以会衰老，会腐朽，原因还在于需求的变化，从而导致系统结构变得庞大而混乱。我们在进行技术决策时，常常是根据当下的需求以及目前现有的技术，结合团队技术能力做出的最符合当时场景的合理决策。因而，技术栈迁移的原因常常是是因为“此一时彼一时”。在当时场景下做出的明智决策，随着时间的推移，会显得不合时宜。这一点在质量需求的满足上，体现得尤为明显。例如，系统对可伸缩性、性能、安全的要求，都可能因为新的质量需求的提出发生变化。而这些质量属性往往靠旧有技术无法解决。RackSpace对日志处理的案例就属于这一场景[2] 。RackSpace的架构对日志的支持，先后经历了三个大版本的演化，从文件服务器到中心数据库，再到MapReduce，每次技术栈的迁移都是质量属性的驱动，不得不为之。</p>

<h4>出于战略的考虑</h4>

<p>这常常是因为企业架构的因素。对于一个企业而言，应该将其IT系统看作是一个整体的生态系统。对于一个正在成长中的企业而言，必然会随着整个企业组织结构、业务体系的变化而影响到IT系统。一般而言，企业IT系统的架构会存在两种情况。第一种情况是从无到有，根据企业架构师与业务架构师的设计，严格按照设计蓝图来规划所有的IT系统。第二种情况则可能是多种不同的系统并存（可能是因为企业采用了并购等方式兼并其他公司业务，也可能是因为不同的业务需要，购买了不同的软件系统）。第一种情况看似美好，但仍有可能发生规划蓝图不能满足需求的可能。第二种情况则处于龙蛇混杂的局面，最后可能导致所谓的“烟囱系统（Stovepipe System）[3]”，需要花大力气对各种系统进行整合。</p>

<p>无论是哪一种情况，一旦做出技术栈迁移的决定，都必然是企业战略上的考虑。当然这种战略指的是IT战略，也可能是企业的整体战略对IT系统产生影响。</p>

<p>我们的一个客户是一家大型的金融企业，提供了多种品牌的保险与银行业务。企业的战略目标是在体现品牌价值的同时，整体展现企业的平台作用。这对于IT系统而言，就意味着需要对各种业务系统进行整合、迁移。整个系统的主要核心是对客户数据的管理，这些数据的管理会影响到整个企业的服务质量、市场推广与产品维护。由于该企业在银行业与保险业的发展壮大，是通过不断的合并与兼并来促进自身的发展。因而在其IT系统中，事实上存在多种不同的系统。客户信息散落在不同系统的数据库中。客户数据的整合，不仅有利于对这些信息的管理，保证数据的一致性，还在于从市场营销角度考虑，可以通过一致的客户信息对客户的情况做出全面了解，制定更好的推广策略。</p>

<h4>原有的技术提供者不再提供支持</h4>

<p>这种情形最是无奈，却时有发生。一种情况是使用的技术（平台、框架）不再被供应商维护，这一点体现在开源项目上更为明显。另一种情况则是所选的技术平台进行了升级，却没有很好地提供向前兼容，使得系统难以随之而升级。在架构设计中，这种绑定具体平台与技术的做法，实际上是反模式的一种，即“供应商锁定（Vendor Lock-In）[4]”。</p>

<h4>使用旧有技术的成本太高</h4>

<p>IT技术并非一定是新技术成本高于旧技术，事实上，随着技术的创新和发展，技术越新，成本越能得到更好的控制。当新旧技术的成本之差，远远高于技术栈迁移的成本，就值得做出迁移的决策了。例如，我们的一个项目需要处理的遗留系统，使用了某软件公司的产品，该产品必须运行在大型服务器上。该产品主要提供客户信息的处理。这是一个存在超过十年以上的产品，之后加入的子系统并未再使用该产品。如今，该产品所支持的客户数量并不多，而每年的产品许可费用以及大型服务器的维护成本都非常高。最后，我们对该产品提供的功能进行了迁移，以渐进地方式逐渐替换了该产品，降低了系统成本。</p>

<h3>二. 引入风险驱动模型</h3>

<p>George Fairbanks提出的风险驱动模型（Risk-Driven Model）非常适合遗留系统的技术栈迁移。所谓“风险驱动模型”，就是通过识别风险，对风险排定优先级；然后根据风险选定相关技术，再对风险是否得到缓解进行评估的一种架构方法[5] 。在对遗留系统进行技术栈迁移时，如果未能事先对迁移过程的风险进行有效识别，就可能为系统引入新的问题，降低系统质量，或者导致迁移的成本过高。</p>

<p>根据我的经验，在对遗留系统进行技术栈迁移时，可以识别的主要风险包括：</p>

<blockquote><p>遗留系统本身存在的质量问题，例如紧耦合、缺乏足够的测试、系统可维护性差；<br/>缺乏足够的知识来帮助我们理解整个遗留系统；<br/>成本、时间与人力的风险；<br/>对迁移的新技术缺乏充分认识；<br/>迁移能力的不足</p></blockquote>


<h3>三. 选择缓解风险的技术</h3>

<p>一旦识别出迁移过程中可能存在的风险，我们就可以有的放矢地选择相关技术，制订降低风险的解决方案。</p>

<h4>寻找丢失的知识</h4>

<p>只有体验过去，才能谋划未来。如果缺乏对遗留系统的足够认识，这种技术栈的迁移就很难取得成功。通常来讲，一个软件系统的知识，主要体现在如下三个方面，如下图所示：
<img class="center" src="http://agiledon.github.com/images/2013/04/legacy_01.png"></p>

<p>在这三个方面中，团队成员拥有的知识无疑是最值得寄予厚望的。在迁移过程中，若有了解该系统的团队成员参与，无疑可以做到事半功倍。可惜，这部分知识又是最为脆弱的，它就好似存储在内存中的数据一般，一旦断电就会全盘丢失。遗留系统的问题恰在于此，由于系统过于陈旧，而人员的流动总是比较频繁，在对系统进行迁移时，可能许多当年参与系统开发的成员，已经很难找到。</p>

<p>缺乏团队成员在知识方面的传承，就只能寄希望于文档与代码。文档的问题有目共睹，无论采用多么严谨的文档管理办法，文档与真实的实现总是存在偏差。正如“尽信书不如无书”，文档可以提供参考价值，但绝对不能完全依赖于文档。毫无疑问，代码是最为真实的知识。它不会说谎，但却过于沉迷于细节，要通过代码来了解遗留系统的知识，一方面耗时耗力，另一方面也难免会产生“只见树木不见森林”之叹。</p>

<p>引入自说明的可运行文档，可以有效地将文档与代码结合起来。通过运用业务语言编写功能场景来体现业务需求，完成文档的撰写；同时，它又是可以运行的代码，通过直接调用代码实现，可以完全真实地验证功能是否准确。目前，有许多框架和工具可以支持这种规格文档，例如Java平台下的<a href="http://jbehave.org/">jBehave</a>，Ruby语言编写的<a href="http://cukes.info/">Cucumber</a>，支持HTML格式的<a href="http://www.concordion.org/">Concordion</a>，以及ThoughtWorks的产品<a href="http://www.thoughtworks-studios.com/twist-agile-testing">Twist</a>[6]。</p>

<p>在我们的一个项目中，需要完成系统从WebLogic到JBoss的技术栈迁移。该系统是一个长达十年以上时间的遗留系统。虽然有比较完整的文档说明，但许多具体的业务对于我们而言，还是像一个黑盒，不知道具体的交互行为。此时，我们和客户一起为其建立了一个专门的项目，通过运用jBehave为该系统的业务行为编写可以运行的Story。在编写Story时，我们参考了系统的文档，并根据文档描述的功能建立场景，确定输入和输出，判断系统的行为是否与文档描述一致。事实上，我们在编写Story的过程中，确曾发现系统的真实行为与文档描述不一致的地方。这时，我们会判断这种不一致究竟是缺陷，还是期待的真实行为。在编写Story的过程中，我们寻找回了已经丢失的知识，并进一步熟悉了系统的结构，了解到系统组件的功能以及组件之间的关系。通过这些不断完善的Story，我们逐渐建立起了一个完全反应了真实实现的可运行文档库，它甚至可以取代原来的文档，成为系统的重要知识。</p>

<h4>及时验证，快速反馈</h4>

<p>在对系统进行技术栈迁移时，我们常常会担心修改会破坏原有的功能。尤其是对于大多数遗留系统，普遍存在测试不足，代码紧耦合，可维护性差的特点。虽然遗留系统会因为这些缺点而受人诟病，但不可否认的是，这些遗留系统毕竟经历了长时间的考验，在功能的正确性上已经得到了充分的验证。在迁移到新的技术时，如果不慎破坏了原有功能，引入了新的缺陷，就可能得不偿失了。</p>

<p>为了避免这种情况发生，我们就需要为其建立充分的测试，并通过建立持续集成（Continuous Integration）环境，提供快速反馈的通道。一旦发现新的修改破坏了系统功能，就需要马上修复或者撤销之前的提交。</p>

<p>问题是我们该如何建立测试保护网？为遗留系统建立测试是一件非常痛苦的事情，为了减小工作量，我们首先应该根据技术迁移的目标，缩小和锁定系统的范围。例如，倘若我们要将系统从IBMMQ迁移到JBossMQ，那么就只需要验证那些与消息队列通信的组件。若要将报表迁移到JasperReport，就应该只检测整个系统的报表组件。另一方面，我们应尽量从粗粒度的测试开始入手。一个好消息是，在之前为了寻找失去的知识时建立的可运行文档，事实上可以看作是一种验收测试。它不仅提供了自说明的文档，同时还建立了覆盖率客观的测试保护网。这种验收测试是针对业务行为编写的完整功能场景，更接近业务需求。它的抽象层次相对较高，并不会涉及太多编程细节。即使实现模块（包括类）是紧耦合的，没有明显的单元边界，我们仍然可以为其编写测试。这就可以省去对类与模块进行解耦这一难度颇高的工作。</p>

<p>通常，我们会将这些测试作为持续集成的一个单独pipeline。每次对原有系统的修改，都要触发该pipeline的运行，以期获得及时的反馈。这样，就可以为原有系统建立一个覆盖范围广泛的测试保护网，使得我们可以有信心地对系统进行技术栈迁移。</p>

<p>针对一些核心场景，我们还可以为遗留系统编写集成测试。这种粗粒度的测试不需要对原有代码进行太多的调整或重构，唯一需要付出的努力是对集成测试环境的搭建。</p>

<p>对于遗留系统的集成测试，最好能够支持本地构建。因为若能在本地开发环境运行集成测试，就可以通过在本地运行构建脚本，快速地获得反馈，避免一些集成错误流入到源代码服务器中，导致持续集成Pipeline频繁出现错误。这种快速失败的方式，可以更好地验证错误，降低集成风险。在搭建本地集成环境时，可以选择一些轻量级框架或容器，提高部署性能。例如我们可以在本地运行Jetty这种轻量级的Web服务器，使用HSQL内存数据库来准备数据。对于某些集成极为困难的情况，也可以适当考虑建立Stub。例如对外部服务的依赖，可以建立一个Stub的Web Service。这种方式虽然没有真实地体现集成功能，但它却可以快速地验证系统内部的功能。</p>

<p>倘若因为一些外部约束，我们无法做到完全的本地构建，也应该提供足够的集成环境，采取混合的方式运行构建脚本。例如可以将正在进行迁移的系统运行在本地环境上，而将该系统需要访问的中间件或者数据库放到其他的集成环境下。我们还可以利用构建脚本如Gradle，建立多种部署环境，例如Dev、Local、Stub、Intg等，使得开发人员或测试人员可以根据不同情况运行不同环境的构建脚本。</p>

<h4>做好充分的技术预研</h4>

<p>所谓“技术栈迁移”，必然是指从一种技术迁移到另一种技术。在充分了解系统当前存在的问题后，还需要深思熟虑，选择合理的目标技术。通常，我们会识别出待迁移模块（或系统）希望达到的质量属性，然后就此功能给出候选技术，建立一个用于权衡的矩阵。接着，再对这些待选技术进行技术预研（Spike），预研的结果将作为最终判断的依据。这种决策是有理有据的，可以有效地规避迁移中因为引入新技术带来的风险。下图是我们在一个项目中对文本搜索进行的技术预研结果矩阵。
<img class="center" src="http://agiledon.github.com/images/2013/04/legacy_02.png"></p>

<p>因为是技术栈迁移，必然要求目标技术一定要优于现有技术，否则就没有迁移的必要了。通过技术预研，既可以提供可以量化的数据，保证这种迁移是值得的；同时也相当于预先开始对目标技术展开学习和了解，及早发现技术难点和迁移的痛点。</p>

<p>在我曾经参与的一个项目中，我们针对报告生成器模块编写了自己的一个支持并发处理的Batch Job。但随着系统用户数量的逐步增加，在生成报告的高峰期，并发请求数超过了之前架构设计预见的峰值，且每个报告生成所耗费的时间较长。于是，我们计划引入消息队列技术来替换现有的Batch Job。我们对一些候选技术进行了前期预研，这其中包括微软的MSMQ、Apache ActiveMQ以及RabbitMQ，针对并发处理、可维护性、成本、部署、安全、分布式处理以及灾备等多方面进行了综合考虑，如下表所示：
<img class="center" src="http://agiledon.github.com/images/2013/04/legacy_03.png"></p>

<p>技术选型从来都不是以单方面的高质量作为评价标准，即使某项技术在多个评判维度上都得到了最高的分数，也未必就是最佳选择。我们必须结合当前项目的具体场景，实事求是地进行判断，以期获得一个恰如其分的迁移方案。</p>

<h4>新旧共存，小步前行</h4>

<p>技术栈迁移的某些特征与架构的演化不谋而合，我们绝对不能奢求获得一个一蹴而就的完美方案，更不能盼望整个迁移过程能够一步到位。尤其针对那些因为战略调整而驱动的技术栈迁移，可能牵涉到架构风格或整个基础设施的修改或调整，单就迁移这一项工作而言，就可能是一个浩大的工程。这时，我们必须要允许新旧共存，通过小步前行的方式逐步以新技术替换旧技术。我们必须保证前进的每一小步，都不会破坏系统的整体功能。这种新旧共存的局面，可能导致在一段时间会出现架构风格或解决方案的不一致，但只要做好整体规划，最终仍能在一致性方面获得完美的答案。</p>

<p>在我们工作的一个项目中，需要将一个独立的系统彻底移除，并将该系统原有的功能集成到另一个系统。需要移除的目标系统目前以Web Service方式提供服务。我们选择的解决方案是渐进地移除该系统。假设待移除的目标系统为Target，要集成的系统为Integration，我们采用了如下的迁移步骤：
1、修改Integration，为其创建与Target提供的Web Service一致的服务接口；
2、让新建立的服务接口的实现调用Target提供的Web Service；
3、修改客户端对Target服务的调用，改为指向新增的Integration服务接口；
4、如果运行一切正常，再将Target中的实现迁移到Integration中；
5、在迁移过程中，提供Toggle开关，可以随时通过改变Toggle的值，选择使用新或旧的调用方式；
6、再次确定采用新的调用方式是否正常，如果正常，彻底去掉原有的实现，移除Target系统。</p>

<p>新旧共存并非一种妥协，而是迁移过程中必须存在的中间状态。Jez Humble介绍了ThoughtWorks产品<a href="http://www.thoughtworks-studios.com/go-continuous-delivery">GO</a>的几次技术栈迁移[7]，包括从iBatis迁移到Hibernate，从Velocity和JsTemplate转向JRuby on Rails的案例。文章提出了一种称为Branch By Abstraction（抽象分支）的迁移方法，执行步骤如下图所示：
<img class="center" src="http://agiledon.github.com/images/2013/04/legacy_04.png"></p>

<p>图中的抽象层将客户端（Consumer）与被替换的实现进行了解耦，使得这种替换可以透明地进行。在对抽象层的实现进行替换时，可以规定替换纪律，例如对于新增功能，必须运用新技术提供实现；还可以通过持续集成的验证门自动验证，例如设置旧有技术在系统中的阈值，每次提交都不允许旧有技术的代码量超过这个阈值。整个迁移过程要保证这个阈值是不断减少，绝不能增加。</p>

<h4>理清思路，持续改进</h4>

<p>要完成遗留系统的技术栈迁移，不可避免地需要对代码实现进行修改或重构。这或许是迁移难度最大的一部分内容。我的经验是针对遗留系统进行处理时，不要从一开始就埋首于浩如烟海的代码段中，太多的细节可能会让你迷失其中。若系统是可以运行的，可以首先运行该系统，通过实际操作了解系统的各个功能点、业务流程。这样的直观感受可以最快地帮助你了解该系统：它能够做什么？它能达成什么目标？它的范围是什么？它存在什么问题？</p>

<p>接下来，我们需要从系统架构出发，了解遗留系统的逻辑结构和物理分布，最好能描绘出遗留系统的轮廓图，这可以帮助你从技术的宏观角度剖析遗留系统的结构与组成；然后再结合你对该系统业务的理解，快速地掌握遗留系统。在阅读源代码时，最好能够从主程序入口开始，找到一些主要的模块，了解其大体的设计方式与编码习惯。由于之前对系统架构已有了解，阅读代码时，不应在一开始就去理解代码实现的细节，而应结合架构文档，比对代码实现是否与文档的描述一致，并充分利用自己的技术与经验，找到阅读代码的终南捷径。例如，如果我们知道该系统采用了MVC架构，就可以很容易地根据Url找到对应的Controller对象，并在该对象中寻找业务功能实现的脉络。又例如我们知道系统引入了WCF来支持分布式处理，而我们又非常熟悉WCF，就可以基本忽略系统基础设施的部分，直接了解系统的业务实现。如果系统基于EJB 2.0实现，则完全可以根据EJB提供的Bean的结构，快速地定位到对应的服务接口与实现。这是因为许多框架都规定了一些约束或规范，从这些约束与规范入手，可以做到事半功倍。</p>

<p>在尝试理解代码的过程中，可以通过手工绘制或利用IDE自动生成包图、时序图等可视性强的UML图，帮助我们理解代码结构。Michael Feathers提出可以为遗留代码绘制影响结构图与特征草图[8]，从而帮助我们去梳理程序中各个对象之间的关系，尤其是帮助我们识别依赖，进而利用接缝类型、隐藏依赖等手法去解除依赖。</p>

<p>了解了代码，还需要对代码进行修改。多数情况下，我们需要首先通过重构来改善代码质量。注意，技术栈的迁移并非重构，但重构可以作为迁移工具箱中一件最为重要的工具。例如，我们可以通过Extract Interface，并结合Use Interface Where Possible手法，对一些具体类进行接口提取，并改变对原来具体类对象的依赖。重构时，必须采取“分而治之，小步前进”的策略。可以首先选择实现较为容易，或者独立性较好的模块进行重构。将遗留系统逐步提取为一些可重用的模块与类。其中，对于原有类或模块的调用方，由于在重构时可能会更改接口，因而可以考虑引入Facade模式或Adapter模式，通过引入间接层对接口进行包装或适配，逐渐替换系统，最后演化为一个结构合理的良好系统。需要注意的是，在重构时一定要时刻谨记，我们之所以进行重构，其目的是为了更好地迁移遗留系统的技术栈，而非为了重构而重构，从而偏离我们之前确定的目标。故而，重构与迁移应该是两顶不同的帽子，不能同时进行。</p>

<h3>四. 结束语</h3>

<p>遗留系统的技术栈迁移可能是一个漫长艰苦的过程，它的难度甚至要高于新开发一个系统，这是因为我们常常会挣扎在新旧系统之间，并在不断的妥协、权衡中缓步前行。</p>

<p>它是一个复杂工程，需要参与者了解迁移前后的技术栈知识，掌握或者至少善于分析与理解遗留系统。我们需要审慎地做出技术决策，通过识别迁移过程的风险来驱动整个迁移过程。在决定迁移选择的技术时，要根据这些识别出来的风险对这些候选技术做充分的预研，获得可供参考的度量矩阵。我们还可以引入BDD框架来编写可运行的功能场景，以此来寻找失去的知识，同时兼得验收测试的保护网。</p>

<p>我们可以通过引入持续集成，建立快速反馈环，以避免迁移时做出的改动对原有系统造成破坏。同时，还必须具备技术迁移的能力。我们可以考虑引入一些最佳实践或迁移方法，例如抽象分支、影响结构图、特征草图，运用设计模式和重构手法来改善遗留代码，以利于技术的迁移。当然，团队协作、架构设计、组织管理、进度跟踪等一系列技术与管理实践同样重要，只是这些实践并非技术栈迁移所必须的，而是所有开发过程都必须经历的过程，因而本文不再赘述这些内容。</p>

<p><strong>参考文献：</strong></p>

<p>[1]：<a href="http://en.wikipedia.org/wiki/Legacy_system">http://en.wikipedia.org/wiki/Legacy_system</a>，原文为：“A legacy system is an old method, technology, computer system, or application program.”</p>

<p>[2]：文章<a href="http://highscalability.com/how-rackspace-now-uses-mapreduce-and-hadoop-query-terabytes-data">How Rackspace Now Uses MapReduce And Hadoop To Query Terabytes Of Data</a></p>

<p>[3]：烟囱系统，一种反模式，<a href="http://highscalability.com/how-rackspace-now-uses-mapreduce-and-hadoop-query-terabytes-data">http://sourcemaking.com/antipatterns/stovepipe-system</a>。</p>

<p>[4]：供应商锁定，一种反模式，参见<a href="http://highscalability.com/how-rackspace-now-uses-mapreduce-and-hadoop-query-terabytes-data">http://sourcemaking.com/antipatterns/vendor-lock-in</a>。</p>

<p>[5]：Gorge Fairbanks：<a href="http://www.amazon.com/Just-Enough-Software-Architecture-Risk-Driven/dp/0984618104">Just Enough Software Architecture</a>，参见第3章Risk Driven Model</p>

<p>[6]：以上所述皆为BDD框架或整体工具。</p>

<p>[7]：Jez Humble：<a href="http://continuousdelivery.com/2011/05/make-large-scale-changes-incrementally-with-branch-by-abstraction/">Make Large Scale Changes Incrementally with Branch By Abstraction</a></p>

<p>[8]：Michael Feathers：<a href="http://www.amazon.com/Working-Effectively-Legacy-Michael-Feathers/dp/0131177052">Working Effectively with Legacy Code</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ThoughtWorks(中国)程序员读书雷达]]></title>
    <link href="http://agiledon.github.com/blog/2013/04/17/thoughtworks-developer-reading-radar/"/>
    <updated>2013-04-17T21:46:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/04/17/thoughtworks-developer-reading-radar</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2013/04/reading-radar.jpg">
软件业的特点是变化。若要提高软件开发的技能，就必须跟上技术发展的步伐。埋首醉心于项目开发与实战，固然能够锤炼自己的开发技巧，却难免受限于经验与学识。世界上并不存在速成的终南捷径，但阅读好的技术书籍，尤其是阅读大师们的经典著作，总能收到事半功倍之效。一位优秀的程序员，或许就是一名好的阅读者。好的阅读者，总是知道如何选择好的书籍。书海浩繁，良莠不齐。阅读技术好书，如与智者交谈，“与君一席话胜读十年书”；遭遇技术烂书，如被拐卖，“少小离家老大回，乡音无改鬓毛衰”。</p>

<p>ThoughtWorks作为一家学习型组织，颇为看重每一位员工的学习能力。事实上，大多数ThoughtWorker的骨子里，都溢满了读书的基因。与书相伴，与书为伍，既是一种乐趣，又是一种习惯。当习惯成为自然时，书籍就成为生活和工作不可或缺的一部分了。如果说人文历史哲学等书籍是一碗心灵鸡汤，技术书籍大抵算得上是一味营养素，读之可以直接带来养分；可若是不了解自己究竟缺了哪一种营养，乱吃乱补，结果就可能适得其反了。有鉴于此，我和同事刘龙军结合自身的阅读经验，为新入职ThoughtWorks的程序员制作了一份读书路线图。我们将范围明确为程序员，是因为作为程序员的我们，它是我们最了解的工作角色。我们筛选出了一些大家公认的经典书籍，再结合自己的阅读体会，并广泛征集了更多ThoughtWorker的意见，包括徐昊，熊节，郑晔等资深阅读者，得到了这样一份草稿。在中国公司内部推出时，这份读书路线图得到了多数人的认可和欢迎。继而，我们在成都办公室陆续针对此读书路线图展开了读书俱乐部的活动，算是做了一次全方位大面积的试水。</p>

<!--more-->


<p>现在，我们觉得是推出正式版本，并面向更多受众的时机了。这就是大家现在看到的ThoughtWorks(中国)程序员读书雷达。它相较于之前的读书路线图草稿，分类更为专业，书籍筛选更为合理，并以雷达独有的优势，来展现不同的阅读维度与阅读深度。显然，读书雷达更能表达我们对所选书籍的深度认识。它可以作为学习型组织的一份知识输入，每一位程序员都可以根据自身水平与能力，选择适合自己的书籍，甚至组成一份表达阅读履历的读书路线图，在获得知识完善与汲取的过程中，提高自身能力，达至各个维度的巅峰。</p>

<p>该读书雷达将书籍分为了如下四个象限：</p>

<blockquote><p>Coding Practice（编程实践）<br/>Architecture & Design（架构与设计）<br/>Methodology（方法学）<br/>Thought & Leadership（思想与领导力）</p></blockquote>


<p>我们之所以将方法学、思想与领导力放入到这个为程序员设计的读书雷达中，乃是因为软件开发不仅仅是个人的活动，也不仅仅是编码技巧和设计能力的体现。我们认为，开发技能其实是一项综合的系统工程。了解方法学，可以促进你对开发过程的理解；关于思想，则涉及大脑思维的修炼，可以提高程序员的抽象能力、学习能力，有助于帮助程序员发现事物发展的规律和本质；至于领导力，则有助于程序员在开发团队中发挥更大的作用，并能作为很好的团队成员，提升团队的整体能力。我们没有在这个读书雷达中包括语言类的书籍，原因在于这类书籍太过于发散，且更新较快；我们也不可能奢望在一张读书雷达图中，为不同的语言平台展现不同的优秀书籍。相比较语言的学习，我们更看重程序员在编程实践上的基本功。</p>

<p>每个象限皆分为三个等级，分别为Fundamental、Medium和Advanced，对应初学、进阶和高级。在雷达图中，读者可以根据该书在图中距离圆心的远近，判断它的难度级别。我们还使用了不同的图示来表达对每本书的倾向性意见，其中，橙色的三角形图示代表“强烈推荐”，蓝色的圆形图示代表“推荐”。我们希望这类书籍对于程序员而言，可以根据自己目前的水平，选择适合自己的书籍。在这个层次上，强烈推荐可能就意味着必读。</p>

<p>或许有人会质疑读书雷达的挑选标准。正所谓“每个人心中都有自己的哈姆雷特”，我们认同的未必能得到读者的认同，这是我们这个世界关于一种观点或态度的常态。我们发布这个读书雷达，只是希望能提供更多有用的信息与参考，而非代表一种读书权利的绝对化。事实上，我们也不可能做到。此外，&#8221;吾生也有涯，而知也无涯&#8221;，我们阅读的书籍毕竟有限，且读书雷达的容量也有限，难免会有遗珠之叹，这也是一件无可奈何之事。然而，我们欢迎更多的批评与建议，或许你推荐的好书恰恰是我们遗忘的，又或者激起了我们的共识，那么我们也会毫不吝啬地更新读书雷达，以求做到我们能力范围内的尽善尽美。当然，正如你看到的，我们在Methodology（方法学）象限，更多地推荐了与敏捷和精益相关的书籍。这是因为我们对敏捷技能与方法更有心得和信心。对于我和刘龙军还不够擅长的领域，我们不敢也不愿做出可能误导人的推荐。</p>

<p>本读书雷达虽然冠以ThoughtWorks（中国）之名，但选书的倾向与意见并非ThoughtWorks（中国）官方的态度，而是作为制作者（龙军和我）个人表达的意见而已。如果你也加入了ThoughtWorks，你一定会发现这种自发组织的民间活动，在ThoughtWorks可谓俯拾皆是，不用诧异。</p>

<p>我将在后面的文章中，根据每个象限为每一本书给出我们的推荐理由。此时，书籍成为了我们的臣民，我想对这个王国做一次不吝惜赞赏的巡视。最后，列出读书雷达的中英文书单，如下所示(感谢凯峰为这个雷达图建立的豆列，可以访问<a href="http://book.douban.com/doulist/2012097/">ThoughtWorks(中国)程序员读书雷达</a>)：</p>

<h3>Coding Practice | 编程实践</h3>

<h4>基础篇</h4>

<blockquote><p>Clean Code《代码整洁之道》<br/>Pragmatic Unit Testing《单元测试之道》<br/>The Productive Programmer《卓有成效的程序员》<br/>Test-Driven Development By Example《测试驱动开发》<br/>Clean Coder《程序员的职业修养》<br/>The Art of Readable Code《编写可读代码的艺术》</p></blockquote>


<h4>进阶篇</h4>

<blockquote><p>Refactoring To Patterns《重构与模式》<br/>Implementation Patterns《实现模式》<br/>Code Complete《代码大全》<br/>The Pragmatic Programmer《程序员修炼之道》</p></blockquote>


<h4>高级篇</h4>

<blockquote><p>Structure and Interpretation of Computer Programs《计算机程序的构造和解释》<br/>Working Effectively with Legacy Code《修改代码的艺术》</p></blockquote>


<h3>Architecture &amp; Design | 架构与设计</h3>

<h4>基础篇</h4>

<blockquote><p>Agile Software Development 《敏捷软件开发：原则、实践与模式》<br/>Head First Design Patterns《深入浅出设计模式》<br/>Design Patterns 《设计模式》</p></blockquote>


<h4>进阶篇</h4>

<blockquote><p>The Art of UNIX Programming 《Unix编程艺术》<br/>Practical API Design  《框架设计的艺术》<br/>Domain Specific Languages 《领域特定语言》<br/>Patterns of Enterprise Application Architecture 《企业应用架构模式》</p></blockquote>


<h4>高级篇</h4>

<blockquote><p>Release It <br/>Domain-Driven Design 《领域驱动设计》<br/>Enterprise Integration Patterns《企业集成模式》<br/>Beautiful Architecture《架构之美》<br/>Pattern-Oriented Software Architecture《面向模式的软件架构》</p></blockquote>


<h3>Methodology | 方法学</h3>

<h4>基础篇</h4>

<blockquote><p>User Stories Applied《用户故事与敏捷方法》<br/>The Gold Mine《金矿》<br/>Scrum and XP From the Trenches《硝烟中的Scrum和XP》<br/>Continuous Integration《持续集成》<br/>Extreme Programming Explained《解析极限编程》</p></blockquote>


<h4>进阶篇</h4>

<blockquote><p>Lean Thinking《精益思想》<br/>Continuous Delivery《持续交付》<br/>How Google Tests Software<br/>Agile Testing<br/>Extreme Programming Refactored《重构极限编程》</p></blockquote>


<h4>高级篇</h4>

<blockquote><p>Specification By Example</p></blockquote>


<h3>Thought &amp; Leadership | 思想与领导力</h3>

<h4>基础篇</h4>

<blockquote><p>The Effective Executive《卓有成效的管理者》<br/>Are Your Lights On?《你的灯亮着吗》<br/>Becoming A Technical Leader《成为技术领导者》</p></blockquote>


<h4>进阶篇</h4>

<blockquote><p>The Fifth Discipline《第五项修炼》<br/>The Design Of Business<br/>Management 3.0《管理3.0：培养和提升敏捷领导力》<br/>Presentation To Win<br/>The McKinsey Way《麦肯锡方法》</p></blockquote>


<h4>高级篇</h4>

<blockquote><p>Thinking, Fast and Slow《思考快与慢》</p></blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阅读Scala代码之二]]></title>
    <link href="http://agiledon.github.com/blog/2013/04/07/reading-scala-code-2/"/>
    <updated>2013-04-07T22:37:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/04/07/reading-scala-code-2</id>
    <content type="html"><![CDATA[<p>今天要阅读的代码来自《Scala By Example》一书的第一个例子。这两段代码通过实现一个快速排序算法体现了命令式与函数式之间的区别。这种直观的对比无疑很好地展现了函数式编程的优雅与简洁。让我们来看看这两段代码，首先是命令式的实现方式：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">def</span> <span class="n">sort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">swap</span><span class="o">(</span><span class="n">i</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">j</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">val</span> <span class="n">t</span> <span class="k">=</span> <span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">);</span> <span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span><span class="o">(</span><span class="n">j</span><span class="o">);</span> <span class="n">xs</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="k">=</span> <span class="n">t</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">def</span> <span class="n">sort1</span><span class="o">(</span><span class="n">l</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">r</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">val</span> <span class="n">pivot</span> <span class="k">=</span> <span class="n">xs</span><span class="o">((</span><span class="n">l</span> <span class="o">+</span> <span class="n">r</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
</span><span class='line'>      <span class="k">var</span> <span class="n">i</span> <span class="k">=</span> <span class="n">l</span><span class="o">;</span> <span class="k">var</span> <span class="n">j</span> <span class="k">=</span> <span class="n">r</span>
</span><span class='line'>      <span class="k">while</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">xs</span><span class="o">(</span><span class="n">i</span><span class="o">)</span> <span class="o">&lt;</span> <span class="n">pivot</span><span class="o">)</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">while</span> <span class="o">(</span><span class="n">xs</span><span class="o">(</span><span class="n">j</span><span class="o">)</span> <span class="o">&gt;</span> <span class="n">pivot</span><span class="o">)</span> <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">j</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">swap</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span>
</span><span class='line'>          <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
</span><span class='line'>          <span class="n">j</span> <span class="o">-=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">j</span><span class="o">)</span> <span class="n">sort1</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">j</span><span class="o">)</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">r</span><span class="o">)</span> <span class="n">sort1</span><span class="o">(</span><span class="n">i</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span>
</span><span class='line'>    <span class="n">sort1</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>下面是函数式的方式：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'>  <span class="k">def</span> <span class="n">sort</span><span class="o">(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">])</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="n">xs</span>
</span><span class='line'>    <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>      <span class="k">val</span> <span class="n">pivot</span> <span class="k">=</span> <span class="n">xs</span><span class="o">(</span><span class="n">xs</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="mi">2</span><span class="o">)</span>
</span><span class='line'>      <span class="nc">Array</span><span class="o">.</span><span class="n">concat</span><span class="o">(</span>
</span><span class='line'>        <span class="n">sort</span><span class="o">(</span><span class="n">xs</span> <span class="n">filter</span> <span class="o">(</span><span class="n">pivot</span> <span class="o">&gt;)),</span>
</span><span class='line'>             <span class="n">xs</span> <span class="n">filter</span> <span class="o">(</span><span class="n">pivot</span> <span class="o">==),</span>
</span><span class='line'>        <span class="n">sort</span><span class="o">(</span><span class="n">xs</span> <span class="n">filter</span> <span class="o">(</span><span class="n">pivot</span> <span class="o">&lt;)))</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>后者的简洁不言而喻，感觉实在太强烈了。它还展露出一种优雅的从容，因为没有嵌套的while循环，清扫了许多阅读障碍，没有繁文缛节，直指问题本质，显得游刃有余，挥洒自如。究其根由，在于这种函数式的编程方式，完全匹配快速排序的算法原则与过程，就像是那种斩钉截铁的证明，没有多余的啰嗦，结果如同“清水出芙蓉，天然来雕饰”。</p>

<p>不提这种感觉的美感，函数式编程带来的实实在在好处在于它的无副作用特质。这就好似你寻找的药方，不仅能够药到病除，服用后还没有不良反应，真可以说得上奢望了。阅读第二段代码，我们可以非常直观地看到没有任何操作修改了传入的xs数组。从外向内看，返回的数组是通过Array.concat将三段数组给串联了起来，返回了一个新的数组对象。表面看来，这段代码对xs做了filter操作，根据传入的Predicate对数组元素进行筛选。事实上，filter同样是函数，它并没有直接更改被操作的数组，而是返回了一个新的筛选后的数组对象。这意味着，即使我们传入一个val的数组对象，这个sort函数也是不会抱怨的。例如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">target</span> <span class="k">=</span> <span class="nc">Array</span><span class="o">(</span><span class="mi">1</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">5</span><span class="o">,</span> <span class="mi">3</span><span class="o">,</span> <span class="mi">8</span><span class="o">,</span> <span class="mi">4</span><span class="o">,</span> <span class="mi">7</span><span class="o">)</span>
</span><span class='line'><span class="k">val</span> <span class="n">result</span> <span class="k">=</span> <span class="n">sort</span><span class="o">(</span><span class="n">target</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>这两种方案皆使用了递归，时间复杂度皆为O(N log(N))，但就简洁性和易读性而言，却不可同日而语。而这种无副作用特性则体现了函数式的不变特质，从而可以极大地简化并发编程模型。当然，这种方法必然会造成空间的浪费；不过，有JVM提供的GC负责内存管理，我们也无需关心这些对象在何时需要被释放。只要系统对内存的要求没有特别的限制，这一问题几乎可以忽略不计。</p>

<p>好吧，让我们再转到Scala语言层面的特性上来。看第一段代码，除了个别关键字与语法不同之外，它几乎与Java代码没有太大的区别，最大的不同还在于Scala将函数（或者说方法）提升到了一等公民。第二段代码中，比较特殊的用法是调用Array的filter函数。该函数的签名为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">filter</span><span class="o">(</span><span class="n">p</span><span class="k">:</span> <span class="kt">T</span> <span class="o">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">Array</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>调用时，这段代码传入的表达式比较奇怪。严格意义上，filter显然需要传入一个函数，这个函数要求一个输入参数，返回为Boolean型。如果采用匿名函数的方式，调用方式应该为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">xs</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="n">x</span> <span class="k">=&gt;</span> <span class="n">pivot</span> <span class="o">&gt;</span> <span class="n">x</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果使用变量的placeholder，则可以表示为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="n">xs</span><span class="o">.</span><span class="n">filter</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="n">pivot</span> <span class="o">&gt;</span> <span class="k">_</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>而这里使用的则是一种称为partially applied function的方式，它支持我们在不会引起歧义的情况下（主要是指只有一个参数的情形），直接省略该参数变量。只要明白这种语法，这样的代码仍然是可读的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[阅读Scala代码之一]]></title>
    <link href="http://agiledon.github.com/blog/2013/04/04/reading-scala-code-1/"/>
    <updated>2013-04-04T22:17:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/04/04/reading-scala-code-1</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://agiledon.github.com/images/2013/04/scala.jpg">
学习一门语言，固然需要了解这门语言的语法，但针对一些完全属于不同范式的语言，即使通过阅读书籍可以理解一些特殊的语法，若不能付诸实践，总有隔靴搔痒之感。其实，要能通过运用这门新语言开发一个项目，或能快速并深刻地了解甚至吃透这门语言。我正是这样尝试着运用Scala来开发我的一个开源框架。可是，在开发过程中，我总感觉自己像是被捆绑了一只手的程序员一般，开发过程磕磕碰碰，不够顺畅。仔细想来，还是因为缺乏对这门语言的足够了解，尤其是那些迥异于Java却又在Scala中是极为常见的惯用法，总不能做到在合适的场景信手拈来。</p>

<p>关键在于，自己阅读Scala的代码太少，编写Scala的代码更少。找到症结，那就尝试去解决。当然，我可以选择一些著名的Scala开源框架，例如<a href="http://www.playframework.com/">Play Framework</a>，Kestrel或者<a href="http://kafka.apache.org/">Kafka</a>，对其进行深入阅读。可是，我发现这些框架对于目前的我而言，似乎显得困难了一点。那么，就从一些短小的代码段开始着手吧。<!--more--></p>

<p>今天阅读的这段代码来自Twitter团队编写的<a href="http://twitter.github.com/effectivescala/">Effective Scala</a>。这段代码对一个Seq对象的值进行了分类汇总，然后进行了排序。代码内容如下：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">votes</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">((</span><span class="s">&quot;scala&quot;</span><span class="o">,</span><span class="mi">1</span><span class="o">),(</span><span class="s">&quot;java&quot;</span><span class="o">,</span><span class="mi">4</span><span class="o">),(</span><span class="s">&quot;scala&quot;</span><span class="o">,</span><span class="mi">10</span><span class="o">),(</span><span class="s">&quot;scala&quot;</span><span class="o">,</span><span class="mi">1</span><span class="o">),(</span><span class="s">&quot;phthon&quot;</span><span class="o">,</span><span class="mi">10</span><span class="o">))</span>
</span><span class='line'><span class="k">val</span> <span class="n">orderedVotes</span> <span class="k">=</span> <span class="n">votes</span>
</span><span class='line'>    <span class="o">.</span><span class="n">groupBy</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">_1</span><span class="o">)</span>
</span><span class='line'>    <span class="o">.</span><span class="n">map</span> <span class="o">{</span> <span class="k">case</span> <span class="o">(</span><span class="n">which</span><span class="o">,</span> <span class="n">counts</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>  <span class="o">(</span><span class="n">which</span><span class="o">,</span> <span class="n">counts</span><span class="o">.</span><span class="n">foldLeft</span><span class="o">(</span><span class="mi">0</span><span class="o">)(</span><span class="k">_</span> <span class="o">+</span> <span class="k">_</span><span class="o">.</span><span class="n">_2</span><span class="o">))</span>
</span><span class='line'>    <span class="o">}.</span><span class="n">toSeq</span>
</span><span class='line'>    <span class="o">.</span><span class="n">sortBy</span><span class="o">(</span><span class="k">_</span><span class="o">.</span><span class="n">_2</span><span class="o">)</span>
</span><span class='line'>    <span class="o">.</span><span class="n">reverse</span>
</span></code></pre></td></tr></table></div></figure>


<p>首先，它针对Seq对象votes进行了分组，调用了Seq集合的groupBy方法。该方法的定义为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">groupBy</span><span class="o">[</span><span class="kt">K</span><span class="o">](</span><span class="n">f</span><span class="k">:</span> <span class="o">(</span><span class="kt">A</span><span class="o">)</span> <span class="o">=&gt;</span> <span class="n">K</span><span class="o">)</span><span class="k">:</span> <span class="kt">immutable.Map</span><span class="o">[</span><span class="kt">K</span>, <span class="kt">Sequ</span><span class="o">[</span><span class="kt">A</span><span class="o">]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>该函数的输入参数实际上是一个函数，该函数的参数为A，这个泛型参数在这里指代Seq元素的类型，即一个tuple；返回值为K，为key对应的类型。groupBy函数的返回值是一个不变类型的Map。对于此例而言，就是根据语言进行分类，由此可以得到三个类别，每个类别又包含一个Seq或者List。结果为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="nc">Map</span><span class="o">(</span><span class="n">scala</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">((</span><span class="n">scala</span><span class="o">,</span><span class="mi">1</span><span class="o">),</span> <span class="o">(</span><span class="n">scala</span><span class="o">,</span><span class="mi">10</span><span class="o">),</span> <span class="o">(</span><span class="n">scala</span><span class="o">,</span><span class="mi">1</span><span class="o">)),</span> <span class="n">java</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">((</span><span class="n">java</span><span class="o">,</span><span class="mi">4</span><span class="o">)),</span> <span class="n">phthon</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">((</span><span class="n">phthon</span><span class="o">,</span><span class="mi">10</span><span class="o">)))</span>
</span></code></pre></td></tr></table></div></figure>


<p>在这段代码中，用到了Scala的特殊语法，例如groupBy(_._1)。括号中的_代表了一个类型为A的参数，在这里就是tuple对象；而_1则是方法名，对于tuple而言，_1方法能够返回tuple的第一个元素，即语言的名称。（与之类似，_2则会返回tuple的第二个元素。）因此，_._1恰好能够满足groupBy()函数需要传入的函数，从而根据语言的名称对votes进行分组。</p>

<p>紧跟着groupBy函数后面的是一个map函数，它可以通过运用一个函数为Map的所有元素建立一个新的集合。简单地理解，可以将其看做是一种转换操作。在上面给出的代码中，map函数中的case (which, counts) => …是一个模式匹配的匿名函数（Pattern Matching Anonymous Functions）。在《The Scala Language Specification》中对此的定义为：</p>

<blockquote><p>which appear as an expression without a prior match. The expected type of such an expression must in part be defined. It must be either scala.Functionk[S1, &#8230;, Sk, R] for some k > 0, or scala.PartialFunction[S1, R], where the argument type(s) S1, &#8230;, Sk must be fully determined, but the result type R may be undetermined.</p></blockquote>


<p>在文章《<a href="http://blog.bruchez.name/2011/10/scala-partial-functions-without-phd.html">Scala Partial Functions Without Phd</a>》中，Erik认为这是一种特殊方式的匿名函数定义，采用这种方式会更加安全，使用更自由。文章给出了一些Partial Function的例子，例如通过Partial Function可以忽略多余的参数，忽略因为除0抛出的异常。这比直接使用匿名函数会更加安全。</p>

<p>在这段代码中，map函数接受which参数就是lang，counts则是lang对应的List。在这个匿名函数中，会对counts这个List类型进行求和操作（通过foldLeft函数）。返回的结果仍然是一个包含了Tuple元素的Map类型。</p>

<p>接下来的方法就比较容易理解了，即调用toSeq将Map转换为Seq，并根据tuple的第二个元素进行排序，此时，排序的关键字为统计的语言次数。soryBy函数的默认排序为升序，因此需要调用reverse颠倒顺序。</p>

<p>如果弄懂了Scala与此相关的语法，要理解这段代码还是比较容易的。然而，在Twitter给出的Effective Scala文章中，提到了关于编程意图的问题。因为上述代码通过一种类似流水线转换的方式完成整个操作，操作过程中的一些中间值被隐藏在一系列的函数调用中，并没有很好地展现其意图。文章提出的解决办法就是声明中间结果和参数。上述代码可以改写为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">votes</span> <span class="k">=</span> <span class="nc">Seq</span><span class="o">((</span><span class="s">&quot;scala&quot;</span><span class="o">,</span><span class="mi">1</span><span class="o">),(</span><span class="s">&quot;java&quot;</span><span class="o">,</span><span class="mi">4</span><span class="o">),(</span><span class="s">&quot;scala&quot;</span><span class="o">,</span><span class="mi">10</span><span class="o">),(</span><span class="s">&quot;scala&quot;</span><span class="o">,</span><span class="mi">1</span><span class="o">),(</span><span class="s">&quot;phthon&quot;</span><span class="o">,</span><span class="mi">10</span><span class="o">))</span>
</span><span class='line'><span class="k">val</span> <span class="n">votesByLang</span> <span class="k">=</span> <span class="n">votes</span> <span class="n">groupBy</span> <span class="o">{</span> <span class="k">case</span><span class="o">(</span><span class="n">lang</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">lang</span> <span class="o">}</span>
</span><span class='line'><span class="k">val</span> <span class="n">sumByLang</span> <span class="k">=</span> <span class="n">votesByLang</span> <span class="n">map</span> <span class="o">{</span> <span class="o">(</span><span class="n">lang</span><span class="o">,</span> <span class="n">counts</span><span class="o">)</span> <span class="k">=&gt;</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">countsOnly</span> <span class="k">=</span> <span class="n">counts</span> <span class="n">map</span> <span class="o">{</span> <span class="k">case</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">count</span><span class="o">}</span>
</span><span class='line'>  <span class="o">(</span><span class="n">lang</span><span class="o">,</span> <span class="n">countsOnly</span><span class="o">.</span><span class="n">sum</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'><span class="k">val</span> <span class="n">orderedVotes</span> <span class="k">=</span> <span class="n">sumByLang</span><span class="o">.</span><span class="n">toSeq</span>
</span><span class='line'>  <span class="o">.</span><span class="n">sortBy</span> <span class="o">{</span> <span class="k">case</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="n">count</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">count</span> <span class="o">}</span>
</span><span class='line'>    <span class="o">.</span><span class="n">reverse</span>
</span></code></pre></td></tr></table></div></figure>


<p>因为有了中间值的变量声明，意图会变得更清晰一些。我同意这样的观点，特别是针对一些函数式语言或动态语言而言，代码变得简洁了，但有时候会用到一些比较tricky的花招，影响了代码的可读性。但要注意，这种可读性一定是基于该语言的特色而言。我们千万不能将Scala程序写成Java命令式的方式，以为这样适合Java程序员的阅读习惯，这无疑误解了所谓“可读性”的含义。当然，就这段代码而言，由于groupBy函数的名称已经非常清晰，我并不太赞成提取出votesByLang的中间变量。这类似fluent interface的方式，只要API的设计是有意义的，这种流水线的处理方式仍然非常清楚，前提是我们要有合理的排版。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[新手培养日记(二)]]></title>
    <link href="http://agiledon.github.com/blog/2013/03/28/diary-2-for-coaching-fresh-man/"/>
    <updated>2013-03-28T20:30:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/03/28/diary-2-for-coaching-fresh-man</id>
    <content type="html"><![CDATA[<p><img class="center" src="http://agiledon.github.com/images/2013/03/learning_perception.jpg">
几天后，新手又一次提交了一份代码。由于改动较大，新手重新创建了一个项目。在这份代码中，新手接受了我的建议，改为使用Spring提供的JdbcTemplate。包的结构也得到了一定程度的改善。这充分说明他认识到了问题所在，并能够快速准确地采取行动去纠正这些问题。但或许是我提出的问题太多，给出的建议不够具体，在新提交的这份代码中，我还是看到了一些问题，且某些问题在上一次Review代码时，我曾经提及。</p>

<p>来看看如下两段代码。首先，是CustomerService，它定义了目前Story要求的基本业务：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Service</span><span class="o">(</span><span class="s">&quot;customerService&quot;</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomerService</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Autowired</span>
</span><span class='line'>    <span class="nd">@Qualifier</span><span class="o">(</span><span class="s">&quot;customerDAO&quot;</span><span class="o">)</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">CustomerDAO</span> <span class="n">customerDAO</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">private</span> <span class="kd">final</span> <span class="n">String</span> <span class="n">defaultTableNameForCustomer</span> <span class="o">=</span> <span class="s">&quot;customer&quot;</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">tableName</span> <span class="o">=</span> <span class="n">defaultTableNameForCustomer</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTableName</span><span class="o">(</span><span class="n">String</span> <span class="n">tableName</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">tableName</span> <span class="o">=</span> <span class="n">tableName</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Transactional</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addCustomer</span><span class="o">(</span><span class="n">Customer</span> <span class="n">customer</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">DuplicateCustomerException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">customerDAO</span><span class="o">.</span><span class="na">addCustomer</span><span class="o">(</span><span class="n">customer</span><span class="o">,</span> <span class="n">tableName</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Customer</span> <span class="nf">getCustomer</span><span class="o">(</span><span class="n">String</span> <span class="n">nickname</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">CustomerNotFoundException</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">customerDAO</span><span class="o">.</span><span class="na">getCustomer</span><span class="o">(</span><span class="n">nickname</span><span class="o">,</span> <span class="n">tableName</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">withdraw</span><span class="o">(</span><span class="n">String</span> <span class="n">nickname</span><span class="o">,</span> <span class="kt">double</span> <span class="n">balanceToWithdraw</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">BalanceOverdrawException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">customerDAO</span><span class="o">.</span><span class="na">withdrawBalance</span><span class="o">(</span><span class="n">nickname</span><span class="o">,</span> <span class="n">balanceToWithdraw</span><span class="o">,</span> <span class="n">tableName</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deposit</span><span class="o">(</span><span class="n">String</span> <span class="n">nickname</span><span class="o">,</span> <span class="kt">double</span> <span class="n">balance</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">customerDAO</span><span class="o">.</span><span class="na">deposit</span><span class="o">(</span><span class="n">nickname</span><span class="o">,</span> <span class="n">balance</span><span class="o">,</span> <span class="n">tableName</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>在CustomerService类中，调用了CustomerDAO类的相关方法：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="nd">@Component</span>
</span><span class='line'><span class="nd">@Repository</span><span class="o">(</span><span class="s">&quot;customerDAO&quot;</span><span class="o">)</span>
</span><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">CustomerDAO</span> <span class="o">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Autowired</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">JdbcTemplate</span> <span class="n">jdbcTemplate</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">createTable</span><span class="o">(</span><span class="n">String</span> <span class="n">tableName</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="s">&quot;DROP TABLE IF EXISTS &quot;</span> <span class="o">+</span> <span class="n">tableName</span><span class="o">);</span>
</span><span class='line'>        <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">execute</span><span class="o">(</span><span class="s">&quot;CREATE TABLE &quot;</span> <span class="o">+</span> <span class="n">tableName</span> <span class="o">+</span> <span class="s">&quot;(&quot;</span> <span class="o">+</span> <span class="s">&quot;nickname VARCHAR(45) NOT NULL ,&quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;dateOfBirth DATETIME NOT NULL,&quot;</span> <span class="o">+</span> <span class="s">&quot;balance DOUBLE NOT NULL, &quot;</span> <span class="o">+</span> <span class="s">&quot;PRIMARY KEY(nickname)&quot;</span> <span class="o">+</span> <span class="s">&quot;);&quot;</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addCustomer</span><span class="o">(</span><span class="n">Customer</span> <span class="n">customer</span><span class="o">,</span> <span class="n">String</span> <span class="n">tableName</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">DuplicateCustomerException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">SQL</span> <span class="o">=</span> <span class="s">&quot;insert into &quot;</span> <span class="o">+</span> <span class="n">tableName</span> <span class="o">+</span> <span class="s">&quot;(nickname, dateOfBirth, balance) values (?, ?, ?)&quot;</span><span class="o">;</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">SQL</span><span class="o">,</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[]{</span><span class="n">customer</span><span class="o">.</span><span class="na">getNickname</span><span class="o">(),</span> <span class="n">customer</span><span class="o">.</span><span class="na">getDateOfBirth</span><span class="o">(),</span> <span class="n">customer</span><span class="o">.</span><span class="na">getBalance</span><span class="o">()});</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">DuplicateKeyException</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">DuplicateCustomerException</span><span class="o">(</span><span class="s">&quot;Customer with nickname &quot;</span> <span class="o">+</span> <span class="n">customer</span><span class="o">.</span><span class="na">getNickname</span><span class="o">()</span> <span class="o">+</span> <span class="s">&quot; has already existed&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Customer</span> <span class="nf">getCustomer</span><span class="o">(</span><span class="n">String</span> <span class="n">nickname</span><span class="o">,</span> <span class="n">String</span> <span class="n">tableName</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">CustomerNotFoundException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">SQL</span> <span class="o">=</span> <span class="s">&quot;select * from &quot;</span> <span class="o">+</span> <span class="n">tableName</span> <span class="o">+</span> <span class="s">&quot; where nickname = ?&quot;</span><span class="o">;</span>
</span><span class='line'>        <span class="n">Customer</span> <span class="n">customer</span><span class="o">;</span>
</span><span class='line'>        <span class="k">try</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">customer</span> <span class="o">=</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">queryForObject</span><span class="o">(</span><span class="n">SQL</span><span class="o">,</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[]{</span><span class="n">nickname</span><span class="o">},</span> <span class="k">new</span> <span class="n">CustomerMapper</span><span class="o">());</span>
</span><span class='line'>        <span class="o">}</span> <span class="k">catch</span> <span class="o">(</span><span class="n">EmptyResultDataAccessException</span> <span class="n">exception</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">CustomerNotFoundException</span><span class="o">(</span><span class="s">&quot;Customer with nickname &quot;</span> <span class="o">+</span> <span class="n">nickname</span> <span class="o">+</span> <span class="s">&quot; is not found&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">customer</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">Double</span> <span class="nf">getBalance</span><span class="o">(</span><span class="n">String</span> <span class="n">nickname</span><span class="o">,</span> <span class="n">String</span> <span class="n">tableName</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">String</span> <span class="n">SQL</span> <span class="o">=</span> <span class="s">&quot;select balance from &quot;</span> <span class="o">+</span> <span class="n">tableName</span> <span class="o">+</span> <span class="s">&quot; where nickname = ?&quot;</span><span class="o">;</span>
</span><span class='line'>        <span class="kt">double</span> <span class="n">balance</span> <span class="o">=</span> <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">queryForObject</span><span class="o">(</span><span class="n">SQL</span><span class="o">,</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[]{</span><span class="n">nickname</span><span class="o">},</span> <span class="n">Double</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">balance</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">withdrawBalance</span><span class="o">(</span><span class="n">String</span> <span class="n">nickname</span><span class="o">,</span> <span class="kt">double</span> <span class="n">balanceToWithdraw</span><span class="o">,</span> <span class="n">String</span> <span class="n">tableName</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">BalanceOverdrawException</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">double</span> <span class="n">balanceBefore</span> <span class="o">=</span> <span class="n">getBalance</span><span class="o">(</span><span class="n">nickname</span><span class="o">,</span> <span class="n">tableName</span><span class="o">);</span>
</span><span class='line'>        <span class="kt">double</span> <span class="n">balanceAfter</span> <span class="o">=</span> <span class="n">balanceBefore</span> <span class="o">-</span> <span class="n">balanceToWithdraw</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">balanceAfter</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="k">throw</span> <span class="k">new</span> <span class="nf">BalanceOverdrawException</span><span class="o">(</span><span class="s">&quot;You have only &quot;</span> <span class="o">+</span> <span class="n">balanceBefore</span> <span class="o">+</span> <span class="s">&quot;$. You can not withdraw &quot;</span> <span class="o">+</span> <span class="n">balanceToWithdraw</span> <span class="o">+</span> <span class="s">&quot;$&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">String</span> <span class="n">SQL</span> <span class="o">=</span> <span class="s">&quot;update &quot;</span> <span class="o">+</span> <span class="n">tableName</span> <span class="o">+</span> <span class="s">&quot; set balance = ? where nickname = ?&quot;</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">SQL</span><span class="o">,</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[]{</span><span class="n">balanceAfter</span><span class="o">,</span> <span class="n">nickname</span><span class="o">});</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">deposit</span><span class="o">(</span><span class="n">String</span> <span class="n">nickname</span><span class="o">,</span> <span class="kt">double</span> <span class="n">balanceToDeposit</span><span class="o">,</span> <span class="n">String</span> <span class="n">tableName</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">double</span> <span class="n">balanceBefore</span> <span class="o">=</span> <span class="n">getBalance</span><span class="o">(</span><span class="n">nickname</span><span class="o">,</span> <span class="n">tableName</span><span class="o">);</span>
</span><span class='line'>        <span class="kt">double</span> <span class="n">balanceAfter</span> <span class="o">=</span> <span class="n">balanceBefore</span> <span class="o">+</span> <span class="n">balanceToDeposit</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">String</span> <span class="n">SQL</span> <span class="o">=</span> <span class="s">&quot;update &quot;</span> <span class="o">+</span> <span class="n">tableName</span> <span class="o">+</span> <span class="s">&quot; set balance = ? where nickname = ?&quot;</span><span class="o">;</span>
</span><span class='line'>        <span class="n">jdbcTemplate</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">SQL</span><span class="o">,</span> <span class="k">new</span> <span class="n">Object</span><span class="o">[]{</span><span class="n">balanceAfter</span><span class="o">,</span> <span class="n">nickname</span><span class="o">});</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这两段代码存在什么问题？</p>

<p>显然，我们看到CustomerService履行的职责仅仅是对调用的委派，另外还添加了事务功能，除此之外，它什么事情都没有做，接到了请求，转手就递给CustomerDAO了。再看CustomerDAO，特别关注withdrawBalance()方法，你会发现这个方法的实现其实体现了较多的业务逻辑。事实上，我们看到这个方法的名称，体现的就是业务的概念。显然，这里的职责分配是不合理的。新手明显没有深刻体会Service与Dao之间的区别。无论是传统的分层架构模型，还是DDD提出的领域层与基础设施层的分离，都表达了业务与数据访问关注点分离的原则。事实上，新手还错误地将Service类放到了database.service包中。</p>

<p>正确的做法应该是保证每个对象的纯洁性与单一性，让每个对象只做一件事情，只做它应该关心的事情，遵循单一职责原则。Dao是数据访问对象，那么它就应该只处理数据访问的逻辑，而对具体业务应该是“一无所知”的。一个简单的识别办法，就是不要在这个类中出现任何业务概念，它做的事情就是CRUD。</p>

<p>对于许多OO初学者而言，职责不清是最容易犯下的毛病。要么就是恨不得把所有内容都塞给一个类；要么就是张冠李戴，随着性子乱分配职责，全然不考虑每个对象的感受。我常常说，对象是有意识的生物，这样不尊重对象搞乱分配，迟早这些对象会造反。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hadoop MapReduce技巧]]></title>
    <link href="http://agiledon.github.com/blog/2013/03/19/hadoop-mapreduce-skillset/"/>
    <updated>2013-03-19T13:19:00+08:00</updated>
    <id>http://agiledon.github.com/blog/2013/03/19/hadoop-mapreduce-skillset</id>
    <content type="html"><![CDATA[<p><img class="left" src="http://agiledon.github.com/images/2013/03/mapreduce.jpg">
我在使用Hadoop编写MapReduce程序时，遇到了一些问题，通过在Google上查询资料，并结合自己对Hadoop的理解，逐一解决了这些问题。</p>

<h4>自定义Writable</h4>

<p>Hadoop对MapReduce中Key与Value的类型是有要求的，简单说来，这些类型必须支持Hadoop的序列化。为了提高序列化的性能，Hadoop还为Java中常见的基本类型提供了相应地支持序列化的类型，如IntWritable，LongWritable，并为String类型提供了Text类型。不过，这些Hadoop内建的类型并不足以支持真实遇到的业务。此时，就需要自定义Writable类，使得它既能够作为Job的Key或者Value，又能体现业务逻辑。</p>

<p>假设我已经从豆瓣抓取了书籍的数据，包括书籍的Title以及读者定义的Tag，并以Json格式存储在文本文件中。现在我希望提取这些数据中我感兴趣的内容，例如指定书籍的Tag列表，包括Tag被标记的次数。这些数据可以作为向量，为后面的数据分析提供基础数据。对于Map，我希望读取Json文件，然后得到每本书的Title，以及对应的单个Tag信息。作为Map的输出，我希望是我自己定义的类型BookTag。<!--more-->它只包括Tag的名称和标记次数：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BookTag</span> <span class="kd">implements</span> <span class="n">Writable</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">String</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">BookTag</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="nf">BookTag</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">,</span> <span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">write</span><span class="o">(</span><span class="n">DataOutput</span> <span class="n">dataOutput</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">dataOutput</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">Text</span><span class="o">.</span><span class="na">writeString</span><span class="o">(</span><span class="n">dataOutput</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
</span><span class='line'>            <span class="n">dataOutput</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">count</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">readFields</span><span class="o">(</span><span class="n">DataInput</span> <span class="n">dataInput</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">(</span><span class="n">dataInput</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">name</span> <span class="o">=</span> <span class="n">Text</span><span class="o">.</span><span class="na">readString</span><span class="o">(</span><span class="n">dataInput</span><span class="o">);</span>
</span><span class='line'>            <span class="n">count</span> <span class="o">=</span> <span class="n">dataInput</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">getName</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setName</span><span class="o">(</span><span class="n">String</span> <span class="n">name</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">getCount</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setCount</span><span class="o">(</span><span class="kt">int</span> <span class="n">count</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">this</span><span class="o">.</span><span class="na">count</span> <span class="o">=</span> <span class="n">count</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="s">&quot;BookTag{&quot;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;name=&#39;&quot;</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="sc">&#39;\&#39;&#39;</span> <span class="o">+</span>
</span><span class='line'>                <span class="s">&quot;, count=&quot;</span> <span class="o">+</span> <span class="n">count</span> <span class="o">+</span>
</span><span class='line'>                <span class="sc">&#39;}&#39;</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>注意，在write()与readFields()方法中，对于String类型的处理完全不同于Int、Long等类型，它需要调用Text的相关静态方法。</p>

<p>针对每本书，Map出来的结果可能包含重复的BookTag信息（指Tag Name相同）；而我需要得到每个Tag的标记总和，以作为数据分析的向量。因此，作为Reduce的输入，可以是&lt;Text, Iterable<BookTag>>，但输出则应该是合并了相同Tag信息的结果。为此，我引入了BookTags类，在其内部维持了一个BookTag的Map，它同样需要实现Writable。由于BookTags包含了一个集合类型，因此它的实现会略有不同：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">BookTags</span> <span class="kd">implements</span> <span class="n">Writable</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">BookTag</span><span class="o">&gt;</span> <span class="n">tags</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">BookTag</span><span class="o">&gt;();</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">write</span><span class="o">(</span><span class="n">DataOutput</span> <span class="n">dataOutput</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">dataOutput</span><span class="o">.</span><span class="na">writeInt</span><span class="o">(</span><span class="n">tags</span><span class="o">.</span><span class="na">size</span><span class="o">());</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">BookTag</span> <span class="n">tag</span> <span class="o">:</span> <span class="n">tags</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">tag</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">dataOutput</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">readFields</span><span class="o">(</span><span class="n">DataInput</span> <span class="n">dataInput</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">dataInput</span><span class="o">.</span><span class="na">readInt</span><span class="o">();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">BookTag</span> <span class="n">tag</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BookTag</span><span class="o">();</span>
</span><span class='line'>            <span class="n">tag</span><span class="o">.</span><span class="na">readFields</span><span class="o">(</span><span class="n">dataInput</span><span class="o">);</span>
</span><span class='line'>            <span class="n">tags</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">tag</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">tag</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">add</span><span class="o">(</span><span class="n">BookTag</span> <span class="n">tag</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">String</span> <span class="n">tagName</span> <span class="o">=</span> <span class="n">tag</span><span class="o">.</span><span class="na">getName</span><span class="o">();</span>
</span><span class='line'>            <span class="k">if</span> <span class="o">(</span><span class="n">tags</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">tagName</span><span class="o">))</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">BookTag</span> <span class="n">bookTag</span> <span class="o">=</span> <span class="n">tags</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">tagName</span><span class="o">);</span>
</span><span class='line'>                <span class="n">bookTag</span><span class="o">.</span><span class="na">setCount</span><span class="o">(</span><span class="n">bookTag</span><span class="o">.</span><span class="na">getCount</span><span class="o">()</span> <span class="o">+</span> <span class="n">tag</span><span class="o">.</span><span class="na">getCount</span><span class="o">());</span>
</span><span class='line'>            <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">tags</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">tagName</span><span class="o">,</span> <span class="n">tag</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Override</span>
</span><span class='line'>    <span class="kd">public</span> <span class="n">String</span> <span class="nf">toString</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">StringBuilder</span> <span class="n">resultTags</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringBuilder</span><span class="o">();</span>
</span><span class='line'>        <span class="k">for</span> <span class="o">(</span><span class="n">BookTag</span> <span class="n">tag</span> <span class="o">:</span> <span class="n">tags</span><span class="o">.</span><span class="na">values</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">resultTags</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="n">tag</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span><span class='line'>            <span class="n">resultTags</span><span class="o">.</span><span class="na">append</span><span class="o">(</span><span class="s">&quot;|&quot;</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">resultTags</span><span class="o">.</span><span class="na">toString</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>其实，针对这种嵌套了集合的自定义Writable类型，由于嵌套的类型同样实现了Writable接口，因而同样可以调用嵌套类型的write()与readFields()方法，唯一的区别是需要将集合的Size写入到DataOutput中，以便于在读取时可以遍历集合。这实际上是一种Composite模式。</p>

<h4>Iterable的奇怪行为</h4>

<p>我需要在reduce()方法中，遍历传入的Iterable<BookTag>，以便于对重复的Tag进行累加操作。在遍历该对象时，我发现了一个奇怪现象，即最终得到的每本书的Tag信息，全部变成了一样的内容。通过对Reduce Job进行调试，发现每当遍历到Iterable<BookTag>的下一个元素时，这个最新的值就会覆盖之前得到的对象，使其变成同一个对象。通过Google，我发现这个问题是Hadoop的奇怪行为，即Iterable对象的next()方法永远会返回同一个对象。解决办法就是在遍历时，创建一个新对象放到我们要存储的集合中，如下第5行代码所示：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">BookReduce</span> <span class="kd">extends</span> <span class="n">Reducer</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">,</span> <span class="n">BookTag</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">BookTags</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">Text</span> <span class="n">key</span><span class="o">,</span> <span class="n">Iterable</span><span class="o">&lt;</span><span class="n">BookTag</span><span class="o">&gt;</span> <span class="n">values</span><span class="o">,</span> <span class="n">Context</span> <span class="n">context</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span><span class="o">,</span> <span class="n">InterruptedException</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">BookTags</span> <span class="n">bookTags</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BookTags</span><span class="o">();</span>
</span><span class='line'>            <span class="k">for</span> <span class="o">(</span><span class="n">BookTag</span> <span class="n">tag</span> <span class="o">:</span> <span class="n">values</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">bookTags</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">BookTag</span><span class="o">(</span><span class="n">tag</span><span class="o">.</span><span class="na">getName</span><span class="o">(),</span> <span class="n">tag</span><span class="o">.</span><span class="na">getCount</span><span class="o">()));</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>            <span class="n">context</span><span class="o">.</span><span class="na">write</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">bookTags</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>这里得到的一个经验是，在编写MapReduce程序时，通过调试可以帮助你快速地定位问题。调试时，可以在项目的根目录下建立input文件夹，将数据源文件放入到该文件夹中，然后在调试的参数中设置即可。</p>

<h4>如何进行单元测试</h4>

<p>我们同样可以给MapReduce Job编写单元测试。除了可以使用Mockito进行Mock之外，我认为MRUnit可以更好地完成对MapReduce任务的验证。MRUnit为Map与Reduce提供了对应的Driver，即MapDriver与ReduceDriver。在编写测试用例时，我们只需要为Driver指定Input与Output，然后执行Driver的runTest()方法，即可测试任务的执行是否符合预期。这种预期是针对output输出的结果而言。以WordCounter为例，编写的单元测试如下：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">WordCounterTest</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">MapDriver</span><span class="o">&lt;</span><span class="n">LongWritable</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">&gt;</span> <span class="n">mapDriver</span><span class="o">;</span>
</span><span class='line'>    <span class="kd">private</span> <span class="n">ReduceDriver</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">&gt;</span> <span class="n">reduceDriver</span><span class="o">;</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Before</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setUp</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">WordCounter</span><span class="o">.</span><span class="na">Map</span> <span class="n">tokenizerMapper</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WordCounter</span><span class="o">.</span><span class="na">Map</span><span class="o">();</span>
</span><span class='line'>        <span class="n">WordCounter</span><span class="o">.</span><span class="na">Reduce</span> <span class="n">reducer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WordCounter</span><span class="o">.</span><span class="na">Reduce</span><span class="o">();</span>
</span><span class='line'>        <span class="n">mapDriver</span> <span class="o">=</span> <span class="n">MapDriver</span><span class="o">.</span><span class="na">newMapDriver</span><span class="o">(</span><span class="n">tokenizerMapper</span><span class="o">);</span>
</span><span class='line'>        <span class="n">reduceDriver</span> <span class="o">=</span> <span class="n">ReduceDriver</span><span class="o">.</span><span class="na">newReduceDriver</span><span class="o">(</span><span class="n">reducer</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_execute_tokenizer_map_job</span><span class="o">()</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">mapDriver</span><span class="o">.</span><span class="na">withInput</span><span class="o">(</span><span class="k">new</span> <span class="n">LongWritable</span><span class="o">(</span><span class="mi">12</span><span class="o">),</span> <span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">&quot;I am Bruce Bruce&quot;</span><span class="o">));</span>
</span><span class='line'>        <span class="n">mapDriver</span><span class="o">.</span><span class="na">withOutput</span><span class="o">(</span><span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">&quot;I&quot;</span><span class="o">),</span> <span class="k">new</span> <span class="n">IntWritable</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
</span><span class='line'>        <span class="n">mapDriver</span><span class="o">.</span><span class="na">withOutput</span><span class="o">(</span><span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">&quot;am&quot;</span><span class="o">),</span> <span class="k">new</span> <span class="n">IntWritable</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
</span><span class='line'>        <span class="n">mapDriver</span><span class="o">.</span><span class="na">withOutput</span><span class="o">(</span><span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">&quot;Bruce&quot;</span><span class="o">),</span> <span class="k">new</span> <span class="n">IntWritable</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
</span><span class='line'>        <span class="n">mapDriver</span><span class="o">.</span><span class="na">withOutput</span><span class="o">(</span><span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">&quot;Bruce&quot;</span><span class="o">),</span> <span class="k">new</span> <span class="n">IntWritable</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
</span><span class='line'>        <span class="n">mapDriver</span><span class="o">.</span><span class="na">runTest</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nd">@Test</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">should_execute_reduce_job</span><span class="o">()</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">List</span><span class="o">&lt;</span><span class="n">IntWritable</span><span class="o">&gt;</span> <span class="n">values</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;</span><span class="n">IntWritable</span><span class="o">&gt;();</span>
</span><span class='line'>        <span class="n">values</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">IntWritable</span><span class="o">(</span><span class="mi">1</span><span class="o">));</span>
</span><span class='line'>        <span class="n">values</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="k">new</span> <span class="n">IntWritable</span><span class="o">(</span><span class="mi">3</span><span class="o">));</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">reduceDriver</span><span class="o">.</span><span class="na">withInput</span><span class="o">(</span><span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">&quot;Bruce&quot;</span><span class="o">),</span> <span class="n">values</span><span class="o">);</span>
</span><span class='line'>        <span class="n">reduceDriver</span><span class="o">.</span><span class="na">withOutput</span><span class="o">(</span><span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="s">&quot;Bruce&quot;</span><span class="o">),</span> <span class="k">new</span> <span class="n">IntWritable</span><span class="o">(</span><span class="mi">4</span><span class="o">));</span>
</span><span class='line'>        <span class="n">reduceDriver</span><span class="o">.</span><span class="na">runTest</span><span class="o">();</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h4>Chaining Job</h4>

<p>通过利用Hadoop提供的ChainMapper与ChainReducer，可以较为容易地实现多个Map Job或Reduce Job的链接。例如，我们可以将WordCounter分解为Tokenizer与Upper Case两个Map任务，最后执行Reduce。遗憾的是，ChainMapper与ChainReducer似乎不支持新版本的API，它要链接的Map与Reduce必须派生自MapReduceBase，并实现对应的Mapper或Reducer接口(说明，下面的代码基本上来自于StackOverFlow的<a href="http://stackoverflow.com/a/10470437/1008310">一个帖子</a>)。</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='java'><span class='line'><span class="kd">public</span> <span class="kd">class</span> <span class="nc">ChainWordCounter</span> <span class="kd">extends</span> <span class="n">Configured</span> <span class="kd">implements</span> <span class="n">Tool</span> <span class="o">{</span>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Tokenizer</span> <span class="kd">extends</span> <span class="n">MapReduceBase</span> <span class="kd">implements</span> <span class="n">Mapper</span><span class="o">&lt;</span><span class="n">LongWritable</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">private</span> <span class="kd">final</span> <span class="kd">static</span> <span class="n">IntWritable</span> <span class="n">one</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IntWritable</span><span class="o">(</span><span class="mi">1</span><span class="o">);</span>
</span><span class='line'>        <span class="kd">private</span> <span class="n">Text</span> <span class="n">word</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Text</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">map</span><span class="o">(</span><span class="n">LongWritable</span> <span class="n">key</span><span class="o">,</span> <span class="n">Text</span> <span class="n">value</span><span class="o">,</span> <span class="n">OutputCollector</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">&gt;</span> <span class="n">output</span><span class="o">,</span> <span class="n">Reporter</span> <span class="n">reporter</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">StringTokenizer</span> <span class="n">tokenizer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringTokenizer</span><span class="o">(</span><span class="n">value</span><span class="o">.</span><span class="na">toString</span><span class="o">());</span>
</span><span class='line'>            <span class="k">while</span> <span class="o">(</span><span class="n">tokenizer</span><span class="o">.</span><span class="na">hasMoreTokens</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">word</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">tokenizer</span><span class="o">.</span><span class="na">nextToken</span><span class="o">());</span>
</span><span class='line'>                <span class="n">output</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">word</span><span class="o">,</span> <span class="n">one</span><span class="o">);</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">UpperCaser</span> <span class="kd">extends</span> <span class="n">MapReduceBase</span> <span class="kd">implements</span> <span class="n">Mapper</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">map</span><span class="o">(</span><span class="n">Text</span> <span class="n">key</span><span class="o">,</span> <span class="n">IntWritable</span> <span class="n">count</span><span class="o">,</span> <span class="n">OutputCollector</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">&gt;</span> <span class="n">collector</span><span class="o">,</span> <span class="n">Reporter</span> <span class="n">reporter</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>            <span class="n">collector</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="k">new</span> <span class="n">Text</span><span class="o">(</span><span class="n">key</span><span class="o">.</span><span class="na">toString</span><span class="o">().</span><span class="na">toUpperCase</span><span class="o">()),</span> <span class="n">count</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">class</span> <span class="nc">Reduce</span> <span class="kd">extends</span> <span class="n">MapReduceBase</span> <span class="kd">implements</span> <span class="n">Reducer</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">,</span> <span class="n">Text</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">&gt;</span> <span class="o">{</span>
</span><span class='line'>        <span class="kd">private</span> <span class="n">IntWritable</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">IntWritable</span><span class="o">();</span>
</span><span class='line'>
</span><span class='line'>        <span class="nd">@Override</span>
</span><span class='line'>        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">reduce</span><span class="o">(</span><span class="n">Text</span> <span class="n">key</span><span class="o">,</span> <span class="n">Iterator</span><span class="o">&lt;</span><span class="n">IntWritable</span><span class="o">&gt;</span> <span class="n">values</span><span class="o">,</span> <span class="n">OutputCollector</span><span class="o">&lt;</span><span class="n">Text</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">&gt;</span> <span class="n">collector</span><span class="o">,</span> <span class="n">Reporter</span> <span class="n">reporter</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">IOException</span> <span class="o">{</span>
</span><span class='line'>            <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>            <span class="k">while</span> <span class="o">(</span><span class="n">values</span><span class="o">.</span><span class="na">hasNext</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                <span class="n">sum</span> <span class="o">+=</span> <span class="n">values</span><span class="o">.</span><span class="na">next</span><span class="o">().</span><span class="na">get</span><span class="o">();</span>
</span><span class='line'>            <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>            <span class="n">result</span><span class="o">.</span><span class="na">set</span><span class="o">(</span><span class="n">sum</span><span class="o">);</span>
</span><span class='line'>            <span class="n">collector</span><span class="o">.</span><span class="na">collect</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">result</span><span class="o">);</span>
</span><span class='line'>        <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">run</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="n">JobConf</span> <span class="n">jobConf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JobConf</span><span class="o">(</span><span class="n">getConf</span><span class="o">(),</span> <span class="n">ChainWordCounter</span><span class="o">.</span><span class="na">class</span><span class="o">);</span>
</span><span class='line'>        <span class="n">FileInputFormat</span><span class="o">.</span><span class="na">setInputPaths</span><span class="o">(</span><span class="n">jobConf</span><span class="o">,</span> <span class="k">new</span> <span class="n">Path</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">FileInputFormat</span><span class="o">.</span><span class="na">setInputPaths</span><span class="o">(</span><span class="n">jobConf</span><span class="o">,</span> <span class="k">new</span> <span class="n">Path</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">0</span><span class="o">]));</span>
</span><span class='line'>        <span class="n">Path</span> <span class="n">outputDir</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Path</span><span class="o">(</span><span class="n">args</span><span class="o">[</span><span class="mi">1</span><span class="o">]);</span>
</span><span class='line'>        <span class="n">FileOutputFormat</span><span class="o">.</span><span class="na">setOutputPath</span><span class="o">(</span><span class="n">jobConf</span><span class="o">,</span> <span class="n">outputDir</span><span class="o">);</span>
</span><span class='line'>        <span class="n">outputDir</span><span class="o">.</span><span class="na">getFileSystem</span><span class="o">(</span><span class="n">getConf</span><span class="o">()).</span><span class="na">delete</span><span class="o">(</span><span class="n">outputDir</span><span class="o">,</span> <span class="kc">true</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">JobConf</span> <span class="n">tokenizerMapConf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JobConf</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
</span><span class='line'>        <span class="n">ChainMapper</span><span class="o">.</span><span class="na">addMapper</span><span class="o">(</span><span class="n">jobConf</span><span class="o">,</span> <span class="n">Tokenizer</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">LongWritable</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Text</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Text</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">tokenizerMapConf</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">JobConf</span> <span class="n">upperCaserMapConf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JobConf</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
</span><span class='line'>        <span class="n">ChainMapper</span><span class="o">.</span><span class="na">addMapper</span><span class="o">(</span><span class="n">jobConf</span><span class="o">,</span> <span class="n">UpperCaser</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Text</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Text</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">upperCaserMapConf</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">JobConf</span> <span class="n">reduceConf</span> <span class="o">=</span> <span class="k">new</span> <span class="n">JobConf</span><span class="o">(</span><span class="kc">false</span><span class="o">);</span>
</span><span class='line'>        <span class="n">ChainReducer</span><span class="o">.</span><span class="na">setReducer</span><span class="o">(</span><span class="n">jobConf</span><span class="o">,</span> <span class="n">Reduce</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Text</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">Text</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="n">IntWritable</span><span class="o">.</span><span class="na">class</span><span class="o">,</span> <span class="kc">true</span><span class="o">,</span> <span class="n">reduceConf</span><span class="o">);</span>
</span><span class='line'>
</span><span class='line'>        <span class="n">JobClient</span><span class="o">.</span><span class="na">runJob</span><span class="o">(</span><span class="n">jobConf</span><span class="o">);</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="n">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="kd">throws</span> <span class="n">Exception</span> <span class="o">{</span>
</span><span class='line'>        <span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">ToolRunner</span><span class="o">.</span><span class="na">run</span><span class="o">(</span><span class="k">new</span> <span class="n">Configuration</span><span class="o">(),</span> <span class="k">new</span> <span class="n">ChainWordCounter</span><span class="o">(),</span> <span class="n">args</span><span class="o">);</span>
</span><span class='line'>        <span class="n">System</span><span class="o">.</span><span class="na">exit</span><span class="o">(</span><span class="n">ret</span><span class="o">);</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>不知道什么时候这种机制能够很好地支持新版的API。</p>
]]></content>
  </entry>
  
</feed>
