
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta property="wb:webmaster" content="65cd5fda62d66878" />
  <title>逸言</title>
  <meta name="author" content="张逸">

  
  <meta name="description" content="这两日，我参加了Implementing Domain Driven Disign一书作者Vaughn Vernon组织的IDDD Workshop。培训中，Vernon带领我们针对Domain Event进行了一次建模工作坊。 在领域驱动设计中，Domain Event变得越来越重要。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://agiledon.github.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="逸言" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">



  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">逸言</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:agiledon.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/categories">Categories</a></li>
  <li><a href="/about">About Me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/25/event-modeling-in-ddd/">领域驱动设计中的事件建模</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-25T12:58:00+08:00" pubdate data-updated="true">Sep 25<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/09/25/event-modeling-in-ddd/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这两日，我参加了Implementing Domain Driven Disign一书作者Vaughn Vernon组织的IDDD Workshop。培训中，Vernon带领我们针对Domain Event进行了一次建模工作坊。
<img class="center" src="/images/2014/vernonandme.jpg"></p>

<p>在领域驱动设计中，Domain Event变得越来越重要。在Implementing Domain Driven Disign这本书中，Vaughn Vernon甚至将Domain Event上升到了一等公民的地位。</p>

<p>那么，Domain Event到底是什么？Domain Event即领域事件，是指领域中发生的事实（facts）。当满足某个条件时，某个发起者就会触发事件产生。因而在对事件建模时，我们可以关注统一语言中如下的关键词汇：
<strong>“当…”
“如果发生…”
“当…的时候，请通知我”
“发生…时”</strong></p>

<p>“事件为事实（fact）”这一描述让我对“事件”本身有了更准确的认识。它让我想起两篇发表在InfoQ上的文章。一篇文章为《<a href="http://www.infoq.com/cn/articles/Architecture-Datomic">Datomic的架构</a>》。文中提到：“信息是一组事实（facts），事实是指一些已经发生的事情。鉴于任何人都无法改变过去，这也意味着数据库将累积这些事实，而非原地进行更新。虽然过去可以遗忘，但却是不能改变的。”同理推之，若事件即事实，那么它也是不可改变的。对于这些历史发生的“事实”，我们需要“立此存照”——于是，这就引出了Event Store或者Event Sourcing。我会在后续的文章深入分析Event Store与Event Sourcing。</p>

<p>另一篇文章是徐昊的《<a href="http://www.infoq.com/cn/articles/xh-four-color-modeling">运用四色建模法进行领域分析</a>》。文中表达了类似的思想：“任何的业务事件都会以某种数据的形式留下足迹。我们对于事件的追溯可以通过对数据的追溯来完成。……你无法回到从前去看看到底发生了什么，但是却可以在单据的基础上，一定程度的还原当时事情发生的场景。当我们把这些数据的足迹按照时间顺序排列起来，我们几乎可以清晰的推测出这个在过往的一段时间内到底发生了那些事情。”</p>

<p>在四色建模分析法中，徐昊认为应该将“时标性对象（moment-interval）”作为建模的起点。我在这里并不是要介绍四色建模法，这个话题留待以后再讲。我试图阐释的观点在于，如果事件与时间相关，那么在对事件进行建模时，就可以针对业务场景确定一条时间线，并通过分析业务状态的各种变迁，得到我们希望获得的事件模型。这正是这个工作坊的切入点。</p>

<p>整个事件建模的活动可以分为四个步骤：
1. 选定某个自己熟悉的领域，然后针对时间线去寻找那些用过去时态表现的事件；找到这些事件后，用黄色即时贴写出事件名称，形式如：OrderFilled。
2. 针对每个事件，对触发事件的Command对象进行建模，并用绿色即时贴写出Command的名称。对Command对象进行建模并非单纯地为了寻找Command对象，而是为了更深一步地验证之前建模的事件模型。在思考触发事件的对象时，我们可能会发现一些遗漏又或者多余的事件。
3. 判断这些事件应该属于哪个聚合对象，找到它们，然后写在紫色即时贴上。
4. 对这些识别出来的Event、Command、Aggregate进行分类，判断它们到底属于哪个Bounded Context，并用红色即时贴标出。
<img class="center" src="/images/2014/eventmodeling.jpg"></p>

<p>这种Workshop不仅只针对培训，它更应该运用到团队进行领域驱动设计的过程中。这也正是我一直在提倡的所谓“可视化设计”。可视化设计并非一个噱头，更不是为了美观好看，而是希望以直观简单的形式展现设计思路，尤其需要让整个团队成员都能以协作互动的形式参与到这个设计过程中。群策群力，头脑风暴，如此方能获得更好的设计方案，并以这种团队行为的方式完成知识的共享与传递。其实，“架构”究竟是什么，不就是一种软件设计的知识吗？设计架构，重要在于交流，在于知识传递，而不仅仅是严谨完整的解决方案文档。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/22/understanding-scala-stack/">快速了解Scala技术栈</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-22T15:31:00+08:00" pubdate data-updated="true">Sep 22<span>nd</span>, 2014</time>
        
         | <a href="/blog/2014/09/22/understanding-scala-stack/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我无可救药地成为了Scala的超级粉丝。在我使用Scala开发项目以及编写框架后，它就仿佛凝聚成为一个巨大的黑洞，吸引力使我不得不飞向它，以至于开始背离Java。固然Java 8为Java阵营增添了一丝亮色，却是望眼欲穿，千呼万唤始出来。而Scala程序员，却早就在享受lambda、高阶函数、trait、隐式转换等带来的福利了。</p>

<p>Java像是一头史前巨兽，它在OO的方向上几乎走到了极致，硬将它拉入FP阵营，确乎有些强人所难了。而Scala则不，因为它的诞生就是OO与FP的混血儿——完美的基因融合。</p>

<p>“Object-Oriented Meets Functional”，这是Scala语言官方网站上飘扬的旗帜。这也是Scala的野心，当然，也是Martin Odersky的雄心。</p>

<h2>Scala社区的发展</h2>

<p>然而，一门语言并不能孤立地存在，必须提供依附的平台，以及围绕它建立的生态圈。不如此，语言则不足以壮大。Ruby很优秀，但如果没有Ruby On Rails的推动，也很难发展到今天这个地步。Scala同样如此。反过来，当我们在使用一门语言时，也要选择符合这门语言的技术栈，在整个生态圈中找到适合具体场景的框架或工具。</p>

<p>当然，我们在使用Scala进行软件开发时，亦可以寻求庞大的Java社区支持；可是，如果选择调用Java开发的库，就会牺牲掉Scala给我们带来的福利。幸运的是，在如今，多数情况你已不必如此。伴随着Scala语言逐渐形成的Scala社区，已经开始慢慢形成相对完整的Scala技术栈。无论是企业开发、自动化测试或者大数据领域，这些框架或工具已经非常完整地呈现了Scala开发的生态系统。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/09/22/understanding-scala-stack/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/10/understanding-rdd-of-spark/">理解Spark的核心RDD</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-10T08:54:00+08:00" pubdate data-updated="true">Sep 10<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/09/10/understanding-rdd-of-spark/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img class="center" src="/images/2014/spark_architecture.jpg">
与许多专有的大数据处理平台不同，Spark建立在统一抽象的RDD之上，使得它可以以基本一致的方式应对不同的大数据处理场景，包括MapReduce，Streaming，SQL，Machine Learning以及Graph等。这即Matei Zaharia所谓的“设计一个通用的编程抽象（Unified Programming Abstraction）。这正是Spark这朵小火花让人着迷的地方。</p>

<p>要理解Spark，就需得理解RDD。</p>

<p><strong>RDD是什么？</strong></p>

<p>RDD，全称为Resilient Distributed Datasets，是一个容错的、并行的数据结构，可以让用户显式地将数据存储到磁盘和内存中，并能控制数据的分区。同时，RDD还提供了一组丰富的操作来操作这些数据。在这些操作中，诸如map、flatMap、filter等转换操作实现了monad模式，很好地契合了Scala的集合操作。除此之外，RDD还提供了诸如join、groupBy、reduceByKey等更为方便的操作（注意，reduceByKey是action，而非transformation），以支持常见的数据运算。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/09/10/understanding-rdd-of-spark/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/09/visualize-design-workshop/">可视化设计工作坊</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-09T12:55:00+08:00" pubdate data-updated="true">Aug 9<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/08/09/visualize-design-workshop/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img class="center" src="/images/2014/workshop.jpg">
之所以选择可视化手段来进行软件设计——非UI或UX的设计——是基于我对设计的理解：<strong>设计并非文档，而是交流</strong>。那种依靠一位英雄来完成所有的设计，并编撰为详尽的文档，然后让程序员连蒙带猜按图索骥的设计方式，完全不可取。尤其在一个自组织的开发团队中，我们希望人人都是程序员，人人都是软件设计师，人人都是架构师。</p>

<p>那么，该如何做到充分的交流，就像风吹过树林，不分彼此的摇动每一片树叶？我想到最简单直截的方式：可视化。然而，此可视化非UML之所谓的“一图胜千言”。没错，我们当然需要绘制设计图，而且必须绘制设计图，但我们更希望是以草图的形式，并辅以视觉引导，来推着团队的每个成员，渐进地完善设计，直到抵达设计的真相。我们没有门派偏见，亦不愿邯郸学步，因而我们既信奉“拿来主义”，又会依据设计的本质原则与真谛，进行了细微的创新。创新未必一定是无中生有，“旧瓶装新酒”或是对经典的追随，“新瓶装旧酒”又何尝不能看作是创意的包装！</p>

<p>此次在TID会议上的可视化设计工作坊算是我与姜志辉针对此主题的一次彩排吧。我们从未就此话题有过深度合作，但是，我们对设计的理解是志同道合的，说得肉麻点，有心有灵犀的感觉。下图是整个工作坊的路径缩影：
<img class="center" src="/images/2014/visulaizationdesign.jpg"></p>

<p>我们的主线就是设计的可视化，整个过程我们通过草图、即时贴、画布等多种方式来触发团队成员之间的交流与讨论。至于方法工具箱，则几乎等同于一个大杂烩了。我们使用经典的用例图进行需求分析（我们会以商业画布为需求的起点，因为时间关系省去了此步骤），继而根据用例的边界获得DDD中所谓的Bounded Context。
<img class="center" src="/images/2014/contextmap.jpg"></p>

<p>通过运用DDD的Context Map，我们辨别出Context之间的上下游关系与各种集成方式，继而利用Cockburn的六边形架构以及传统的分层架构，驱动出系统的应用逻辑架构与物理架构。
<img class="center" src="/images/2014/haxagon_workshop.jpg"></p>

<p>然后，我们跳入Context的内部，开始领域建模。我们尝试了两种领域建模方式：健壮性分析与四色建模，以此为起点，我们可以得到粗略的CRC草图，之后就进入了我和姜志辉提出的设计画布。
<img class="center" src="/images/2014/designcanvas.jpg"></p>

<p>我们希望看到的是这样的交流场景，如此才可碰撞出好设计的火花。
<img class="center" src="/images/2014/workshop01.jpg">
<img class="center" src="/images/2014/workshop02.jpg"></p>

<p>可视化设计并非仅能针对一个新系统，或者仅用于设计阶段。</p>

<p>例如，我曾经在客户处通过运用我提出的依赖沉淀图，让团队成员以交流协作的方式完成对遗留系统模块依赖关系的梳理。这种依赖关系梳理虽然可以利用工具来生成，但采用可视化的方式却可以充分保障成员之间的知识共享。它追求的并非只是结果，而是整个协作的过程。又例如，我们也可以在Inception阶段，通过可视化设计来评估风险，或针对候选技术进行Spike，又或者运用六边形架构等方式来梳理系统与周边系统之间的关系，以便于团队理解整个软件产品的生态系统。</p>

<p>其实，这种可视化设计，我更倾向于称之为“体验式设计”，但它与ThoughtWorks提出的XD并非专注同一个层面的内容。当然，这种体验式的软件设计，我还处于试验的摸索阶段。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/05/how-to-implement-ddd/">如何实现领域驱动设计</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-05T19:34:00+08:00" pubdate data-updated="true">Aug 5<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/08/05/how-to-implement-ddd/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img class="center" src="/images/2014/iddd.jpg">
从Eric Evans写下经典名著Domain-Driven Design: Tackling Complexity in the Heart of Software至今，DDD刚好发展了十年的时间。它几乎成了开发复杂软件系统主要的领域设计方法，既是面向对象（组件）设计的补充，又超越了面向对象（组件）设计。DDD中提出的诸多概念如实体、值对象、聚合等，已经成为了耳熟能详的设计术语。DDD社区的发展也如火如荼，似乎并没有被层出不穷的设计思想所取代，相反，它仍在强劲地发展，吸收了许多新的概念与方法，例如函数式编程思想、Event Source、CQRS等。然而，就我个人所观察到的情况来看，许多项目虽然号称应用了DDD设计，但主要都停留在Eric所谓的“战术设计”层面。即使是战术层面，依旧有许多程序员没有弄明白实体与值对象之间的区别，不知道该怎么定义聚合以及聚合根，更谈不上合理地划分上下文（Context）。</p>

<p>我不明白其中内含的真实原因，只能冒昧地揣测是否DDD显得高高在上？究其原因，会否还是Eric惹的祸，他的那本经典之作美则美矣，却显得有些不接地气？至少，我的阅读感受正是如此。虽然在之后，国内也引进了其他一些与DDD相关的著作，例如Jimmy Nilsson的著作《领域驱动设计与模式实战》。这些书好虽好，却并没有全面深入地阐述领域驱动设计，更谈不上完整地实践，直到Vaughn Vernon的《实现领域驱动设计（Implementing Domain-Driven Design）》的出现。</p>

<p>这本书首先吸引我的是书中的第2章至第4章。虽然书中内容几乎忠实地反映了Eric Evans的DDD理论，但作者却创造性地在一开始就着眼于DDD的战略性设计，包括领域（Domain）、子域（Subdomain）、受限上下文（Unbounded Context）、上下文映射（Context Map）以及架构。以第4章架构为例，书中对DDD经典的分层架构进行了深入探讨与分析，并颠覆性地提出将基础设施层（Infrastructure Layer）置于用户接口层（User Interface Layer）之上。最初读来，简直让我莫名惊诧，然而仔细思索，从依赖倒置原则的角度来分析，实在是合乎情理。坦白说，它彻底解决了之前一直纠缠在我心底的一个问题：若我们视实体为Repository以及数据访问的对象，应将实体置于哪一层？在DDD中，实体对象承担了领域业务行为，但同时又可能通过ORM与数据表产生映射。基础设施层的数据访问对象（即传统的DAO）需要调用这些实体对象。若它处于最底层，则会造成业务行为与基础设施的混合。若将实体与数据映射对象分离，既会造成对象之间的重复，又会导致不好的贫血对象。而将基础设施层放在分层架构的上端，非常巧妙地解决了这一问题。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/08/05/how-to-implement-ddd/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/03/test-data-prepare-framework/">测试数据准备框架</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-03T21:25:00+08:00" pubdate data-updated="true">Aug 3<span>rd</span>, 2014</time>
        
         | <a href="/blog/2014/08/03/test-data-prepare-framework/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img class="center" src="/images/2014/sisyphus.jpg"></p>

<p>这是我去年写的一个小框架，专为自动化测试准备数据。以我个人的经验，进行自动化测试尤其是单元测试，除了技能的障碍外，最大的障碍有两点：1)难以解除依赖，因而无法为相关功能编写独立的测试；2)数据准备困难，导致编写测试的成本高。在我的一篇博客《<a href="http://agiledon.github.io/blog/2013/12/25/thought-about-applying-tdd/">推行TDD的思考</a>》中有相关总结。尤其在企业级软件系统中，面对的领域相对复杂，被测接口常常需要输入复杂的数据，然后再返回复杂的数据。在面向对象开发中，这些数据常常被建模为对象。我们该怎么实例化这些对象？在单元测试中，我们常常会引入Builder模式，通过Fluent Interface的方式建立类似DSL的构建接口，以便于自由、流畅而可任意组合的方式，帮助编写测试的人实例化他想要创建的对象。然而，一旦这个对象内嵌了多层，或具有极多的属性时，创建就变得极为艰难了。</p>

<p>在ThoughtWorks的一些项目中，尝试使用Yaml来准备数据。有一个极好的框架snakeyaml可以很好地支持我们处理yaml文件。正是基于此，启发我开发了这样一个小框架Sisyphus。它可以帮助更方便地以各种文件形式来准备数据，并提供了统一的接口。目前，支持的格式为我们最常使用的yaml与json。</p>

<p>框架的开发并没有什么技术含量，但框架提供的功能却是基于实际项目中面临的困难逐步演化出来的。例如框架提供的模板功能，数据分节功能，在一开始并没有想到。正是因为这两个功能，让我觉得这个框架还有一些用处。之所以将这个框架命名为Sisyphus，缘由在于我将测试数据视为西西弗推动的那一块大石头，无法承受的如命运一般的沉重，却又不得不用力去承受，如此往返以致时时刻刻。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/08/03/test-data-prepare-framework/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/01/thoughtworks-china-book/">ThoughtWorks中国区文集出版</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-01T23:25:00+08:00" pubdate data-updated="true">Aug 1<span>st</span>, 2014</time>
        
         | <a href="/blog/2014/08/01/thoughtworks-china-book/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img class="center" src="/images/2014/tw_book.png"></p>

<p>这次参加TID会议，居然看到了这本耗时达3年的书《<a href="http://product.china-pub.com/4243605">软件开发践行录——ThoughtWorks中国区文集</a>》——终于出版了。很早以前，凯峰就提出这个想法，当时他作为InfoQ中文站原创社区的主编，着实策划了不少优秀的原创技术文章。凯峰作为ThoughtWorks的一份子，很好地搭建了ThoughtWorks实践与社区的分享桥梁。不少由TWer撰写的优秀文章陆续在InfoQ发表。然而，从想法到本书出版经历了如此漫长的时间，却也出乎我意料之外。大约一年前，在我提供了个人信息给负责此事的同事后，就没再关心此事，差不多就要淡忘了。如今看到这本漂亮的汇集了中国区TWer心得体会的小书，真是莫名的惊喜啊。就好似那些珍贵的东西你会忘记，却在再次遇见时，忽然发现这种珍贵一点都没有减少。</p>

<p>无论如何，我都为加入ThoughtWorks感到开心而自豪；我也为能有文章选入这本文集而感到荣幸。这是一本散文集，是我们书写在IT边上的日志，又或是一种对技术的诠释与注解，未必必然美丽，却是心灵的一种悸动，一声叹息，是因为技术的狂热而挑动的心弦。这份执着，更是一种美——必然是美！</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/20/scala-resource/">Scala学习资源</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-20T22:17:00+08:00" pubdate data-updated="true">Jul 20<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/07/20/scala-resource/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>网站</h2>

<p>Twitter提供的<a href="http://twitter.github.io/scala_school/zh_cn/basics.html">Scala School</a>：讲解简洁，可以作为快速入门</p>

<p>Twitter编写的如何有效开发Scala的文档——<a href="http://twitter.github.io/effectivescala/index.html">Effective Scala</a></p>

<p>一个非常棒的<a href="http://zh.scala-tour.com">Scala网上教程</a>：可以直接在网页上修改程序和运行程序</p>

<p>很好的<a href="http://www.artima.com/index.jsp">Scala社区网站</a>：只是最近似乎很少更新</p>

<p>当然，不能忘记了Scala的<a href="http://www.scala-lang.org/documentation/">官方网站提供的文档</a>：这或许可以说是最权威的内容，同时，也会提供最新的内容</p>

<p>我自己整理的<a href="https://github.com/agiledon/scala_coding_convention">Scala编码规范与最佳实践</a>：是我结合项目情况并参考相关书籍和文章，以及个人的体会整理的。内容在不断更新中。若愿意贡献一份力量，可以和我联系，我可以加你为Contributor。</p>

<h2>博客</h2>

<p>Alvin Alexander的<a href="http://alvinalexander.com/scala">博客</a>：内有诸多Scala文章，Alvin是Scala Cookbook一书的作者</p>

<p>阿里巴巴Hongjiang的<a href="http://hongjiang.info/scala/">博客</a>：有很多成系列的Scala文章</p>

<h2>视频与教程</h2>

<p>Scala之父Martin Odersky在<a href="https://www.coursera.org/course/progfun">Scala教学视频</a>。你还可以在<a href="http://www.gtan.com/welfare05.html">国内的这个网站</a>上在线观看，在这个网站上，你还能阅读到Akka文档的中文版。</p>

<p>你还可以通过<a href="http://www.typesafe.com/activator">下载Activator</a>，然后通过运行activator，生成各式各样的Scala开发模板（包括Play、Akka、Spray、Spark）。生成的模板有代码和简明教程。</p>

<p>若想更扎实的掌握函数式编程，可以在学习Scala之前，先学习Heskell。
学习<a href="http://learnyouahaskell.com/chapters">Heskell的在线书</a>：写得简洁易懂，很生动。可以作为heskell的入门书籍</p>

<h2>书籍</h2>

<p>如果你希望快速地了解Scala的语法，可以阅读《<a href="http://book.douban.com/subject/19971952/">快学Scala</a>》，即Scala for the I&#8217;mpatient；但是，如果你希望了解真正的Scala精髓，那么奉劝大家不要阅读此书，而应该阅读Scala宝典，由Martin Odersky亲自撰写的著作<a href="http://book.douban.com/subject/3338669/">Programming in Scala</a>。不要阅读此书的中文版，翻译实在糟糕。</p>

<p>如果你想要深入理解Scala的内在机制，可以阅读<a href="http://book.douban.com/subject/6962379/">Scala in Depth</a>；我的同事<a href="http://kaopua.com/blog/">诺铁</a>翻译了此书，即日出版。</p>

<p>如果你想了解更多Scala的案例运用，可以阅读<a href="http://book.douban.com/subject/20876182/">Scala Cookbook</a>。书中提供了大量的案例。</p>

<p>如果你想了解Scala的函数式运用，请阅读Paul Chiusano撰写的<a href="http://book.douban.com/subject/20488750/">Functional Programming in Scala</a>。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/07/using-listbuffer-vs-list/">ListBuffer vs List in Scala</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-07T19:19:00+08:00" pubdate data-updated="true">Jul 7<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/07/07/using-listbuffer-vs-list/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>我们有一个需求，需要在Scala中调用JDBC对数据库进行查询。然后将查询的结果ResultSet放到一个自定义结果类SqlResult中：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">case</span> <span class="k">class</span> <span class="nc">SqlResult</span><span class="o">(</span><span class="n">name</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">],</span> <span class="n">value</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]])</span>
</span></code></pre></td></tr></table></div></figure>


<p>SqlResult的第一个构造函数参数存储的是数据表的列名，第二个参数存储数据表的行记录。由于ResultSet是Java中的一个对象，并不支持Scala的常用集合操作，因此这种转换是有必要的。我引入了隐式类（放在一个package object中）来完成这个转换，在转换过程中，由于需要对ResultSet进行遍历，因而引入了一个结果集List。默认情况下，Scala的List是immutable的，因此将其声明为var：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">package</span> <span class="nn">object</span> <span class="n">db</span> <span class="o">{</span>
</span><span class='line'>     <span class="k">implicit</span> <span class="k">class</span> <span class="nc">ResultSetUtil</span><span class="o">(</span><span class="n">rs</span><span class="k">:</span> <span class="kt">ResultSet</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="k">private</span> <span class="k">val</span> <span class="n">columnCount</span> <span class="k">=</span> <span class="n">rs</span><span class="o">.</span><span class="n">getMetaData</span><span class="o">.</span><span class="n">getColumnCount</span>
</span><span class='line'>
</span><span class='line'>          <span class="k">def</span> <span class="n">rows</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>               <span class="k">var</span> <span class="n">valueList</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">()</span>
</span><span class='line'>               <span class="k">while</span> <span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">next</span><span class="o">())</span> <span class="o">{</span>
</span><span class='line'>                    <span class="k">val</span> <span class="n">oneLine</span> <span class="k">=</span> <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">columnCount</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">getString</span><span class="o">).</span><span class="n">toList</span>
</span><span class='line'>                    <span class="n">valueList</span> <span class="k">=</span> <span class="n">oneLine</span> <span class="o">::</span> <span class="n">valueList</span>
</span><span class='line'>               <span class="o">}</span>
</span><span class='line'>               <span class="n">valueList</span><span class="o">.</span><span class="n">reverse</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>
</span><span class='line'>          <span class="k">def</span> <span class="n">columns</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">String</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>               <span class="o">(</span><span class="mi">1</span> <span class="n">to</span> <span class="n">columnCount</span><span class="o">).</span><span class="n">map</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">getMetaData</span><span class="o">.</span><span class="n">getColumnName</span><span class="o">).</span><span class="n">toList</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>     <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>有了这个隐式转换，操作ResultSet就变简单了：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">query</span><span class="o">(</span><span class="n">sql</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">SqlResult</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">stmt</span> <span class="k">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">createStatement</span><span class="o">()</span>
</span><span class='line'>    <span class="n">rs</span> <span class="k">=</span> <span class="n">stmt</span><span class="o">.</span><span class="n">executeQuery</span><span class="o">(</span><span class="n">sql</span><span class="o">)</span>
</span><span class='line'>    <span class="nc">SqlResult</span><span class="o">(</span><span class="n">rs</span><span class="o">.</span><span class="n">columns</span><span class="o">,</span> <span class="n">rs</span><span class="o">.</span><span class="n">rows</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>由于在前面的实现中，我初始化了一个Immutable的List，因此只能使用::添加每行从ResultSet得到的记录，然后再赋值给valueList。::方法只能将后加入的元素放到List的头部。所以在遍历完毕后，还需要做一个reverse操作。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/07/07/using-listbuffer-vs-list/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/06/18/magic-scala-1-call-by-name/">Magic Scala(1): Call by Name</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-06-18T23:57:00+08:00" pubdate data-updated="true">Jun 18<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/06/18/magic-scala-1-call-by-name/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在Scala中，调用函数有两种形式：Call by value（按值调用）和call by name（按名称调用）。若是call by value，会先计算参数的值，然后再传递给被调用的函数；若是call by name，参数会到实际使用的时候才计算。例如：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">val</span> <span class="n">logEnable</span> <span class="k">=</span> <span class="kc">false</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">log</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>    <span class="k">if</span> <span class="o">(</span><span class="n">logEnable</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'><span class="k">val</span> <span class="nc">MSG</span> <span class="k">=</span> <span class="s">&quot;programing is running&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="n">log</span><span class="o">(</span><span class="nc">MSG</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">0</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>此时的log函数是call by value。因此在调用log函数时，会先计算传入的参数，此时会计算MSG + 1/0。由于表达式中有0作为被除数，因此会抛出异常：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>Exception in thread "main" java.lang.ArithmeticException: / by zero
</span><span class='line'>        at Main$.main(scala-script352098905369979205.scala:16)
</span><span class='line'>        at Main.main(scala-script352098905369979205.scala)
</span><span class='line'>exit value is 1
</span><span class='line'>Program exited.</span></code></pre></td></tr></table></div></figure>


<p>如果修改log的定义为：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">log</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">String</span><span class="o">)</span> <span class="k">=</span>
</span><span class='line'>     <span class="k">if</span> <span class="o">(</span><span class="n">logEnable</span><span class="o">)</span> <span class="n">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>当调用log函数：log(MSG + 1/0)时，它首先并不会计算MSG + 1/0表达式，而是先执行log的函数体，即判断logEnable的值。此时logEnable值为false，此时就不会执行该分支println(msg)。既然不会执行println，就不会计算MSG + 1/0。因此就不会抛出异常。</p>

<p>再看另外一个例子。首先定义一个函数：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">getOneWhatever</span><span class="o">()</span><span class="k">:</span><span class="kt">Int</span> <span class="o">=</span> <span class="o">{</span>
</span><span class='line'>     <span class="n">println</span><span class="o">(</span><span class="s">&quot;calling getOneWhatever&quot;</span><span class="o">)</span>
</span><span class='line'>     <span class="mi">1</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>然后，再定义两个函数，分别用call by value和call by name的方式：</p>

<figure class='code'> <div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">def</span> <span class="n">callByValue</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>     <span class="n">println</span><span class="o">(</span><span class="s">&quot;x1=&quot;</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span>
</span><span class='line'>     <span class="n">println</span><span class="o">(</span><span class="s">&quot;x2=&quot;</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="n">callByName</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="o">=&gt;</span> <span class="nc">Int</span><span class="o">)</span> <span class="k">=</span> <span class="o">{</span>
</span><span class='line'>     <span class="n">println</span><span class="o">(</span><span class="s">&quot;x1=&quot;</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span>
</span><span class='line'>     <span class="n">println</span><span class="o">(</span><span class="s">&quot;x2=&quot;</span> <span class="o">+</span> <span class="n">x</span><span class="o">)</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>如果执行callByValue(getOneWhatever())，则结果为：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>calling getOneWhatever
</span><span class='line'>x1=1
</span><span class='line'>x2=1</span></code></pre></td></tr></table></div></figure>


<p>若执行callByName(getOneWhatever())，则结果为：</p>

<figure class='code'><div class="highlight"><table><tr></td><td class='code'><pre><code class=''><span class='line'>calling getOneWhatever
</span><span class='line'>x1=1
</span><span class='line'>calling getOneWhatever
</span><span class='line'>x2=1</span></code></pre></td></tr></table></div></figure>


<p>注意看二者的区别，采用by name的方式，getOneWhatever函数被执行了两次，这是因为在callByName函数中，传入的参数被调用了两次。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <div align="center">
  	<p><img src="/images/profile/zhangyi03.jpg" align="center"/></p>
  	<p>
    <strong>Company: </strong>ThoughtWorks<br>
  	<strong>Role: </strong>Lead Consultant</p>  
  </div>
  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38898311-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/09/25/event-modeling-in-ddd/">领域驱动设计中的事件建模</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/22/understanding-scala-stack/">快速了解Scala技术栈</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/10/understanding-rdd-of-spark/">理解Spark的核心RDD</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/09/visualize-design-workshop/">可视化设计工作坊</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/05/how-to-implement-ddd/">如何实现领域驱动设计</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/agiledon">@agiledon</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'agiledon',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>

<section>
  <h1>Tag Cloud</h1>
  <ul class="tag-cloud">
<a style="font-size: 100%" href="/blog/tags/agilechina/">AgileChina</a>
<a style="font-size: 155%" href="/blog/tags/akka/">Akka</a>
<a style="font-size: 205%" href="/blog/tags/architecture/">Architecture</a>
<a style="font-size: 155%" href="/blog/tags/big-data/">Big Data</a>
<a style="font-size: 144%" href="/blog/tags/book/">Book</a>
<a style="font-size: 100%" href="/blog/tags/cqrs/">CQRS</a>
<a style="font-size: 144%" href="/blog/tags/csharp/">CSharp</a>
<a style="font-size: 128%" href="/blog/tags/coach/">Coach</a>
<a style="font-size: 171%" href="/blog/tags/coding/">Coding</a>
<a style="font-size: 155%" href="/blog/tags/ddd/">DDD</a>
<a style="font-size: 205%" href="/blog/tags/design/">Design</a>
<a style="font-size: 128%" href="/blog/tags/design-patterns/">Design Patterns</a>
<a style="font-size: 128%" href="/blog/tags/dotnet/">DotNET</a>
<a style="font-size: 128%" href="/blog/tags/dotnet/">DotNet</a>
<a style="font-size: 100%" href="/blog/tags/go/">GO</a>
<a style="font-size: 100%" href="/blog/tags/geek/">Geek</a>
<a style="font-size: 100%" href="/blog/tags/guava/">Guava</a>
<a style="font-size: 100%" href="/blog/tags/hdfs/">HDFS</a>
<a style="font-size: 144%" href="/blog/tags/hadoop/">Hadoop</a>
<a style="font-size: 128%" href="/blog/tags/infoq/">InfoQ</a>
<a style="font-size: 177%" href="/blog/tags/java/">Java</a>
<a style="font-size: 100%" href="/blog/tags/language/">Language</a>
<a style="font-size: 155%" href="/blog/tags/literature/">Literature</a>
<a style="font-size: 128%" href="/blog/tags/mvc/">MVC</a>
<a style="font-size: 100%" href="/blog/tags/mapreduce/">MapReduce</a>
<a style="font-size: 128%" href="/blog/tags/mock/">Mock</a>
<a style="font-size: 100%" href="/blog/tags/mysql/">MySQL</a>
<a style="font-size: 128%" href="/blog/tags/notes/">Notes</a>
<a style="font-size: 128%" href="/blog/tags/novel/">Novel</a>
<a style="font-size: 100%" href="/blog/tags/nutch/">Nutch</a>
<a style="font-size: 155%" href="/blog/tags/oo/">OO</a>
<a style="font-size: 144%" href="/blog/tags/octopress/">Octopress</a>
<a style="font-size: 128%" href="/blog/tags/photo/">Photo</a>
<a style="font-size: 128%" href="/blog/tags/rest/">REST</a>
<a style="font-size: 195%" href="/blog/tags/reading/">Reading</a>
<a style="font-size: 155%" href="/blog/tags/reading-radar/">Reading Radar</a>
<a style="font-size: 164%" href="/blog/tags/refactoring/">Refactoring</a>
<a style="font-size: 144%" href="/blog/tags/responsibility/">Responsibility</a>
<a style="font-size: 128%" href="/blog/tags/ruby/">Ruby</a>
<a style="font-size: 205%" href="/blog/tags/scala/">Scala</a>
<a style="font-size: 100%" href="/blog/tags/scalability/">Scalability</a>
<a style="font-size: 144%" href="/blog/tags/spark/">Spark</a>
<a style="font-size: 128%" href="/blog/tags/spray/">Spray</a>
<a style="font-size: 100%" href="/blog/tags/struts/">Struts</a>
<a style="font-size: 164%" href="/blog/tags/tdd/">TDD</a>
<a style="font-size: 100%" href="/blog/tags/thinking/">Thinking</a>
<a style="font-size: 128%" href="/blog/tags/thought/">Thought</a>
<a style="font-size: 164%" href="/blog/tags/thoughtworks/">ThoughtWorks</a>
<a style="font-size: 100%" href="/blog/tags/transaltion/">Transaltion</a>
<a style="font-size: 128%" href="/blog/tags/visualization/">Visualization</a>

  </ul>
</section>

<section>
  <h1>Visitor</h1>
  <div><a href="https://www.google.com/analytics/web/?hl=zh-CN#savedreport/-74rj-TaSR2-OlraMB4ZZQ/a38898311w67651546p69626158/%3F_r.dsa%3D1%26_.advseg%3D%26_.sectionId%3D/" target="_blank"><img src="/images/googleanalytics.png"/></a></div>
    <div id="clustrmaps-widget"></div><script type="text/javascript">var _clustrmaps = {'url' : 'http://agiledon.github.com', 'user' : 1081379, 'server' : '4', 'id' : 'clustrmaps-widget', 'version' : 1, 'date' : '2013-02-27', 'lang' : 'en', 'corners' : 'square' };(function (){ var s = document.createElement('script'); s.type = 'text/javascript'; s.async = true; s.src = 'http://www4.clustrmaps.com/counter/map.js'; var x = document.getElementsByTagName('script')[0]; x.parentNode.insertBefore(s, x);})();</script><noscript><a href="http://www4.clustrmaps.com/user/63d108023"><img src="http://www4.clustrmaps.com/stats/maps-no_clusters/agiledon.github.com-thumb.jpg" alt="Locations of visitors to this page" /></a></noscript>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - 张逸 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'agiledon';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
