
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta property="wb:webmaster" content="65cd5fda62d66878" />
  <title>简单文本</title>
  <meta name="author" content="张逸">

  
  <meta name="description" content="今天，微信群“改变自己”发布了一篇张辉的文章《一个人的旅程：逃离舒适圈》——之所以选择一个人从北京到拉斯维加斯，就是希望挑战一下自己的孤独和不安感觉。读到这篇文章，让我想起自己的一次远行，何其相似。当我只有一个人面对一个陌生环境时，我也常常会陷入一种焦虑不安的情绪之中。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://agiledon.github.com/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="简单文本" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<!--<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css"> -->
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">



  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">简单文本</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:agiledon.github.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/categories">Categories</a></li>
  <li><a href="/about">About Me</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/01/17/jump-out-of-comfort-zone/">跳出舒适区</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-01-17T20:31:00+08:00" pubdate data-updated="true">Jan 17<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/01/17/jump-out-of-comfort-zone/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天，微信群“改变自己”发布了一篇张辉的文章《一个人的旅程：逃离舒适圈》——之所以选择一个人从北京到拉斯维加斯，就是希望挑战一下自己的孤独和不安感觉。读到这篇文章，让我想起自己的一次远行，何其相似。当我只有一个人面对一个陌生环境时，我也常常会陷入一种焦虑不安的情绪之中。区别只在于张辉的一个人旅程是主动选择，而我则是迫于无奈。</p>

<p>那是在前年，我自己一人独自上路，乘坐从北京到布里斯本（Brisbane）的飞机。飞机经由香港转机到布里斯本，而在之前还要在凯恩斯（Keynes）做短暂停留。
<img class="center" src="images/2014/airport.jpg"></p>

<p>问题就出在这里，我一直以为在香港转机后，是直飞布里斯本。所以当飞机即将到达凯恩斯时，听到通知凯恩斯即将到达的广播时，就开始了自己的纠结：我是否坐错了飞机呢？实在按奈不住，终于忍不住问询了旁边的一位菲律宾人，得到完全无误的确认后，我才长舒了一口气。那种纠结真是折磨，虽然在理智上认为这种错误不可能发生，可是心里总是放却不下。当我走出布里斯本机场，上了公司派来接我的汽车后，似乎整个人才彻底轻松下来，开始与司机聊起布里斯本那美丽的景色来。同样是语言不通，同样是陌生人，飞机上的我格外地拘束，而坐在这白人小伙的车上，突然就变得自如了许多，就好似被压抑的洪水，一下子冲出了闸门。</p>

<p>一个人非得要经历一些陌生事物，陌生景色，才会慢慢变得硬线条，粗神经，降低对周遭环境的敏感度。只有如此，才能变得更加适应这个社会。我记得第一次出国到洛杉矶，相对于兴奋，更显得紧张和不安。可惜那一次因为是与同事同行，缺乏了一次绝佳的锻炼机会。工作之余，我们几个人一起租车到棕榈泉，到拉斯维加斯，到胡佛大坝。因为同行还有一位美国同事，所以很多事情都已安排好，自己完全不用费心考虑。
<img class="center" src="images/2014/palmspring.JPG"></p>

<p><img class="center" src="images/2014/lasvagas.jpg"></p>

<p><img class="center" src="images/2014/dam.jpg"></p>

<p>到布里斯本的一次，让我体味到寂寞孤独的同时，也让我心智成熟了许多。仔细思考，这种独自一人的旅行或许并不能让你收获什么知识，但它就像醍醐灌顶一般，不知不觉就打通了你的任督二脉。你突然会变得独立，变得勇敢，变得对陌生无畏。于是在布里斯本，我开始习惯在周末独自一人在布里斯本街头闲逛，在布里斯本河畔的餐馆就餐，到Queen Street的超市去购物，到Wedding Lawn看那些新人们举行婚礼，到South Bank体味艺术的人文气味；最后趁着复活节的空闲，独自一人去了一趟悉尼。我想，以后再将我扔到某个陌生环境，我至少不会恐惧了，我会学着正确地面对。
<img class="center" src="images/2014/brisbanebridge.jpg"></p>

<p><img class="center" src="images/2014/sbank.jpg"></p>

<p><img class="center" src="images/2014/southbank.jpg"></p>

<p>这正是我为何在去年要申请离开Office的项目出外做咨询，为何希望作为Coach申请到印度参加TWU。我希望尝试一些新东西，试着给自己一些挑战，这在我司，一个流行说法就是“跳出舒适区”。在一个熟悉的环境，每天面对熟悉的人，做着熟悉的事情，久而久之，自己的行为就会被惯性推动，然后成为习惯，产生惰性。这就好似在一个重力场一般，只要重力发生一丁点改变，我们的身体都会敏感的察觉，并通过神经中枢系统传达这种不适意。然而一旦熟悉了这种重力，我们在这样的重力场中的任何行为都会变得轻松自如。一旦重力再一次改变，即使是调整到之前的值，身体仍然需要做再一次调整。</p>

<p>只有不断地调整才能让自己不断的进步。从去年9月至现在，我在客户处经历了两个咨询项目，体验了许多与交付项目完全不同的经历和压力，学到了很多知识，能力也得到了很大提高，显然也增强了我的自信心。尤其是当咨询项目完成一个阶段时，看到客户在我的影响下向好的方向发生改变，工作效率和开发质量得到很大的提高，这种成就感是无与伦比的。</p>

<p>去年因为咨询项目的缘故，印度之行最后还是泡汤了。孤身一人到印度，然后与各个国家的TWer沟通，那种压力会更大吧。若能再跳出现在这个舒适区挑战一下自己，一定受益匪浅吧。所以今年，我还要再次申请到印度的机会！</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/01/16/actor-and-its-supervisors-of-akka/">Akka的Actor及其Supervisors</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-01-16T20:29:00+08:00" pubdate data-updated="true">Jan 16<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/01/16/actor-and-its-supervisors-of-akka/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>声明：本文主要内容来源于Akka官方网站的Akka Scala Documentation文档。</p>

<h2>Actor的Best Practice</h2>

<p>在文档16页，给出了Actor的Best Practice，包括：</p>

<ul>
<li>Actor应是一个好的协作者；</li>
<li>不要在Actor之间传递可变对象；</li>
<li>Actor是行为与状态的容器；这意味着状态与行为应封装在Message中；</li>
<li>顶级Actor是Error Kernel最内部的一部分，这有利于错误处理。</li>
</ul>


<h2>Actor</h2>

<p>17页定义了Actor：</p>

<blockquote><p>An actor is a container for State, Behavior, a Mailbox, Children and a Supervisor Strategy.</p></blockquote>

<p>Actor对象可以分为内部与外部，外部以引用方式传递。这使得我们可以重启Actor而无需更新任何地方的引用（这是指内部的重启）；可以将实际的Actor对象放在远端主机；可以发送消息给完全不同应用程序的Actor。</p>

<p>Actor状态可以是显式的状态机（例如使用FSM模块）或者计数器、一组侦听器、待处理的请求等。从概念上讲，每个Actor都拥有属于自己的轻量级线程，保护它不会被系统的其余部分影响。我们在编写Actor时，就不用担心并发。</p>

<p>每个Actor都有一个(恰好一个)Mailbox，所有Sender会将消息入队到Mailbox中。入队的顺序按照消息发送的时间顺序。Mailbox有多种实现，默认为FIFO。但也可以根据优先级考虑出队顺序，实现算法则不相同。</p>

<p>AKKA与其他Actor模型不同的是：当前的行为总是会处理下一个出队的消息，而不会去扫描Mailbox，获得下一个匹配的消息。因此，当处理消息失败，就会认为是失败，除非这个行为被重写了。</p>

<p>每个Actor都是一个潜在的Supervisor：如果该Actor创建了一个Child去执行子任务，就会自动来管理这些Child。Children的列表放在Actor的Context中，Actor可以访问他们。创建或停止的操作分别为：
Liquid error: invalid byte sequence in US-ASCII</p>

<p>看起来，这种变更会实时反映出来；但事实上是以异步的方式在后台执行，它并不会阻塞Supervisor。</p>

<p>Supervisor处理失败场景的策略在创建Actor时就被确定，因而在Actor创建之后不能改变。一个Actor只有一个策略，因此，如不同的策略被运用到Actor的不同Child，就会被分组，会按照策略去匹配Supervisor，而非构建时的分类。</p>

<p>一旦Actor被终止，就会释放资源。在其Mailbox中的消息会被转发给系统的“dead letter mailbox”；然后该Mailbox会被替换为系统的Mailbox。所有新发来的消息也会作为Dead letter转发到系统的Mailbox。可以向Event Bus注册一个TestEventListener，监听dead letter的转发。这样就可以对错误写日志。</p>

<hr />

<h2>Supervision</h2>

<p>Supervisor会将任务委派给下级（subordinate），并能响应这些下级的失败。若下级侦测到失败（例如抛出异常），就要暂停它自身以及它的所有下级，并发送消息给它的Supervisor，以标识该失败。这时，Supervisor有四种选择：</p>

<ul>
<li>重新获得（Resume）下级，并保持其累加的内部状态；</li>
<li>重新启动（Restart）下级，清除其累加的内部状态；</li>
<li>永久地终止下级；</li>
<li>扩大（Escalate）失败，从而使得自身也失败。</li>
</ul>


<p><strong>重要的一点是要认识到一个Actor就是Supervision层次的一部分。</strong></p>

<p>对于Actor类的hook方法preRestart()默认行为是在重启（restarting）之前，是终止所有的children（这个过程是递归的）。但是，该方法可以被重写。</p>

<h2>Top-Level Supervisors</h2>

<p>一个Actor系统在创建之初，至少有三个Actor，如下图所示：
<img class="center" src="images/2014/supervisor.png"></p>

<p><strong>1.The Guardian Actor</strong></p>

<p>它是用户创建的Actor的parent，命名为“/user”。使用system.actorOf()方法创建的Actor都是它的children。这意味着只要这个Actor终止了，系统中所有常规的Actor都会被关掉。在Akka 2.1中，可以设置Supervisor Strategy，配置项为akka.actor.guardian-supervisor-strategy，对应类名为SupervisorStrategyConfigurator。倘若这个Guardian Actor扩大了失败，按照前面描述的Supervisor策略，它会使得root guardian终止该Actor，从而使得这个Actor下的所有子Actor都停止，即关掉了整个Actor系统。</p>

<p><strong>2.The System Guardian</strong></p>

<p>名为“/system&#8221;。主要是为了在常规Actor被终止时，做到按序的shut-down顺序。它可以监控User Guardian。可以管理Top-Level的System Actor采用一种策略，可以在除了ActorInitializationException与ActorKilledException之外的异常出现时，无限制地重启它。</p>

<p><strong>3.The Root Guardian</strong></p>

<p>由于每个真正的Actor都有一个supervisor，因此，root guardian的supervisor不是一个真正的Actor。</p>

<p>当出现如下三类失败错误时，就可能Restart Actor：</p>

<ul>
<li>在收到特定消息时，发生系统错误，如编程的错误；</li>
<li>在处理消息时，因为一些外部资源的原因出现错误；</li>
<li>Actor的内部状态出现问题</li>
</ul>


<p>Restart的过程：</p>

<ol>
<li>暂停Actor（这意味着在Restart期间，不会处理常规的消息，直到它被Resume）。同时，还会递归地暂停所有的children；</li>
<li>调用旧实例的preRestart钩子方法（默认情况下，会发送终止消息给所有children，调用children的postStop()）。</li>
<li>等待所有的children被终止（调用context.stop()）。这个过程是非阻塞的；</li>
<li>通过调用原来提供的工厂去创建新的Actor实例；</li>
<li>调用新实例的postRestart()方法（默认情况下，仍然要先调用preStart()）；</li>
<li>将restart的请求发送给执行第3步时没有被kill掉的children；然后遵循第2步递归地对children执行restart；</li>
<li>resume actor。</li>
</ol>


<h2>Lifecycle Monitoring</h2>

<p>对于Monitoring而言，能监控的状态就是alive到dead之间的迁移。因此，在Akka中，Lifecycle Monitoring指的就是DeathWatch。Monitoring主要指的是监控其他的Actor，而非Supervision层次中的Actor。</p>

<p>监控的Actor（Monitoring Actor）如果接受到一条Terminated消息，默认行为就会抛出DeathPactException。要侦听Terminated消息，可以调用ActorContext.watch(targetActorRef)；停止监听则调用ActorContext.unwatch(targetActorRef)。</p>

<p>如果Supervisor不能简单地重启其Children，又必须终止他们，例如在初始化Actor时出现了错误，就可以使用Monitoring。此时，可以侦听这些children，然后重新创建他们，或者安排时间重试。</p>

<p>使用Monitoring的另一种常见情形是，在缺乏外部资源，且该外部资源属于该Actor的一个children，Actor需要失败。如果第三方通过system.stop(child)或者发送PoisonPill去终止child，supervisor就会受到影响。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/01/13/testing-styles-of-scalatest/">ScalaTest的测试风格</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-01-13T18:39:00+08:00" pubdate data-updated="true">Jan 13<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/01/13/testing-styles-of-scalatest/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>ScalaTest几乎已经成为Scala语言默认的测试框架，而在JVM平台下，无论是否使用Scala进行开发，我认为仍有尝试ScalaTest的必要。这主要源于它提供了多种表达力超强的测试风格，能够满足各种层次的需求包括单元测试、BDD、验收测试、数据驱动测试。正如ScalaTest的创建者Bill Venners所说：</p>

<blockquote><p>A guiding design principle of ScalaTest is that different people on a team should be able look at each others test code and know immediately what&#8217;s going on.</p>

<p>ScalaTest is designed to make it easy for you to customize your testing tool to meet your current needs, and for the built-in traits at least, make it easy for anyone who comes along later to read and understand your code.</p></blockquote>

<h2>UT与IT的风格选择</h2>

<p>ScalaTest一共提供了七种测试风格，分别为：FunSuite，FlatSpec，FunSpec，WordSpec，FreeSpec，PropSpec和FeatureSpec。这就好像使用相同的原料做成不同美味乃至不同菜系的佳肴，你可以根据自己的口味进行选择。以我个人的偏好来看，我倾向于选择FlatSpec或FunSpec(类似Ruby下的RSpec)来编写单元测试与集成测试。虽然FunSuite的方式要更灵活，而且更符合传统测试方法的风格，区别仅在于test()方法可以接受一个闭包，但坏处恰恰就是它太灵活了。而FlatSpec和FunSpec则通过提供诸如it、should、describe等方法，来规定书写测试的一种模式，例如前者明显的<em>“主-谓-宾”结构</em>，后者清晰的<strong>分级式结构</strong>，都可以使团队的测试更加规范。如下是ScalaTest官方网站的提供的FunSuite、FlatSpec和FunSpec的三种风格样例。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="c1">//FunSuite</span>
</span><span class='line'><span class="k">import</span> <span class="nn">org.scalatest.FunSuite</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">SetSuite</span> <span class="k">extends</span> <span class="nc">FunSuite</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">test</span><span class="o">(</span><span class="s">&quot;An empty Set should have size 0&quot;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">assert</span><span class="o">(</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>      <span class="n">test</span><span class="o">(</span><span class="s">&quot;Invoking head on an empty Set should produce NoSuchElementException&quot;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">intercept</span><span class="o">[</span><span class="kt">NoSuchElementException</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>          <span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">.</span><span class="n">head</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//FlatSpec</span>
</span><span class='line'><span class="k">import</span> <span class="nn">org.scalatest.FlatSpec</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">SetSpec</span> <span class="k">extends</span> <span class="nc">FlatSpec</span> <span class="o">{</span>
</span><span class='line'>  <span class="s">&quot;An empty Set&quot;</span> <span class="n">should</span> <span class="s">&quot;have size 0&quot;</span> <span class="n">in</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">assert</span><span class="o">(</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>      <span class="n">it</span> <span class="n">should</span> <span class="s">&quot;produce NoSuchElementException when head is invoked&quot;</span> <span class="n">in</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">intercept</span><span class="o">[</span><span class="kt">NoSuchElementException</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>          <span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">.</span><span class="n">head</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="c1">//FunSpec</span>
</span><span class='line'><span class="k">import</span> <span class="nn">org.scalatest.FunSpec</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">SetSpec</span> <span class="k">extends</span> <span class="nc">FunSpec</span> <span class="o">{</span>
</span><span class='line'>  <span class="n">describe</span><span class="o">(</span><span class="s">&quot;A Set&quot;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="n">describe</span><span class="o">(</span><span class="s">&quot;when empty&quot;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>          <span class="n">it</span><span class="o">(</span><span class="s">&quot;should have size 0&quot;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">assert</span><span class="o">(</span><span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>                  <span class="n">it</span><span class="o">(</span><span class="s">&quot;should produce NoSuchElementException when head is invoked&quot;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>              <span class="n">intercept</span><span class="o">[</span><span class="kt">NoSuchElementException</span><span class="o">]</span> <span class="o">{</span>
</span><span class='line'>                  <span class="nc">Set</span><span class="o">.</span><span class="n">empty</span><span class="o">.</span><span class="n">head</span>
</span><span class='line'>              <span class="o">}</span>
</span><span class='line'>          <span class="o">}</span>
</span><span class='line'>      <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>至于WordSpec和FreeSpec，要么太复杂，要么可读性稍差，要么惯用法风格有些混杂，个人认为都不是太好的选择，除非你已经习惯了这种风格。</p>

<h2>数据驱动测试风格</h2>

<p>JUnit对类似表数据的Fixture准备提供了Parameterized支持，但非常不直观，而且还需要为测试编写构造函数，然后定义一个带有@Parameters标记的静态方法。TestNG的DataProvider略好，但通过在测试方法上指定DataProvider的方式，仍然不尽如人意。ScalaTest提供的PropSpec充分利用了Scala函数式语言的特性，使得代码更简单，表达性也更强：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">org.scalatest._</span>
</span><span class='line'><span class="k">import</span> <span class="nn">prop._</span>
</span><span class='line'><span class="k">import</span> <span class="nn">scala.collection.immutable._</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">SetSpec</span> <span class="k">extends</span> <span class="nc">PropSpec</span> <span class="k">with</span> <span class="nc">TableDrivenPropertyChecks</span> <span class="k">with</span> <span class="nc">Matchers</span> <span class="o">{</span>
</span><span class='line'>  <span class="k">val</span> <span class="n">examples</span> <span class="k">=</span>
</span><span class='line'>    <span class="nc">Table</span><span class="o">(</span>
</span><span class='line'>      <span class="s">&quot;set&quot;</span><span class="o">,</span> <span class="nc">BitSet</span><span class="o">.</span><span class="n">empty</span><span class="o">,</span> <span class="nc">HashSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">],</span> <span class="nc">TreeSet</span><span class="o">.</span><span class="n">empty</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span>
</span><span class='line'>    <span class="o">)</span>
</span><span class='line'>  <span class="n">property</span><span class="o">(</span><span class="s">&quot;an empty Set should have size 0&quot;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">forAll</span><span class="o">(</span><span class="n">examples</span><span class="o">)</span> <span class="o">{</span> <span class="n">set</span> <span class="k">=&gt;</span>
</span><span class='line'>      <span class="n">set</span><span class="o">.</span><span class="n">size</span> <span class="n">should</span> <span class="n">be</span><span class="o">(</span><span class="mi">0</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'>  <span class="n">property</span><span class="o">(</span><span class="s">&quot;invoking head on an empty set should produce NoSuchElementException&quot;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">forAll</span><span class="o">(</span><span class="n">examples</span><span class="o">)</span> <span class="o">{</span> <span class="n">set</span> <span class="k">=&gt;</span>
</span><span class='line'>      <span class="n">a</span> <span class="o">[</span><span class="kt">NoSuchElementException</span><span class="o">]</span> <span class="n">should</span> <span class="n">be</span> <span class="n">thrownBy</span> <span class="o">{</span> <span class="n">set</span><span class="o">.</span><span class="n">head</span> <span class="o">}</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>验收测试风格</h2>

<p>我们会推荐由PO（或者需求分析人员BA）与测试人员结对编写验收测试的业务场景，然后由开发人员和测试人员结对实现该场景。Cocumber、JBehave、Twist乃至Robot、Fitness都可以用于编写这样的验收测试（Fitness与Robot更接近实例化需求的方式）。这些工具有一个特点是业务场景与测试支持代码完全是分开的。例如Cucumber将业务场景放到feature文件中，而将测试支持代码放到rb文件中。JBehave类似。这样的好处是feature文件很干净，很纯粹，与技术实现没有任何关系，且有利于生成Living Document。然而，这种分离方式在带来良好可读性的同时，也带来维护成本的增加。</p>

<p>ScalaTest在提供类似Feature的验收测试Spec时，并没有将业务场景与测试支持代码分开，而是采用了混合的方式来表现：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr></td><td class='code'><pre><code class='scala'><span class='line'><span class="k">import</span> <span class="nn">org.scalatest.</span><span class="o">{</span><span class="nc">ShouldMatchers</span><span class="o">,</span> <span class="nc">GivenWhenThen</span><span class="o">,</span> <span class="nc">FeatureSpec</span><span class="o">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">TVSetTest</span> <span class="k">extends</span> <span class="nc">FeatureSpec</span> <span class="k">with</span> <span class="nc">GivenWhenThen</span> <span class="k">with</span> <span class="nc">ShouldMatchers</span><span class="o">{</span>
</span><span class='line'>  <span class="n">info</span><span class="o">(</span><span class="s">&quot;As a TV Set owner&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="n">info</span><span class="o">(</span><span class="s">&quot;I want to be able to turn the TV on and off&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="n">info</span><span class="o">(</span><span class="s">&quot;So I can watch TV when I want&quot;</span><span class="o">)</span>
</span><span class='line'>  <span class="n">info</span><span class="o">(</span><span class="s">&quot;And save energy when I&#39;m not watching TV&quot;</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">feature</span><span class="o">(</span><span class="s">&quot;TV power button&quot;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>    <span class="n">scenario</span><span class="o">(</span><span class="s">&quot;User press power button when TV is off&quot;</span><span class="o">)</span> <span class="o">{</span>
</span><span class='line'>      <span class="nc">Given</span><span class="o">(</span><span class="s">&quot;a TV set that is switched off&quot;</span><span class="o">)</span>
</span><span class='line'>      <span class="k">val</span> <span class="n">tv</span> <span class="k">=</span> <span class="k">new</span> <span class="nc">TVSet</span>
</span><span class='line'>      <span class="n">tv</span><span class="o">.</span><span class="n">isOn</span> <span class="n">should</span> <span class="n">be</span> <span class="o">(</span><span class="kc">false</span><span class="o">)</span>
</span><span class='line'>
</span><span class='line'>      <span class="nc">When</span><span class="o">(</span><span class="s">&quot;The power button is pressed&quot;</span><span class="o">)</span>
</span><span class='line'>      <span class="n">tv</span><span class="o">.</span><span class="n">pressPowerButton</span>
</span><span class='line'>
</span><span class='line'>      <span class="nc">Then</span><span class="o">(</span><span class="s">&quot;The TV should switch on&quot;</span><span class="o">)</span>
</span><span class='line'>      <span class="n">tv</span><span class="o">.</span><span class="n">isOn</span> <span class="n">should</span> <span class="n">be</span> <span class="o">(</span><span class="kc">true</span><span class="o">)</span>
</span><span class='line'>    <span class="o">}</span>
</span><span class='line'>  <span class="o">}</span>
</span><span class='line'><span class="o">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>ScalaTest的FeatureSpec支持常见的Given-When-Then模式。在上面的代码段中，info提供了对Feature的基本描述，然后提供了feature与scenario两个层级。熟悉Cucumber和JBehave的人对此应该不会陌生。测试支持代码直接写在Given、When、Then方法下，因而针对同一个Feature，只产生一个scala文件。这就意味着测试支持代码与自然语言描述是处于同一级的，准确地说，他们其实就属于同一个测试。开发时，PO（或者需求）与测试可以先编写FeatureSpec的骨架，即info-feature-scenario以及Given-When-Then部分。一旦编写好这个FeatureSpec，就可以提交到版本管理库。当开发人员与需求、测试一起Kick Off要做的Story时，就可以根据这个FeatureSpec进行，然后，要求开发人员在完成Story的实现前，与测试结对完成它的测试实现代码。</p>

<p>由于ScalaTest还提供了Tag等功能，我们还可以通过对测试提取基类或者Trait有效地对这些测试进行重用，保证测试代码的可维护性。由于只需要维护一个scala，成本会降低许多，也不需要在业务场景和测试支持代码之间跳转，降低维护的难度。唯一的缺点是它天然不支持Living Document。但是我们发现这些自然语言描述实则都集中在FeatureSpec提供的方法中，我们完全可以自行开发工具或插件，完成对场景描述以及步骤的提取，生成我们需要的文档。</p>

<p>目前，我的同事杨云已经将ScalaTest作为编写验收测试的工具引入到项目中。受他启发，在我当前的项目中也选择使用了ScalaTest作为验收测试的框架。考虑到IDE支持尤其是重构等方面的工具支持，以及构建中对测试运行、测试覆盖率检查等的支持，目前我并没有考虑在单元测试和集成测试中使用ScalaTest。之所以如此，还是源于对成本与收益的考量。</p>

<p><strong>说明：</strong>文章的代码片段全部来自ScalaTest官方网站。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/01/11/excerpt-from-barone-rampante/">摘录《树上的男爵》</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-01-11T19:32:00+08:00" pubdate data-updated="true">Jan 11<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/01/11/excerpt-from-barone-rampante/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img class="center" src="/images/2014/barone_rampante.jpeg"></p>

<p>卡尔维诺《树上的男爵》书写了这么一段难以言说、无可名状的美丽的段落，让我惊叹，甚至是那种心悸的喜悦。这样的笔下的景色，仿佛让我身临其境，又似乎另有一种魔力，如夕阳之下各色景观都涂上了一层金色的光亮。这一段落并非那种精致的美，但却自有一种纤细与磅礴，很奇怪的矛盾杂糅，然后蹦出一种奇异的美。</p>

<blockquote><p>他的天地已经变了，这是一个由架在空中的细长而弯曲的桥，由粗糙树皮上的结节、瘤子和皱褶，由透过或疏或密的树叶挡起的帷幕而变幻着深浅的绿色阳光组成的世界，微风一吹，树叶的柄就抖动不已，而当树干摇摆时整棵树的叶子就像一方纱巾飘动起来。而我们的世界呢，是平贴在地面上的，我们看到的是比例失调的形象，我们当然不理解他在那上面的感受。夜里他倾听着树木如何用它的细胞在树干里记下代表岁月的年轮，树霉如何在北风中扩大斑点，在窝里熟睡的小鸟瑟缩着将脑袋钻进最暖和的翅膀下的羽毛里，毛毛虫蠕动，伯劳鸟腹中的蛋孕育成功。有的时候，原野静悄悄，耳膛内只有细微的响动，一声粗号，一声尖叫，一阵野草迅疾瑟瑟声，一阵流水淙淙响，一阵踏在泥土和石子上的蹄声，而蝉鸣声高出一切之上。响声一个接一个消失，听觉不断辨别出新的声音，就像那拆着一团毛线的手指，感觉到每根毛线变得越来越细，细得几乎感触不到了。同时青蛙一直在鸣唱，作为一种背景并不影响其它声音的传播，如同太阳光不因星星的不断闪烁而起变化。相反，每当风吹起或吹过，每一种声音都会起变化并成为新的声音，留在耳膛内最深处的只有隐隐约约的呼啸声或低吟声，那是大海。</p></blockquote>

<p>要多么细致的观察，多么敏感的心灵，与大自然的脉搏一起跳动，放开身体的所有触觉、嗅觉与视觉，才能从灵魂中涌现出这样的文字，最后再借助一只魔笔润色，天然地凸显出来，就好像它自天地诞生以来一直就存在，只是从未有人发现，偶然的，被在天地之间嬉戏的卡尔维诺发现了。是的，是被发现了，而不是创作出来了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/01/10/reading-the-captive-mind/">读《被禁锢的头脑》</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-01-10T22:24:00+08:00" pubdate data-updated="true">Jan 10<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/01/10/reading-the-captive-mind/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p><img class="center" src="/images/2014/captivemind.jpg">
米沃什在《被禁锢的头脑》中，描述了战时东欧的白色恐怖：</p>

<blockquote><p>此时带着套马索的骑马者就会出现。那就是‘囚车’，即停在街角，用帆布遮盖着的大卡车。行人根本预见不到那里会有危险，当他们路过那个街角时，会突然感觉有一支枪顶住他。它也许会被关进集中营，或者会被推到墙下，用胶布封上嘴巴以防止他喊出反对占领国的口号，然后就被枪毙。这一切都令城市居民心惊胆战，迫使他们俯首帖耳。为了避免这种不幸，最好的办法就是足不出户。但是作为一家之主的父亲必须外出挣钱，弄点供养他的妻儿老小的面包和菜汤。每到晚上，家里人就开始心绪不宁，担心父亲是否还回得来。这种情况已经持续多年，所以人们渐渐觉得他们居住的这座城市简直就是危机四伏的原始森林，20世纪人的命运，与那些每天跟毒蛇猛兽作生死搏斗的穴居人的命运没什么两样。</p></blockquote>

<p>没有经历过这种生活的人阅读这样的文字，仍然可以体会那种惶惶的恐怖，这种恐慌如慢性毒药一般啃啮人的心灵。与其这般在极大恐惧中担惊受怕，过着如丧家犬的生活，不知什么时候会抛尸街头或者入牢笼中受非人的折磨，真还不如扛起枪冲出战壕面对冷酷而喧嚣的枪林弹火呢。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/01/10/reading-the-captive-mind/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/01/09/visualization-architecture-and-ddd/">可视化架构与DDD</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-01-09T13:57:00+08:00" pubdate data-updated="true">Jan 9<span>th</span>, 2014</time>
        
         | <a href="/blog/2014/01/09/visualization-architecture-and-ddd/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>从DDD的角度，领域逻辑的分析可以运用战略方法Bounded Context。可是，一个问题是：<strong>如何获得Bounded Context ？</strong></p>

<p>我查看了许多关于Bounded Context的书籍与文章，虽然都着重强调了它的重要性，也给出了一些实例，却对如何从需求——>Boundex Context这一点上语焉不详。</p>

<p>我的初步设想是通过绘制场景图（但并不成熟）。我认为有三种绘制场景图的方式：商业画布，体验地图和流程图。我认为，商业画布可以作为需求分析（尤其针对初创产品）的起点。商业画布如下图所示：
<img class="center" src="/images/2014/business_canvas.jpeg"></p>

<p>采用这种规范化的方式来推导商业模型，可以激发我们的灵感，理清我们的思路，以便我们思考为何要做这个产品，产品应该具备哪些功能。结合优点和缺点、成本等因素，我们可以藉此判断和决策功能的优先级，从而得到MVP。这个过程需要大量运用即时贴，让整个商业模型呈现。经过取舍后，就可以针对产品绘制场景图。此时，场景图可以采用Experience Map或流程图来体现。Experience Map的例子如下图所示：
<img class="center" src="/images/2014/experience_map.gif"></p>

<p>由于商业画布本身提供了“客户”项，我们应该创建Persona，找准人物角色的特征来“搜寻”需求。绘制了场景图后，就能够确定用例了，此时，可辅以ATDD帮助确定Story。在确定了用例后，可以识别Bounded Context，并通过Context Map确定上下文之间的关系。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2014/01/09/visualization-architecture-and-ddd/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/12/25/thought-about-applying-tdd/">推行TDD的思考</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-12-25T21:26:00+08:00" pubdate data-updated="true">Dec 25<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/12/25/thought-about-applying-tdd/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>目前来看，推行TDD的障碍大约有如下几点：</p>

<pre><code>1. 开发人员的质量意识；
2. 分析需求并进行任务分解的能力；
3. 将测试作为开发起点的开发习惯；
4. 开发人员的重构能力，包括如何识别坏味道和如何运用重构手法；
5. 单元测试的基础设施，尤其是测试数据准备；
</code></pre>

<h2>开发人员的质量意识</h2>

<p>开发人员对于软件质量，常常偏重于软件的外部质量，体现在他们的工作效益上，就是被测试人员发现的缺陷数。而惯常的软件开发思想，总是认为开发人员不适合做测试，因为他们总是站在自己的角度去看待问题，从而可能忽略真正需要测试的用例。这种思想给了开发人员一个错误信号，认为自己不应该写测试，即使写了测试，也写不好。殊不知，由开发人员编写测试带来的收益，最重要的一点不在于测试本身，而在于它能促进开发、测试以及需求分析人员的交流与沟通。而测试先行的方式也能让开发者跳出实现的窠臼，而从业务角度去看待问题，从消费者角度去思量接口。此外，由于开发者总是惫懒地将测试职责委派给了专门的测试人员，于是渐渐会产生一种依赖心理。测试人员的精确测试当然可以保障质量，但这种测试通常是黑盒测试，这里保障的质量主要还是外部质量。而且，这种测试带来的反馈总是慢于开发进度，一旦发现缺陷，修复缺陷的成本也会变得更高。</p>

<p>软件质量除了外部质量之外，内部质量同等重要。软件成本等于开发成本与维护成本之和，而维护成本的增加主要就归咎于内部质量的糟糕。这里讲的内部质量包括：代码的可读性、可重用性、可扩展性等。当我们让开发人员为原有代码编写单元测试时，总是觉得举步维艰。分析原因，主要问题在于代码的可测试性不好。要测试一个类，竟然连简单创建它的对象都变成了不可能完成的任务。我们为这样的代码编写单元测试，就好像在触及蜘蛛网，一旦被这些网丝给牵住，缠住，就可能无法摆脱。除非我们能够快刀斩乱麻，那对于这个系统而言，就不是维护，而是重写了。测试先行的开发至少在一定程度规避了这样的问题。即使代码的内部质量仍有所欠缺，但在足够覆盖率的保护下，我们要进行重构也变得更为简单。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/12/25/thought-about-applying-tdd/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/12/24/the-scenarios-for-using-git/">Git的使用场景</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-12-24T21:38:00+08:00" pubdate data-updated="true">Dec 24<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/12/24/the-scenarios-for-using-git/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>无论学习什么技术，都需要了解该技术的本质。若是靠死记硬背该技术提供的方法或者语法，终归是知其然而不知其所以然，当发现错误时，你根本不知道是什么原因导致的。我在使用Git时，就处于这种知其然而不知其所以然的状态。现在，再来补补课。</p>

<p>Git有三个工作区域，分别为：工作目录（Working Directory）、暂存区（Stage或Index）以及资源库（Repository或Git Directory）。下图是文件在这三个工作区域之间的关系：
<img class="center" src="images/2013/lifecycle.png"></p>

<p>参考Pro Git一书，它给出了Git的几个要点：
* 直接快照，而非比较差异：Git与其他版本管理系统的主要差别在于，Git只关心文件数据的整体是否发生了变化，而其他多数版本管理系统则只关心文件内容的具体差异。Git并不保存文件前后变化的差异数据，更像是把变化的文件做一个快照，然后记录在一个微型的文件系统中。每次提交更新时，会比较这个快照。若文件没有变化，Git则只对上次保存的快照作一个链接。你可以理解Git就是一个小型的文件系统。
* 近乎所有操作都可本地执行：无需多说，这本身就是分布式版本管理系统的特征。
* 时刻保持数据完整性：保存到Git前，所有数据都要进行内容的校验和（checksum），并将该结果作为数据的唯一标识。Git使用了SHA-1算法计算数据的校验和，并将该结果作为索引，而非文件名。
<img class="center" src="images/2013/git-hash.png">
* 多数操作仅添加数据</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/12/24/the-scenarios-for-using-git/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/21/play-trick-with-powermock/">玩花招的PowerMock</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-11-21T12:42:00+08:00" pubdate data-updated="true">Nov 21<span>st</span>, 2013</time>
        
         | <a href="/blog/2013/11/21/play-trick-with-powermock/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>当我们面对一个遗留系统时，常见的问题是没有测试。正如Michael Feathers在Working Effectively with Legacy Code一书中对“遗留代码”的定义。他将其简单归纳为“没有测试的代码”。真是太贴切了！正是因为没有测试，使得我们对遗留代码的任何重构都有些战战兢兢，甚至成为开发人员抵制重构的借口。从收益与成本的比例来看，对于这样的系统，我一贯认为不要盲目进行重构。因为重构的真正适用场景其实是发生在开发期间，而非维护期间。当然，提升自己的重构能力，尤其学会运用IDE提供的自动重构工具，可以在一定程度上保障重构的质量。然而，安全的做法，还是需要为其编写测试。</p>

<p>测试是分层的，即使是针对自动化测试。面对遗留系统，成本相对较低的是针对功能特性编写的功能测试（或者说是验收测试），这可以运用一些BDD框架如Cucumber、JBehave等。由于它的测试粒度较粗，可以以较少的测试用例覆盖系统的主要功能。然而，它的缺点同样存在，那就是反馈周期相对较长。这就好像你置身一个陌生的城市，在找不到路的情况下，只是跟着感觉走。走了数十公里之后，方才幡然醒悟，想起要翻一翻带在手上的地图。倘若发现方向走错，再要回转就已经晚了。反馈周期最短的自然是单元测试。同样根据Michael Feather的定义，单元测试一定要快，一定要不依赖于外部资源。单元测试的粒度自然是最小的，但不要直观地认为单元测试就是针对方法。若只是针对方法来编写单元测试，就会陷入为测试而测试的怪圈。即使是位于技术象限的单元测试，我们仍然要按照业务规则来编写。一个测试方法应该对应一个粒度最小的原子功能。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/11/21/play-trick-with-powermock/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2013/11/10/create-two-jars-from-one-project-using-maven/">使用Maven为一个项目生成多个Jar包</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-11-10T22:43:00+08:00" pubdate data-updated="true">Nov 10<span>th</span>, 2013</time>
        
         | <a href="/blog/2013/11/10/create-two-jars-from-one-project-using-maven/#disqus_thread">Comments</a>
        
      </p>
    
  </header>


  <div class="entry-content"><p>虽然在Java平台下，各种构建工具如Maven、Gradle、SBT已经得到了较为广泛地运用，同时Maven约定的模块目录结构也得到了业界的认可，成为了Java平台下项目结构的事实标准。但我们总无法避免与各种遗留系统或老系统打交道。在没有Maven的时代，是Ant统治的时代，它因为提供了较为灵活的编写Task的功能，而忽略了制定一套看似呆板，实则有效的标准模板。于是，在不同的企业，不同的Java项目，出现了各种各样奇怪的目录结构与打包要求。拖着这些沉重的历史包袱，我们自然希望彻底革命，把那些看不顺眼的东西全部改造，让整个项目焕然一新。这是好事儿，所谓长痛不如短痛，一下子把问题肿瘤给割了，痛快！可是现实总有那么一些阻力会让我们缩手缩脚，我们不能挥起革命的利刃一阵乱砍，这弄不好会砍伤自己的手。于是乎，我们需要做战略性的撤退。退一步海阔天空嘛。</p>

<p>我面对的就是这样一个软件系统。这个Java开发的软件系统一直没有依赖管理，仅仅编写了Ant任务用于发布打包。我们的任务是渐进地引入Maven，并在从Build到deploy的整个生命周期中，逐步替换Ant，与持续集成搭配起来。这个系统的多数模块都划分了服务端与客户端。然而不巧的是，各个模块的服务端和客户端都集中在一个模块中。同时，这个项目的目录结构并非标准的Maven结构，如下图所示。因此，还需要自定义Source与TestSource的目录结构。在原来的Ant任务中，是将它们打包成了两个Jar包。现在，我们需要在Maven中同样做到这一点。</p>

</div>
  
  
    <footer>
      <a rel="full-article" href="/blog/2013/11/10/create-two-jars-from-one-project-using-maven/">阅读全文 &rarr;</a>
    </footer>
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/blog/page/2/">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <div align="center">
  	<p><img src="/images/profile/profile.png" align="center"/></p>
  	<p><strong>Company: </strong>ThoughtWorks<br>
  	<strong>Role: </strong>Senior Consultant</p>  
  </div>
  <script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38898311-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/01/17/jump-out-of-comfort-zone/">跳出舒适区</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/16/actor-and-its-supervisors-of-akka/">Akka的Actor及其Supervisors</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/13/testing-styles-of-scalatest/">ScalaTest的测试风格</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/11/excerpt-from-barone-rampante/">摘录《树上的男爵》</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/01/10/reading-the-captive-mind/">读《被禁锢的头脑》</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating&#8230;</li>
  </ul>
  
  <a href="https://github.com/agiledon">@agiledon</a> on GitHub
  
  <script type="text/javascript">
    $.domReady(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'agiledon',
            count: 5,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>

<section>
  <h1>Tag Cloud</h1>
  <ul class="tag-cloud">
<a style="font-size: 100%" href="/blog/tags/api/">API</a>
<a style="font-size: 100%" href="/blog/tags/agilechina/">AgileChina</a>
<a style="font-size: 205%" href="/blog/tags/architecture/">Architecture</a>
<a style="font-size: 100%" href="/blog/tags/big-data/">Big Data</a>
<a style="font-size: 100%" href="/blog/tags/book/">Book</a>
<a style="font-size: 100%" href="/blog/tags/cqrs/">CQRS</a>
<a style="font-size: 144%" href="/blog/tags/csharp/">CSharp</a>
<a style="font-size: 128%" href="/blog/tags/coach/">Coach</a>
<a style="font-size: 164%" href="/blog/tags/coding/">Coding</a>
<a style="font-size: 202%" href="/blog/tags/design/">Design</a>
<a style="font-size: 128%" href="/blog/tags/design-patterns/">Design Patterns</a>
<a style="font-size: 128%" href="/blog/tags/dotnet/">DotNET</a>
<a style="font-size: 128%" href="/blog/tags/dotnet/">DotNet</a>
<a style="font-size: 100%" href="/blog/tags/extjs/">ExtJS</a>
<a style="font-size: 100%" href="/blog/tags/gae/">GAE</a>
<a style="font-size: 100%" href="/blog/tags/go/">GO</a>
<a style="font-size: 100%" href="/blog/tags/geek/">Geek</a>
<a style="font-size: 100%" href="/blog/tags/hdfs/">HDFS</a>
<a style="font-size: 128%" href="/blog/tags/hadoop/">Hadoop</a>
<a style="font-size: 128%" href="/blog/tags/infoq/">InfoQ</a>
<a style="font-size: 177%" href="/blog/tags/java/">Java</a>
<a style="font-size: 100%" href="/blog/tags/javascript/">JavaScript</a>
<a style="font-size: 100%" href="/blog/tags/language/">Language</a>
<a style="font-size: 155%" href="/blog/tags/literature/">Literature</a>
<a style="font-size: 128%" href="/blog/tags/mvc/">MVC</a>
<a style="font-size: 100%" href="/blog/tags/mapreduce/">MapReduce</a>
<a style="font-size: 128%" href="/blog/tags/mock/">Mock</a>
<a style="font-size: 100%" href="/blog/tags/mysql/">MySQL</a>
<a style="font-size: 100%" href="/blog/tags/nosql/">NoSQL</a>
<a style="font-size: 128%" href="/blog/tags/notes/">Notes</a>
<a style="font-size: 128%" href="/blog/tags/novel/">Novel</a>
<a style="font-size: 100%" href="/blog/tags/nutch/">Nutch</a>
<a style="font-size: 155%" href="/blog/tags/oo/">OO</a>
<a style="font-size: 144%" href="/blog/tags/octopress/">Octopress</a>
<a style="font-size: 100%" href="/blog/tags/poem/">Poem</a>
<a style="font-size: 100%" href="/blog/tags/rest/">REST</a>
<a style="font-size: 192%" href="/blog/tags/reading/">Reading</a>
<a style="font-size: 155%" href="/blog/tags/reading-radar/">Reading Radar</a>
<a style="font-size: 164%" href="/blog/tags/refactoring/">Refactoring</a>
<a style="font-size: 144%" href="/blog/tags/responsibility/">Responsibility</a>
<a style="font-size: 128%" href="/blog/tags/ruby/">Ruby</a>
<a style="font-size: 171%" href="/blog/tags/scala/">Scala</a>
<a style="font-size: 100%" href="/blog/tags/scalability/">Scalability</a>
<a style="font-size: 100%" href="/blog/tags/spray/">Spray</a>
<a style="font-size: 100%" href="/blog/tags/struts/">Struts</a>
<a style="font-size: 164%" href="/blog/tags/tdd/">TDD</a>
<a style="font-size: 100%" href="/blog/tags/thinking/">Thinking</a>
<a style="font-size: 128%" href="/blog/tags/thought/">Thought</a>
<a style="font-size: 164%" href="/blog/tags/thoughtworks/">ThoughtWorks</a>
<a style="font-size: 100%" href="/blog/tags/transaltion/">Transaltion</a>

  </ul>
</section>
<section>
  <h1>Sina Weibo</h1>
    <iframe id="sina_widget_1780465612" style="width:100%; height:500px;" frameborder="0" scrolling="no" src="http://v.t.sina.com.cn/widget/widget_blog.php?uid=1780465612&height=500&skin=wd_01&showpic=1"></iframe>
</section>

<section class="googleplus">
  <h1>
    <a href="https://plus.google.com/bruce.e.zhang@gmail.com?rel=author">
      <img src="http://www.google.com/images/icons/ui/gprofile_button-32.png" width="32" height="32">
      Google+
    </a>
  </h1>
</section>



<section>
  <h1>Visitor</h1>
  <div><a href="https://www.google.com/analytics/web/?hl=zh-CN#savedreport/-74rj-TaSR2-OlraMB4ZZQ/a38898311w67651546p69626158/%3F_r.dsa%3D1%26_.advseg%3D%26_.sectionId%3D/" target="_blank"><img src="/images/googleanalytics.png"/></a></div>
    <div id="clustrmaps-widget"></div><script type="text/javascript">var _clustrmaps = {'url' : 'http://agiledon.github.com', 'user' : 1081379, 'server' : '4', 'id' : 'clustrmaps-widget', 'version' : 1, 'date' : '2013-02-27', 'lang' : 'en', 'corners' : 'square' };(function (){ var s = document.createElement('script'); s.type = 'text/javascript'; s.async = true; s.src = 'http://www4.clustrmaps.com/counter/map.js'; var x = document.getElementsByTagName('script')[0]; x.parentNode.insertBefore(s, x);})();</script><noscript><a href="http://www4.clustrmaps.com/user/63d108023"><img src="http://www4.clustrmaps.com/stats/maps-no_clusters/agiledon.github.com-thumb.jpg" alt="Locations of visitors to this page" /></a></noscript>
</section>


  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - 张逸 -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  

<script type="text/javascript">
      var disqus_shortname = 'agiledon';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = 'http://' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
